

go语言高级编程

2020.1.19
柴树杉　　曹春晖


第１章语言基础

类c语言

自带的标准库的net/http包构造了一个独立运行的http服务。
其中http.HandleFunc("/",...)
针对/根路径请求注册了响应处理函数。
在相应处理函数汇总，我们依然使用fmt.Fprintf格式化输出函数
实现了通过http协议向请求的客户端打印格式化的字符串，
同时通过标准库的日志包在服务器端也打印相关字符串。
最后通过http.ListenAndServe　函数调用用来启动http服务

1.3 数组，字符串和切片


在主流的编程语言中，数组是使用最频繁的。

Go语言汇总数组，字符串和切片三者是密切相关的数据结构。


这三种数据类型，在底层原始数有着相同的内存结构，
在上层，因为语法的限制有着不同的行为表现。
首先,Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是
数组本身的赋值和函数传参都是以整体复制的方式处理的，
Go语言字符串底层数据也是对应的字节数组，但是
字符串的只读属性禁止了在程度中对底层字节数组的
元素的修改。
字符串赋值只是复制了数据地址和对应的长度，
而不会导致底层数据的复制


切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制，
切片的底层数据虽然也是对应数据类型的数组，
但是每个切片还有独立的长度和容量信息，切片赋值和函数传参时
也是将切片信息部分按传值方式处理。因为切片头还有底层数据的指针，
所以它的赋值也不会导致底层数据的赋值。其实Go语言
的赋值和函数传值规则很简单，除了闭包函数以引用的方式对外部变量访问
之外，其它赋值和函数传参数都是传值的方式处理。
要理解数组，字符串和切片三种不同的处理方式的原因

１.3.1 数组

数组是由一个固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成
数组的长度是数组类型的组成部分。因为数组的长度是数组类型的一个部分，不同
长度或不同类型的数据组成的数组是不同的乐行，因此在go语言中很少会直接使用
数组(不同长度的数组因为类型不同无法直接赋值)

和数组对应的类型是切片，切片是可以动态增长和收缩的序列，切片的功能也更加灵活

var a [3]int //定义长度为３的int型数组，元素全为０

这是定义一个数组的最基本的方式，数组的长度明确指定，数组中的每个元素都以零值初始化


var b = [...]int{1,2,3} //定义长度为３的int型数组，元素为1,2,3


定义数组，可以在定义的时候顺序指定全部元素的初始化值，数组的长度根据初始化元素的
数目自动计算


var c =[...]int{2:3,1:2} //定义长度为３的int型数组，元素为0,2,3


以索引的方式初始化来初始化数组的元素，因此元素的初始化值出现顺序比较随意，
这种初始化方式和map[int]Type类型的初始化语法类似，数组的长度以出现的
最大的索引为准，没有明确出初始化元素依然０值初始化


var d = [...]int{1,2,4:5,6} // 定义长度为6的int型数组，元素为１，２，０，０，５，６

上面混合了第二种和第三种的初始化方式，前面两个元素采用顺序初始化，第三和第四个元素
零值初始化，第五个元素通过索引初始化，最后一个
元素跟在起前面的第五个元素值采用顺序初始化


数组的内存结构比较简单。 
[4]int{2,3,5,6}

go语言中的数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的
指针(比如C语言的数组)
而是一个完整的值。当一个数组变量被赋值或被传递的时候，实际上会复制整个数组，
如果数组较大，数组的赋值也会有较大的开销。
为了避免赋值数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组

var a = [...]int{1,2,3} // a是一个数组
var b =&a // b是指向数组的指针


fmt.Println(a[0],a[1]) // 打印数组的前２个元素
fmt.Println(b[0],b[1]) //通过数组指针访问数组元素的方式和数组类似


for i,v := range b {
	//通过数组之后怎迭代数组的元素
	fmt.Println(i,v)
}

其中b是指向a数组的指针，但是通过b访问呢数组中元素的写法和a类似。
还可以通过for range 来迭代数组指针指向的数组元素。
其实数组指针类型除了类型和数组不同之外，通过数组指针操作数组的方式和通过数组本身的
操作类似，而且数组指针赋值时只会拷贝一个指针。
但是数组指针类似依然不够灵活，因为数组的长度是数组类型的组成部分，
指向不同长度数组的数组指针类型也是完全不同的

可以将数组看作一个特殊的结构体，结构的字段名对应数组的索引，同时结构体成员的数目是固定的
内置函数len可以用于计算数组的长度，cap函数可以用于计算数组的容量。
不过对于数组类型来说，len和cap函数返回的结果始终是一个样的，都是对应数组类型的长度


我们可以用for循环来迭代数组

几种方式都可以用来遍历数组


for i:=range a{
	fmt.Println("a[%d]:%d\n",i,a[i])


}


for i,v := range b{
	fmt.Printf("b[%d]:%d\n",i,v)
}


for i := 0; i<len(c);i++{
	fmt.Printf("c[%d]:%d\n",i,c[i])
}



用for range方式迭代的性能可能会更好一些，因为这种迭代可以保证不会出现
数组越界的情形，每轮迭代对数组元素的访问时可以省去对下标越界的判断

用for range 方式迭代，还可以忽略迭代时的下标

var times [5][0]int
for range times{
	fmt.Println("hello")
}


其中times对应一个[5][0]int类型的数组，虽然第一维度数组有长度，但是数组的元素
[0]iunt大小是0，因此整个数组占用的内存大小依然是0
没有付出额外的内存代价，我们就通过for range 方式实现了times次快速迭代


数组不仅仅可以用于数值类型，还可以定义字符串数组，结构体数组，函数数组，
接口数组，管道数组等


//字符串数组

var s1 = [2]string{"hello","world"}

var s2 = [...]string{"你好","世界"}
var s3 = [...]string{1:"世界",0:"你好",}

//结构体数组

var line1 [2]image.Point
var line2 = [...]image.Point{image.Point{X:0,Y:0},image.Point{X:1,Y:1}}
var line3 = [...]image.Point{{0,0},{1,1}}

//图像解码器数组


var decoder1 [2]func(io.Reader) (image.Image,error)
var decoder2 = [...]func(io.Reader)(image.Image,error){
	png.Decode,
	jpeg.Decode,
}


//接口数组

var unknown1 [2]interface{}

var unknown2 = [...]interface{}{123,"你好"}


//管道数组

var chanList = [2]chan int{}



我们还定义一个空的数组


var d[0]int //定义一个长度为０的数组
var e = [0]int{} //定义一个长度为０的数组

var f= [...]int{} //定义一个长度为０的数组


长度为０的数组在内存中并不占用空间。空数组虽然很少直接使用，但是可以用于强调
某种特有类型的操作时避免分配额外的内存空间，比如用于管道的同步操作



c1 := make(chan [0]int)
go func(){
	fmt.Println("c1")
	c1 <- [0]int{}
}()

<-c1


我们不关心管道中传输数据的真实类型，其中管道接收和发送操作只是用于消息的
同步。对于这猴子那个场景，我们用空数组来作为管道类型可以减少管道元素
赋值时的开销。一般更倾向于用无类型的匿名结构体代替

c2 := make(chan struct{})
go func(){
	fmt.Println("c2")
	c2 <- struct{}{} //struct{}部分是类型，{}表示对应的结构体值
}()
<-c2

我们可以用fmt.Printf函数提供的%T或%#v谓词语法来打印数组的类型和详细信息

fmt.Printf("b:%T \n",b) //b:[3]int
fmt.Printf("b:%#v\n",b) // b: [3]int{1,2,3}


在go语言中，数组类型是切片和字符串等结构的基础。

以上数组的很多操作都可以直接用于字符串或企鹅品种


１．３．２　　字符串

一个字符串是一个不可改变的字节序列，字符串通常是用来包含人类刻度的文本数据，
和数组不同的是，字符串的元素不可修改，是一个只读的字节数组。

每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分。
由于go语言的源代码要求是utf8编码，导致go源代码中出现的字符串面值常量一般也是utf8编码

源代码中的文本字符串通常被解释为采用utf8编码的Unicode码点(rune)序列。

因为字节序列对应的是只读的字节序列，因此字符串可以包含任意的数据，
包括byte值0。我们也可以用字符串表示GBK等非UTF8编码的数据，
将字符串看作是一个只读的二进制数组更准确，因为for range等语法并不能支持非utf8编码的
字符串的遍历


go语言字符串的底层结构在reflect.StringHeader中

type StringHeader struct{
	Data uintptr
	Len int
}

字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的
字节的长度。字符串其实是一个结构体，因此字符串的赋值操作也就是reflect.String

var data = [...]byte{
	'h','e',}


字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据(因为
字符串是只读的，相同的字符串面值常量是对应同一个字符串常量)


p34












