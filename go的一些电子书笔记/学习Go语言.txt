

学习Go语言


go的前身来自于Inferno。Inferno包含了一个叫做Limbo的语言

Limbo是用于开发运行在小型计算机上的分布式应用的编程语言。它支持模块化编程，
编译器和运行时的强类型检查，进程内基于具有类型的channel通讯，原子性垃圾收集，和简单
的抽象数据类型。它被设计用于即便是没有永健内存保护的小型设备上，也能安全运行

go从Limbo继承的另一个特性是channel,

channel是用于向系统中其他代理发送和接收特定类型对象的通讯机制。
channel可以用于本地进程间通讯；用于连接到命名的目的地的库方法。
两种情况都是直接发送和接收操作的

使用channel与其他进程进行通讯叫做"通讯序列化过程"(Communicating Sequential Processes-CSP)

GO是第一个实现了简单的并行开发，且跨平台的类c语言


基础

go的特点

1.并行

go让函数很容易成为非常轻量的线程。这些线程在go中叫做goroutine

2.channel
	这些goroutines之间的通讯由channel完成

3.编译很快，执行也很快

4.安全

	当转换一个类型到另一个类型的时候需要显式的转换并遵循严格的规则
	go有垃圾收集，在go中无须free(),语言会处理一切


5.标准格式化

6. 类型后置

	类型在变量名的后面， var a int

7.UTF-8
	任何地方都是UTF-8的，包括字符串以及程序代码

变量，类型和保留字

func用于定义函数和方法
return用于从函数返回
go用于并行
select 用于选择不同类型的通讯
struct用于抽象数据类型
goto，用于跳转到一定是当前函数内定义的标签

for init;condition;post{}
for condition{}
for {}

利用break可以提前退出循环，break终止当前的循环

range，用于循环。可以在slice,array,string,map,channel
range是个迭代器，当被调用的时候，从它循环的内容中返回一个键值对。
基于不同的内容，range返回不同的内容

当对slice或array做循环时，range返回序号作为键，这个序号对应的
内容作为值

switch,表达式不必是常量或整数，执行的过程从上至下，直到
找到匹配项，而如果switch没有表达式，它会匹配true

用default可以指定当前其他所有分支都不匹配的时候的行为


内建函数

预定义了少数函数，这意味着不需引用任何包就可以使用它们

close new panic complex delete make
recover real len append print imag 
cap  copy println



close,用于channel通讯。使用它来关闭channel

delete ,用于在map中删除实例
len和cap，可用于不同的类型，len用于返回字符串,slice,数组的长度


new 用于各种类型的内存分配
make 用于内建类型(map,slice,channel)的内存分配

copy，用于复制slice

append,用于追加slice

panic,recover,用于异常处理机制，恐慌与恢复

print,println是底层打印函数，可以在不引入fmt包的情况下使用，它们主要用于调试
complex,real,imag全部用于处理复数

array,slices,map

可以利用array在列表中进行多个值的排序，或使用更加灵活的：slice,
字段或哈希类型同样可以使用，叫做map


array由[n]<type>定义，n标示array的长度，而<type>标示希望存储的内容的类型
对array的元素赋值或索引是由方括号完成的


slice与array接近，但是在新的元素加入的时候可以增加长度。
slice总是指向底层的一个array.slice是一个指向array的指针，这是其与array不同的地方；
slice是引用类型，这意味着当赋值某个slice到另外一个变量，两个引用会指向同一个array.
例如，如果一个函数需要一个slice参数，在其内对slice元素的修改
也会体现在函数调用者中，这和传递底层的array指针类似

slice总是与一个固定长度的array成对出现。其影响slice的容量和长度

函数append向slices追加零值或其他x值，并且返回追加后的新的，与s有相同类型的slice.
如果s没有足够的容量存储追加的值，
append分配一个足够大的，新的slice来存放原有slice的元素和追加的值。
返回的slice可能指向不同的底层array


函数copy从源slice src复制到目标dst，并且返回复制的元素的个数。
源和目标可能重叠。复制的数量是len(src)和len(dst)中的最小值

map可认为是一个用户字符串索引的数组(在其最简单的形式下)


3.函数

函数是构建go程序的基础不见

命名返回值

go函数的返回值或结果参数可以指定一个名字，
如果对其命名，在函数开始时，它们会用其类型的零值初始化；
如果函数在不加参数的情况下执行了return语句，结果参数
的当前值作为返回值返回。用这个特性，允许(再一次的)用较少
的代码做更多的事

由于命名结果会被初始化并关联于无修饰的return


延迟代码

假设有一个函数，打开文件并且对其进行若干读写。在这样的函数中，
经常有提前返回的地方。
如果这样做，就需要关闭正在工作的文件描述符。

go有defer,在defer后指定的函数会在函数退出前调用

将Close对应的放置于Open后，能够使函数更加健壮
可以将多个函数放入"延迟列表"中

延迟的函数是按照后进先出(LIFO)的顺序执行

利用defer甚至可以修改返回值，
defer func

变参

接受变参的函数是有着不定数量的参数的。
首先需要定义函数使其接受变参

func myfunc(arg ...int){}

arg...int告诉go这个函数接受不定数量的参数。注意，这些参数的
类型全部是int.在函数体中，变量arg是一个int类型的slice:

for _, n := range arg{
	fmt.Printf("And the number is:%d\n",n)
}



如果不指定变参的类型，默认是空的接口interface{}

函数作为值

也可以编写一个接受函数作为参数的函数，例如，用于操作int类型的
slice的Map函数

回调

当函数作为值时，就可以很容易的传递到其他函数里，然后可以作为回调。
首先定义一个函数，对整数做一些"事情"
func callback(y int,f func(int)){
	f(y)
}

panic,recover


go没有像java那样抛出一个异常机制：不能抛出一个异常，
作为替代，它使用了panic,recover,

panic,
	是一个内建函数，可以中断原有的控制流程，进入一个令人
	恐慌的流程中。当函数F调用panic,函数F的执行被中断，
	并且F中的延迟函数会正常执行，然后F返回到调用它的地方，
	在调用的地方，F的行为就像调用了panic,
	这一过程继续向上，直到程序崩溃时的所有goroutine返回
	panic可以直接调用panic产生。也可以由运行时错误产生
	例如访问越界的顺组

Recover
	是一个内建的函数，可以让人进入令人恐慌的流程中的goroutine
	恢复过来。recover仅在延迟函数中有效


在正常的执行过程中，调用recover会返回nil并且没有任何效果。
如果当前的goroutine陷入恐慌，调用recover可以捕获到panic
的输入值，并且恢复正常的执行

这个函数检查作为其参数的函数在执行时是否会产生panic

定义一个新函数throwsPanic接受一个函数作为参数，
当这个函数产生panic,就会返回true,否则返回false

定义一个利用recover的defer函数，如果当前的goroutine产生了panic

这个defer函数能够发现，当recover()返回非nil值，设置b为true

调用作为参数接收的函数

返回b的值。由于b是命名返回值

用new分配空间，创建指针指向的stack的空间，

4.包

包是函数和数据的集合。用package保留字定义一个包。文件名不需要与
包名一直。包名的约定是使用小写字母。go包可以由多个文件组成，但是使用
相同的package<name>这一行。

包名的约定是使用小写字符。go包可以由多个文件组成，但是使用个相同的package<name>

在go中，当函数的首字母大写的时候，函数会被从包中管道处(从包外部课件，或公有)

公有函数的名字以大写字母开头
私有函数的名字以小写字母开头


标识符，当包导入(通过import)时，包名成为了内容的入口

导入包的可以调用函数bytes.Buffer.任何使用这个包的人，可以使用
同样的名字访问它的内容。

包的文档

每个包都应该有包注释

每个定义(并且导出)的函数应当有一小段文字描述该函数的行为

测试包

在go中为包编写单元测试应该是


fmt包 ，实现了格式化的I/O函数

io,这个包提供了原始的I/O操作界面。它主要的任务是对os包这样的原始I/O进行风胡子那个
	，增加一些其他相关，使其具有抽象功能用在公共的接口上

bufio
	这个包实现了缓冲的I/O。它封装与io.Reader和io.Writer对象，创建了
	另一个对象(Reader和Writer)在提供缓冲的同时实现了一些文本I/O的功能

sort
	sort包提供了对数组和用户定义集合的原始的排序功能
strconv
	strconv包提供了将字符串转换成基本数据类型，或从基本数据类型转换为
	字符串的功能

os
	os包提供了与平台无关的操作系统功能接口，其设计是Unix形式
sync
	sync包提供了基本的同步原语，例如互斥锁

flag
	flag包实现了命令行解析，
encoding/json
	encoding/json包实现了编码与解码定义的JSON对象

text/template
	数据驱动的模板，用于生成文本输出，例如HTML
	将模板关联到某个数据结构上的进行解析。模板内容指向数据结构的
	元素(通常结构的字段或map的键)控制解析并且决定某个值被显示。
	模板扫描结构以便解析，而"游标"决定了当前位置在结构中的值

net/http
	net/http实现了HTTP请求响应和URL的解析，并且提供了可扩展的HTTP服务
	和基本的HTTP客户端


unsafe
	unsafe包包含了go程序中数类型上所有不安全的操作，通常无须使用这个


reflect

	reflect包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理
	静态类型interface{}的值，并且通过Typeof解析出其动态类型嘻嘻，通常会返回
	一个有接口类型Type的对象

os/exec
	os/exec包执行外部命令


5.进阶
go有指针，但是没有指针运算。不能用指针遍历遍历字符串的各个字节


内存分配

go同样也有垃圾手机，无须担心内存分配和回收

go有两个内存分配原语，new，make


用new分配内存，new(T)分配了零值填充的T类型的内存空间，并且返回
其地址，一个*T类型的值。它返回了一个指针，指向新分配的类型T的零值

new返回指针

这意味这使用者可以用new创建一个数据结构的实例并且可以直接工作
bytes.Buffer的文档所述Buffer的零值是一个准备好了的空缓冲。
sync.Mutex没有明确的构造函数或Init方法，取而代之，sync.Mutex的零值
被定义为非锁定的互斥量

SynceBuffer的值在份额内存或定义之后立刻就可以使用

用make分配内存

回到内存分配。内建函数make(T,args)与new(T)有着不同的功能，它只能创建
slice,map,channel，并且返回一个初始值(非零)的T类型，而不是*T
本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。
例如，一个slice，是一个包含指向数据(内部array)的指针，长度和容量
的三项描述符：在这些项目被初始化之前，slice为nil.对于slice,map和channel
,make初始化了内部的数据结构，填充适当的值

make返回初始话后的(非零)值

例如，make([]int,10,100)分配了100个整数的数组，然后用长度10和容量100
创建了slice结构指向数组的前10个元素。区别是，new([]int)返回指向新分配
的内存的指针，而零值填充的slice结构是指向nil的slice值

务必记得make仅适用于map,slice,channel，并且返回的不是指针。应当用new获得
特定的指针


new分配;make初始化


new(T):返回*T 指向一个零值T
make():返回初始化后的T

make仅适用于slice,map,channel

构造函数与符合声明


有时零值不能满足需求，必须要有一个初始化的构造函数，

在特定的情况下，如果符合声明不包含任何字段，它创建特定类型的零值。
表达式new(File)和&File{}是等价的

复合声明同样可以用于创建array,slice,map,通过指定适当的索引和map键来
标识字段。

定义自己的类型

go允许定义新的类型，通过保留字type实现：
type foo int

创建了一个新的类型foo作用跟int一样。创建更加复杂的类型需要用到struct保留字

结构字段

方法

可以对新定义的类型创建函数以便操作，可通过两种途径：
1.创建一个函数接受这个类型的参数

2. 创建一个工作在这个类型上的函数

类型转换


首先，将一个值转换为另一个由操作符(比如,byte())完成，
并且不是所有的转换都是允许的


关于数值，定义了下面的转换

1.将整数转换到指定的(bit)长度：unit8(int)
2.从浮点数到整数：int(float32)。这会阶段浮点数的小数部分
3. 其他的类似：float32(int)


用户定义类型的转换

6. 接口


每个类型都有接口，意味着对那个类型定义了方法集合。

定义一个函数接受一个接口类型作为参数
p实现了接口I,必须有Get()方法
Put()方法是类似的

方法就是有接受者的函数

可以在任意类型上定义方法(除了非本地类型，包括内建类型：int类型不能有方法)
然而可以新建一个拥有方法的整数类型

接口类型的方法

接口定义为一个方法的集合。方法包含实际的代码。一个接口就是定义，而方法就是实现。
因此，接收者不能定义为接口类型，这样做的话会报错


接收者类型必须是T或*T,这里的T是类型名。T叫做接收者基础类型或基础类型。
基础类型一定不能是指针或接口类型，并且定义在与方法相同的包中

接口指针

在go中创建指向接口的指针是无意义的，实际上创建接口值的指针也是非法的


并发是关于性能的，并发是关于程序设计的，
go中使用channel,goroutine是并发的核心

goroutine与其他goroutine并行执行的，有着相同地址空间的函数。它轻量级的，
仅比分配栈空间多一点点消耗。而初始时栈是很小的，所以它们也是廉价的，并且随着需要在堆空间上分配和释放
goroutine是一个普通的函数，只是需要使用保留字go作为开头

8. 通讯

go与外部通讯的通讯模块。要了解文件，目录，网路通讯和运行其他程序。Go的I/o核心接口io.Reader和io.Writer

在go中，从文件读取(或写入)是非常容易的，程序只需要使用os包就可以从文件/etc/passwd中读取数据


打开文件，os.Open返回一个实现了io.Reader和io.Writer的*os.File
确保关闭了f；
一次读取1024字节
到达文件末尾
将内容写入os.Stdout

如果想要使用缓冲IO,则有bufio包

io.Reader

许多函数都是通过io.Reader读取一些数据作为输入
为了满足这个接口，只需要实现一个方法：Read(p []byte)(n int,err error)

写入则是Write方法的io.Writer
如果让你自己的程序或包中的类型实现了io.Reader或io.Writer接口，那么整个go标准库都可以使用这个类型

命令行参数

来自命令行的参数在程序中通过字符串slice os.Args获取，导入包os即可

flag包有精巧的接口，同样提供了了解析标识的方法


执行命令

os/exec包有函数可执行外部命令，这也是在go中主要的执行命令的方法

铜鼓欧定义一个有着数个方法的*exec.Cmd结构来使用

网络

所有网络相关的类型和函数可以在net包中找到，这其中最重要的函数是Dial.
当Dial到远程系统，这个函数返回Conn接口类型，可以用于发送或接收消息
函数Dial简洁的抽象了网络层和传输层。因此，IPV4,IPV6,TCP,UDP可以共用一个接口

通过TCP连接到远程系统(端口80),然后UDP,最后是TCP通过IPV6

如果没有错误(由e返回)，就可以使用conn 从套接字中读写，在包net中原始定义




