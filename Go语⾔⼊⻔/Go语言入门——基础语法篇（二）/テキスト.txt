Go语言入门——基础语法篇（二）

基础语法

注释
变量
变量声明
初始化
多变量赋值

常量
枚举

数据类型
字符
字符串
数组
切片
从数组创建切片
直接创建切片
切片的操作
字典，映射

分支与循环
if分支
switch分支
goto跳转
循环


函数


定义函数
函数的不定参
匿名函数与闭包
函数作为参数传递

go语言函数使用小细节


包
自定义包
包的几种导入方式
包的初始化函数
go语言的入口

go，其声明变量时，类型定义在变量名之后

变量申请


使用关键字var，并将类型放在变量名之后

我们直到在c语言中，变量声明必须初始化再使用，否则变量会带有随机的值
go语言的编译器则会在声明变量时对变量做零值初始化，这解决了c语言的缺陷

字符串的零值是一个空字符串"",
数组则是已经开辟了空间，且每个元素的值都是零值，
指针的零值则是0
这里v4变量的类型是切片，实际就是一个指针


同时声明多个变量

//不同类型

var (
	v1 int
	v2 string
)

//相同类型
var i,j,k int

初始化
使用:= 操作符，可以做短变量声明


var v1 int= 10//声明变量的同时初始化
var v2 = 10 //让编译器自动推导类型

v3 := 10 //省略关键字var和类型，让其自动推导而理性


多变量赋值
//先声明，再赋值

var i,j,k int

i,j,k = 2,3,4

//声明的同时赋值，注意使用":="操作符


l,m,n := 7,8,9

常量　

使用const关键字声明常量，声明常量时也可以省略类型定义，如果
想要明确具体类型，提供代码可读性，也可以显式指定类型

const Pi float64 = 3.14

const zero =0.0 //浮点常量

const (
	size int64 = 1024
	eof = -1 // 整型常量
)


// u = 0.0 ,v =3.0 常量的多重赋值

const u,v float32 = 0,3

// a= 3,b =4,c ="foo" 无类型整型和字符串常量、

const a,b,c  =3,4,"foo"


//常量定义的右值可以是一个编译期运算的常量表达式

const mask = 1 << 3

枚举


枚举指一系列相关的常量，比如下面关于一个星期中每天的定义。
同go语言的其他符号一样，以大写字母开头的常量在包外可见

//go 语言中实际上是用整型常量替代枚举


const (
	Sunday = iota
	Monday 
	T	
	W
	T
	F
	S
)

字符

go语言中有两种字符类型，分别是byte,rune,
byte类型就是相当于c语言中的char,表示的是单字节字符，如ascii码，
如果是中文这种，单字节是无法表示的，
就需要多个字节一起来表示

而rune类型则是专门用来表示Unicode字符的，它相当于C语言中的所谓宽字符
即wchar,单个rune就能表示一个中文

字符串
go语言的源代码默认的编码方式就是utf8,这与python一样

我们可以在源代码中直接书写中文字面量

声明并初始化字符串变量

var str1 string= "这是中文"
var str2 string="are you ok?"

//字符串拼接

str3 := str1+str2

go语言吸收了python中字符串切分的语法
注意，字符串切分返回的依然是string类型

不要对中文字符串直接切分操作，会返回乱码

这是因为go语言默认编码是utf8,这是一种多字节编码
通常它使用3个byte来表示要给中文
而字符串切片的就是byte,中文直接切分破坏了每三个byte一组
的完整性。如需对中文字符串切分，必须先强制转换为[]rune类型

go语言中还支持一种反引号括起来的字符串，该字符串还可以包含多行和特殊字符，
双引号括起来的字符串遇到特殊字符需转义，则反引号则不需要

实际上就等同于python中的三引号括起来的字符串，这是一种原始字符串，它会
包含字面量中的格式，即换行和特殊字符

数组

数组是一个具有相同数据类型的元素组成的固定长度和有序集合。数组中包含的每个数据
称为数组元素，包含的元素个数称为数组长度

在go语言中，数组是值类型，长度是类型的组成部分，也就是说[10]int,[20]int是
完全不同的两种数组类型


需要注意，数组作为参数传递时，是值传递，这

所谓值传递即传递的是原始数组的一个复制品，操作复制品，不会改变原始数组，除非是传入数组的指针

切片

数组的长度在定义之后无法再次修改，且数组是值类型，每次传递都产生一份备份，
这是数组的缺陷，而切片正好弥补了数组的这个不足

实际上,go的切片，就是一个动态数组，类似python的List,
可以自动增长

从数组创建切片

切分与数组的区分

var myArray[10]int
var mySlice[]int

数组的中括号中有数字指明数组长度，而切片是没有指定数字的。

go语言汇总，声明数组是不能　省略数组长度的，如果省略，则声明的是切片，不是数组

go语言可以使用myArray[first:last]这样的方式来基于数组生成一个数组切片，
当[]中first或last为0时，可以省略。其中索引是从0开始的，
且包含first索引对应的元素，不包含last索引对应的元素


//基于myArray的所有元素创建数组切片
mySlice = myArray[:]


//基于myArray的前５个元素创建数组切片

mySlice =myArray[:5]


切片处理跟python一样


直接创建切片

使用内置函数make()可以灵活地创建数组切片

//创建一个初始元素个数为5的数组切片，元素初始值为0

mySlice1 := make([]int,5)

//创建一个初始元素个数为５个数组切片，元素初始值为0
//并预留10个元素的存储空间

mySilce2 := make([]int,5,10)

//直接创建并初始化包含５个元素的数组切片

mySilce3 := []int{1,2,3,4,5}

数组切片就向一个指向数组的指针，实际上它拥有自己的数组结构，而不仅仅是指针

数组切片的数据结构抽象为一下３个变量

１．一个指向原生数组的指针
２．数组切片中的元素个数
3.数组切片已分配的存储空间

切片的操作

操作数组元素的所有方法都是用于数组切片，比如数组切片也可以按下标读写元素，
用len()数获取元素个数，并支持使用range关键字来快速遍历所有元素

遍历

for i:=0; i <len(mySlice);i++{
	fmt.Println("mySlice[",i,"]=",mySlice([i]))
}

//range 表达式有两个返回值，第一个是索引，第二个是元素值

for i,v := range mySlice{
	fmt.Println("mySlice[",i,"]=",v)


动态增减元素

可动态增减元素是数组切片比数组更强大的地方。
与数组相比，数组切片多了一个存储能力(capacity)的概念，
即元素个数和分配的空间可以是两个不同的值，合理地设置存储能力的值，
可以大幅降低数组切片内部重新分配内存和搬运内存块的频率，从而大大提高程序性能

分别使len()函数和cap()函数获得切片中元素的个数和切片存储能力的大小

使用append()函数给切片添加元素。要注意append()的第二个参数是一个不定参，可以
按需添加若干个元素，当追加的内容长度超过当前已分配的存储空间(即cap()的值)
数组切片会自动扩容

//添加一个元素

mySlice = append(mySlice,4)

//一次添加三个元素
mySlice =append(mySlice,1,2,3)

mySlice2 := []int{8,9,10}

//给mySlice切片的后面追加另一个数组切片中的所有元素

//因为添加的是一个切片，所以三个点不可省略

mySlice = append(mySlice,mySlice2...)


字段/映射

所谓映射，也就是键值对数据结构。它是pyhon中的字段。java中的HashMap
其他语言中也称关联数组。

go的映射底层是通过Hash表实现的，因此查询性能高效


func main(){
	//声明一个映射变量
	var mapVar1 map[string] int
	

	//使用make函数创建映射
	mapVar1 = make(map[string] int)

	//初始化映射中的键值

	mapVar1["age"] = 18
	mapVar1["id"] = 11

	//使用自动推导声明并创建映射
	mapVar2 := make(map[string] int)

	// 声明，创建并初始化映射

	mapVar3 := map[string] int{
		"age":20,
		"num":1001
}

//	映射的增删改查操作

// 1.增加元素

mapVar2["resId"] = 126
// 2.删除元素，需要指定键

delete(mapVar1,"age")

// 3. 修改元素
mapVar3["num"] = 12


// 4. 查询元素　会返回两个参数，第二个布尔类型，表示查询的键是否存在


value,ok := mapVar1["id"]
if ok{
	//查询的键存在，成功查询到对应的值
}

fmt.Printf("%d,%d",mapVar2,mapVar3)
}


在go语言中强制规定，声明的变量必须使用，否则无法通过编译


分支与循环

if分支

在go中条件语句不需要圆括号，

goto语法主要用于多层循环嵌套时，直接跳出所有的循环，或做返回值的异常处理，
根据不同的返回值，直接跳转到对应的异常处理ｄｉａｍａｎｔｅ，跳过中间的大段代码

循环

for是go中唯一的循环结构。for循环有３个基本使用方式


定义函数

函数的定义格式为:关键字func + 函数名＋参数列表＋返回值类型＋函数体＋返回语句

当函数没有返回值时，则省略返回值声明

go语言和python一样，可以返回多个值


在多返回值中，可以使用_操作符丢弃不需要的

函数的不定参
所谓不定参，是指函数传入的参数个数是不确定的。最典型的不定参函数是Printf,
可以传入任意数量的参数

//定义一个接收不定参的函数


func fun1(args ...int){
	//使用for循环获取不定参数
	for _,arg := range args{
		fmt.Println(arg)
}
}
func main(){
	fun1(1,2,3,4,5)
	fun1(18)
}

形如 ...int格式的类型是作为函数的不定参数类型存在的，它表明不定参数的类型都是int了那些个，
当函数中还有其他参数时，不定参数必须放到参数列表的最后


不定参的传递


如果我们外层的函数只是一个包装，不定参数需要传递给内部的调用的函数，则可以

func fun1(args ...int){
	for _,arg := range args{
		fmt.Println(arg)
}
}


func fun2(args ...int){
	//do something
	//传递不定参数
	fun1(args...)
}

匿名函数和闭包


所谓匿名函数，是指函数名的函数。在go语言中，函数也是一种类型，函数也可以作为
一种参数进行传递，从一个函数传入另一个号桉树，如同c语言中的函数指针或其他
语言的函数式编程。
与c语言不同的是，go的匿名函数可以随时在另一个函数中定义

func main(){
	//定义一个匿名函数，并赋值给变量f1
	f1 := func(a,b int)int{
		return a+b
}

	//通过变量调用匿名函数
	fmt.Println(f1(1,5))

}

与普通函数，相比，匿名函数只是去除了名字，其他没有区别。
除了匿名函数，实际上普通函数也可以赋值给一个变量用于传递


func fun1(args ...int){	
	for _,arg := range args{
		fmt.Println(arg)
}
}

func main(){
	f1 := fun1;
	f1(1,2,3)
}

闭包

通常人们直接将匿名函数理解为闭包

真正的闭包是指一个匿名函数引用了外部变量。匿名函数我们已经知道了，那什么叫做外部变量的引用？

//定义一个计数器函数，它的返回值也是一个函数


func counter() (func()int){
	var i int = 0
	//匿名函数引用了一个外部变量i
	return func() int{
		i++
		return i
}
}

func main(){
	//创建一个计数器
	count := counter()
	//调用计数器，每次调用都会增加１
	fmt.Println(count())
fmt.Println(count())
fmt.Println(count())
}

以上counter函数汇中的匿名函数才是一个真正的闭包，因为它引用了相对于自己的外部变量i

闭包概念的关键就是对外部变量的引用，只要这个闭包还在使用，那么闭包所引用的
外部变量就不会被释放。
因此闭包的使用应当小心，滥用闭包容易造成内存泄露


函数作为参数传递


以上的例子实际上已经演示了函数作为返回值传递，函数作为参数也大致相同，
需要注意的是函数类型该如何声明

//　定义一个函数，它的第一个形参也是一个函数


func f3(add func(int,int)int,a,b int)int{
	return add(a,b)
}
func main(){
	//定义一个匿名函数，只要函数签名匹配，就能传递给形参
	f := func(x,y int)int{
		return x+y
}

	result := f3(f,10,8)
	fmt.Println(result)
}


一个函数的函数签名就是它的类型，
使用type关键字，将函数签名定义为一种新的类型，这等同于c语言中的typeof


//将函数签名定义成一种新类型Add

type Add func(int,int)int

//声明形参时，直接使用这种新的类型，而且不用写很长的函数签名


func f3(add Add,a,b int)int{
	return add(a,b)
}

1.go的函数灭有重载功能。这意味着相同命名空间内的函数不能同名，哪怕函数签名不同
２．go函数的参数传递都是值传递。（可以直接传递指针）
c语言中的数组做函数参数也是引用传递，所谓引用传递，可以理解为是
传递的内存地址。值传递则是直接传递的内容
例如go传递数组，直接是对数组拷贝一份，如果数组很大，这样做性能低下，
因此，go中需要我们手动传递指针


包

为了适应现代的大型程序开发，现代高级编程语言都有包的概念，
go与python中的包概念相似，包就是一个分组，或一个文件夹，
但它也是一个命名空间。

c语言有一个重大缺陷，就是没有命名空间的概念，函数同名，会造成命名冲突。
go语言的包机制则不存在该问题

自定义包

在当前目录下创建一个test目录，

package 用于命名包,import 用于导入包。导入包时，注意路径，这里使用相对路径

匿名导入包的方式

import (
	"fmt"
	//导入包名的前面加下划线_
	_ "hello/test"
)

匿名导入包表示只导入，不使用
go语言强制规定，导入的包必须使用，否则无法通过编译。
有时需要只加载一个包，但不调用这个函数，这是就需要使用匿名导入包

包的初始化函数

在go语言中，每个包都有一个初始化函数init,该函数不需要我们手动调用，它只是在包加载的
时候调用。上面说的匿名导包也就是为了调用该函数做一些初始化工作

go语言的入口

go语言也是一个main函数作为入口函数，但是go语言强制规定，main函数必须在
main包中，因此我们的入口源文件必须声明为main包


在main包中初始化函数init和main函数谁先执行？

init函数作为初始化函数，在main包中,init函数比main函数先执行

