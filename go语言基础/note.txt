
why go?


1.php python ruby系列


这些都是动态语言，性能太慢，一旦代码规模庞大就很难控制代码质量



2.java scala c#系列

这类语言性能强大内库完善，带着一个高效的gc(内存垃圾回收机制)

缺点，带一个硕大的运行时，导致各种资源消耗
java语法的繁琐


3. c/c++系列

这一类语言偏偏对处理字符串比较弱，没有gc.很难写出稳定性强的web程序


而且c++的编译性能很烂，你开一个大型项目,随便make一下，一天就过去了


go环境的安装

go run表示直接编译go语言并执行应用程序

import fmt 告诉编译器使用fmt包(的函数，或其他元素)
fmt包实现了格式化IO(输入、输出)的函数


func main()是程序开始执行的函数。main函数是每一个可执行程序所必须包含的，
一般来说都是在启动后第一个执行的函数(如果有init()函数则会先执行该函数)

注释，fmt.Println()可以将字符串输出到控制台，并在最后自动增加换行字符\n

fmt.Print("hello,world!\n")

Print,Println这两个函数也支持使用变量


fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量arr输出到控制台

1. 配置Vim-go 语法高亮
(1) 下载Vundle.vim(vim 安装插件的工具)
(2) 配置。在~/.vmrc粘贴如下代码即可
(3) 安装vim-go插件
(4) 之后打开一个go文件

2. 配置go语法自动补齐


linux配置vim插件参考

基础语法

1.分隔符

在go程序中，一行代表一个语句结束。每个语句不错需要分号结尾
这些工作都将由go编译器自动完成。


如果打算将多个语句写在同一行，它们则必须使用;人为区分，在实际开发中不要专业

2. 注释

注释不会被编译，每一个包应该有相关注释

//
/**/


3. 标识符


标识符用来命名变量，类型等程序实体。一个标识符实际上就是一个或多个字母
(A~Z,a~z)数字(0~9),下划线_组成的序列，但是第一个字符必须是字母或下划线
而不能是数字

无效的 标识符

1.以数字开头
2.Go语言的关键字
3.运算符是不允许的

4. 关键字(25个)


break,default,func,interface,select
case,defer,go,map,struct
chan,else,goto,package,switch
const,fallthrough,if,range,type
continue,for,import,return ,var

go语言还有36个预定义标识符


append,bool,byte,cap,close,complex,complex64
copy,false,float32,float64,imag,int,int8
int32,int64,iota,len,make,new,nil
print,println,real,recover,string,true,uint

程序一般由关键字，常量，变量，运算符，类型和函数组成


程序汇总可能会使用到这些分隔符：括号(),中括号[],大括号{}


程序中可能会使用到这些标点符号:. 、;...

数据类型

在go编程语言汇总，数据类型用于声明函数和变量

数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要
用大数据的时候才需要申请大内存，就可以充分利用内存


go语言按类别有以下几种数据类型


1. 布尔型 

布尔型的值只可以是常量true或false

var b bool = true


2. 整型


整型 int和浮点型float,go语言支持整型和浮点型数字，并且原生支持复数，
其中位的运算采用补码

3.字符串类型


字符串就是一串固定长度的字符连接起来的字符序列。go的字符串是由单个字节
连接起来的。go语言的字符串的字节使用UTF-8编码标识Unicode文本

4.派生类型
包括

a. 指针类型(Pointer)
b. 数组类型
c. 结构化类型(struct)
d. Channel类型
e. 函数类型
f. 切片类型
g. 接口类型(interface)
h. Map 类型


整型

Go也有基于架构的类型，例如：int,uint和uintptr


uint8

无符号8位整型(0~255)

uint16,uint32,uint64,int8,int16,int64,

常用整型
byte 类似 uint8
rune 类似int32

uint  32或64位

int  与uint 一样大小

uintptr

无符号整型，用于存放一个指针

浮点型

float32, float64,complex64,complex128,

变量

声明变量的一般形式是使用var 关键字


变量声明

第一种，指定变量类型，声明后若不赋值，使用默认值0

var v_name v_type

v_name = value

第二种，根据值自行判定变量类型

var v_name  =value


第三种，省略var ,注意:= 左侧的变量不应该是已经声明的，否则会导致编译错误

v_name := value

// 例如

var a int =10
var b =10
c := 10

多变量声明

值变量和引用类型

所有像int,float,bool,string这些节本类都属于值类型，私用这些类型的变量
直接指向存在内存中的值：

当使用等号 = 将一个变量的值赋给另一个变量时，如: j= i,实际上是在内存
将i的值进行了拷贝

可以通过&i来获取变量i的内存地址，例如，0xd432342(每次的地址都可能不一样)
值类型的变量的遏制存储在栈中

内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会
有很不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同


更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存

一个引用类型的变量r1存储的是r1的值所在的内存地址(数字)，或内存地址中
第一个字所在的位置


这个内存你地址称为指针，这个指针实际上也被存在另外的而某一个字中

同一个引用类型的指针指向的多个字可以是在连续的内存地址中(内存布局是连续的)，
这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，
每个字都指示了下一个字所在的内存地址


当使用赋值语句r2=r1时，只有引用(地址)被复制


如果r1的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个
例子中，r2也会受到影响

常量

常量是一个简单值的标识符，在程序运行时，不会被修改的量

产量中数据类型只可以是布尔型，数字型(整数型，浮点型和复数)和字符串型


常量的定义格式

const identifier [type] = value

可以省略类型说明符[type],因为编译器可以根据变量的值来推断其类型

显式类型定义：

const b string = "abc"

隐式类型定义

const b = "abc"



常量还可以用作枚举：

const (
	Unknown = 0
	Female =1
	Male =2
)

数字0,1,2分别代表未知性别，女性，男性


常量可以用len(),cap(),unsafe.Sizeof()常量计算表达式的值。
常量表达式中，函数必须是内置函数，否则编译不过；

字符串类型在go里面是个结构，包含指向底层数组的指针和长度，这两部分每部分都是
8个字节，所以字符串类型大小为16个字节


优雅的常量iota

有些概念有名字，并且有时候我们关注这些名字，甚至(特别)是在我们代码中

const(
	CCVisa = "Visa"
	CCMasterCard = "MasterCard"
)


在其他时候，我们仅仅关注能把一个东西与其他的作区分。
有时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，
我们可以不想以string存储他们的分类。我们不关注这个分类是怎样命名的，
此外，该名字在市场上一直在变化

我们仅仅关注如何区分他们


自增长

在golang中，一个方面的习惯就是使用iota标识符，它简化了常量用于
增长数字的定义，

const (
	CateGoryBooks = iota // 0
	CateGoryHealth  // 1
	CateGoryClothing //2
)

自定义类型

自增长常量经常包含一个自定义类型，允许你依靠编译器


type Stereotype int // 这是一个自定义类型Steretype　实际上就是 int类型


const (
	TypicalNoob Stereotype = iota //0
	TypicalHipster // 1
	TypicalUnixWizard // 2
	TypicalStartupFounder // 3
)


如果一个函数以int 作为它的参数而不是Steretype,如果你给它传递一个Steretype,
它将在编译器期出现问题


相反也成立。给一个函数以Stereotype作为参数，你不能给它传递int

尽管如此，你可以传递一个数值常量，然后它却能够工作

这是因为常量在go中是弱类型直到它使用在一个严格的上下文环境中


另外，可以使用下划线跳过不想要的值

type AudioOutput int

const (
	OutMute AudioOutput = iota // 0
	OutMono // 1
	OutStereo // 2
	_
	_	
	OutSurround  // 5
)

iota和表达式

iota还可以做很多事情，不仅仅是increment.
iota总是用于increment,但它可以用于表达式，在常量中的存储结果值

type Allergen int

const (
	IgEggs Allergen = 1 << iota // 1 << 0 which is 00000001
	IgChocolate // 1 << 1 which is 00000010
	IgNuts  // 1 << 2 which is 00000100
	IgStrawberries // 1<<3 which is 00001000
	IgShellfish  // 1 << 4 which is 00010000
)


这个工作是因为当你在一个const组中仅仅有一个标识符在一行的时候，它将使用
增长的iota取得前面的表达式并且再运用它

在go语言的spec中，这就是所谓的隐性重复最后一个非空的表达式列表。


fmt.Println(IgEggs|IgChocolate|IgShellfish)

type ByteSize float64

const(
	_ = iota //ignore first value b y assigning to blank idenfier
	KB ByteSize = 1 <<(10*iota) // 1<< (10*1)
	MB  // 1 << (10*2)
	GB // 1 << (10*3)
	TB // 1 << (10*4)
	PB // 1<<(10*5) 
)

当你把两个常量定义在一行的时候会发生什么？


Banana的值是什么？2还是3?　Durian的值又是？

const(

	Apple,Banana = iota+1,iota+2
	Cherimoya,Durian
	Elderberry,Fig
)

在下一行增长，而不是立即取得它的引用


Apple:1
Banana:2
Cherimoya:2
Durian:3
Elderberry:3
Fig:4

运算符

运算符用于在程序运行时执行数学或逻辑运算

GO语言内置的运算符：
1.算术运算符　　
2. 关系运算符
3.逻辑运算符
4.位运算符
5.赋值运算符
6.其他运算符

算术运算符

+  -   *  /   %  ++  --


关系运算符


== !=  >  <  >= <=  

逻辑运算符


&&  \   ! 

位运算

位运算符对整数在内存中的二进制位进行操作

& \ ^ << >>

赋值运算符

= -= += *= /= %= <<= >>= &= ^= \

其他运算愤怒

&  返回变量存储地址，&a;将给出变量的实际地址

* 指针变量　　*a;是一个指针变量


运算符优先级


^!  
*/%<<>>&&^
+=\
== != <<= >=>
<-

&&

条件语句 

条件语句需要开发这指定一个或多个条件，并通过测试条件是否为true来决定
是否执行指定语句，

if...else语句

switch 语句　用于基于不同条件执行不同动作，每一个case分支都是唯一的，
从上至下逐一测试，直到匹配为止

switch语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break

switch 语句还可以被用于type-switch来判断某个ingerface变量中
实际存储的变量类型

Type Switch语句

switch　x.(type){
	case type:
		statement(s);
	case type:
		statement(s);
	// 可以定义任意个数的case
	default：
		statement(s);
}

语言for循环　

for循环是一个循环控制结构，可以执行指定次数的循环


语法


go语言的For循环有三种形式，只有其中的一种使用分号

和C语言的for一样


for init; condiiton;post{} 和c的while一样：

for condition{}


和c的for(;;) 一样


for {}

init :一般为赋值表达式，给控制变量赋予初值；
condition:关系表达式或逻辑表达式，循环控制条件；
post：一般为赋值表达式，给控制变量增量或减量


for循环的range格式可以对slice,map,数组，字符串等进行迭代循环


for key,value := range oldMap{
	newMap[key] = value
}


循环控制语句


循环控制语句可以控制循环体内语句的执行过程


go语言支持一下几种循环控制语句：

控制语句　　　描述

break  经常用于中断当前for循环或跳出switch语句
continue 跳出当前循环的剩余语句，然后继续进行下一轮循环

goto　　将控制转移到被标记的而语句


goto语句

函数


函数是基本的代码块，用于执行一个任务

Go语言最少有个main()函数

可以通过函数来换分不同功能，逻辑上每个函数执行的是指定的任务


函数声明高速了编译器函数的名称，返回类型和参数


go语言标准库提供了多种可动用的内置的函数。例如，
len()函数可以接受不同类型采纳数并返回该类型的长度
如果我们传入的是字符串则返回字符串的铲毒，
如果传入的是数组，则返回数组中包含的函数个数



函数定义


Go语言函数定义格式如下


func function_name ([parameter list]) [return_types]
{
	函数体
}


函数定义解析

func:函数由func开始声明

function_name:函数名称，函数名和参数列表一起构成了函数签名

parameter list:参数列表，参数就像一个占位符，但函数被调用时，你可以
将值传递给参数，这个值被称为实际参数。
参数列表指定的是参数类型，顺序，及参数个数。
参数是可选的，也就是说函数也可以不包含采纳数


return_types:返回类型，函数返回一列值。
return_types是该列值的数据类型。有些功能不需要返回值，这种情况下
return_types不是必须的


函数体：　函数定义的代码集合

以下实例为max()函数的代码，该函数传入两个整型参数num1和num2,并返回
这两个参数的最大值：


//函数返回两个数的最大值

func max(num1,num2 int) int{
	//声明局部变量
	var result int
	if(num1 > num2) {
		result =num1
} else{
	result = num2
}	return result
}


函数调用


当创建函数时，定义函数需要做什么，通过调用改函数来执行指定任务

调用函数，向函数传递参数，并返回值


例子中，在main()函数中调用max()函数



函数返回多个值


go函数可以返回多个值

函数参数

函数如果使用参数，该变量可称为函数的形参

形参就像定义在函数体内的局部变量

调用函数，可以通过两种方式传递参数(值传递和引用传递)


值传递：

值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中
如果对参数进行修改，将不会影响到实际参数


默认情况下，Go语言使用的是值传递，即在调用过程中不会影响到实际参数。

以下定义了swap()函数：

//定义相互交换值的函数


func swap(x,y int)int{
	var temp int
	temp =x //　保存x的值
	x= y //将ｙ值赋给x
	y =temp //将temp　值赋给y
	return temp;
}



下面使用值传递来调用swap()函数

引用传递　是指在调用函数时将实际采纳数的地址传递到函数中，那么在函数中
对采纳数所进行的修改，将影响到实际参数


引用传递指针参数传递到函数内，以下是交换函数swap()使用了引用传递

//定义交换值函数


func swap(x *int,y *int){
	var temp int
	temp = *x // 保持x地址上的值
	*x =*y  //将y 值赋给x
	*y = temp //将temp 值赋给y

}

函数作为值


go语言可以很灵活的创建函数，并作为值使用。
以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是
为了使用内置函数math.sqrt()

闭包


go语言支持匿名函数，可以作为闭包。匿名函数是一个"内联"语句或表达式
匿名函数的优越性在于可以直接床架你函数内的变量，不必声明

下面实例，我们创建了函数getSequence(),返回另一个函数，该函数的
目的是在闭包中递增i变量

go语言变量作用域

作用域为已声明标识符所表示的常量，类型，变量，函数或包在源代码中的作用范围

go语言中变量可以在三个地方声明：

1.函数内定义的变量称为局部变量
2. 函数外定义的变量称为全局变量
３．函数定义中的变量称为形式参数


局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，
参数和返回值变量也是局部变量


下面实例中main()函数使用了局部变量a,b,c:


main函数和init函数

g里面有两个保留函数
init函数　，能够应用于所有的package
main函数 , 只能应用于package　main

这两个函数在定义时不能有任何的参数和返回值


用于最好在一个package中每个文件只写一个init函数


go程序会自动调用init()和main().所以不需要在任何地方调用
这两个函数。每个package中的init函数都是可选的，
但package main就必须包含一个main函数

程序的初始化和执行都起始与main包。
如果main包还导入了其他的包，那么就会在编译时将它们依次导入。

有时一个包会被多个包同时导入，那么它只会被导入一次

当一个包被导入时，如果该包还导入了其他的包，那么会先将其他
包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数
(如果有的话)，以此类推，等所有被导入的包都加载完毕了，就会开始
对main包中的包级常量和变量进行初始化，然后执行main包中的init函数(如果存在的话)
最后执行main函数


指针

go语言中指针很容易学习，go语言中使用指针可以更简单的执行一些任务

变量是一种使用方便的占位符，用于引用计算机内存地址

go语言的取地址符是& ,放到一个变量前使用就会返回相应变量的内存地址


下面延时变量在内存中地址：

一个指针变量可以指向任何一个值的内存地址
它指向那个值的内存地址。类似于变量和常量，在使用指针前你需要声明指针。
指针声明格式如下：

var ip *int //指向整型
var fp *float32 //指向浮点型


如何使用指针

指针使用流程

１．定义指针变量
2. 为指针变量赋值
3. 访问指针变量中指向地址的值


在指针类型前加上*号(前缀)　来获取指针所指向的内容

go空指针

当一个指针被定义后没有分配到任何变量时，它的值为nil

nil指针也称为空指针


nil在概念上和其他语言的null,None,nil,NULL一样，都指代零值或空值


一个指针变量通常缩写为ptr


空指针判断


if(ptr != nil) // ptr不是空指针
if(ptr == nil) // ptr是空指针


指针数组


有一种情况，我们可能需要保存数组，这样就需要使用到指针


一下声明了整型指针数组

var ptr [MAX]*int;

ptr为整型指针数组。因此每个元素都指向了一个值。
以下实例的三个整数将存储在指针数组中：


声明数组
p84









