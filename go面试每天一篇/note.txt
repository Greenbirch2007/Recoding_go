Go 面试每天一篇（第 1 天）

package main

import (
    "fmt"
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println("打印前") }()
    defer func() { fmt.Println("打印中") }()
    defer func() { fmt.Println("打印后") }()

    panic("触发异常")
}


Go 面试每天一篇（第 2 天）

package main

import "fmt"


func main(){
	slice := []int{0,1,2,3}
	m := make(map[int]*int)
	for key,val := range slice{
		m[key] = &val
}
	for k,v := range m{
		fmt.Println(k,"->",*v)
}

for range循环的时候会创建每个元素的副本，而不是元素的引用，所以m[key] = &val取的都是变量val的地址，
所以最后map中的所有元素的值都是变量val的地址

在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。
如果有多个返回值必须加上括号();如果只有一个返回值且命名也必须加上括号()


new(T)和make(T,args)是go语言内建函数，用来分配内存，但适用的类型不同



new(T)会为T类型的新信值分配已置零的内存空间，并且返回地址(指针)，即类型为*T的值。
返回一个指针，该指针指向新分配的，类型为T的零值。适用与值类型，如数组，结构体等


make(T,args)返回初始化之后的T类型的值，这个值并不是T类型的零值，
也不是指针*T,是经过初始化之后的T的引用。
make()只用于slice,map和channel

new([]int)之后的list是一个*[]int类型的指针，不能对之子很执行append操作
可以使用make()初始化之后再用。
map和channel建议使用make()或字面量的方式初始化，不要用new()


append()的第二个参数不能直接使用slice,
需要使用...操作符，将一个切片追加到另一个切片上：append(s1,s2...)
或直接跟上元素,形如append(s1,1,2,3)



x:=100

这种声明方式的显示：
１．必须使用显示初始化
２．　不能提供数据类型，编译器会自动推导
３．　只能在函数内部使用简短模式

结构体的比较
1. 结构体只能比较是否相等，但是不能比较大小
２．　相同类型的结构体才能够记性比较，结构体是否相同不但与属性类型有关，
还与属性顺序相关，sn3与sn1是不同的结构体


３．　如果struct的所有成员都可以比较，则该struct就可以通过==或!=进行比较是否相等，
比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等。


不可以比较的：　切片，map,函数
可以比较的：bool,数值型，字符，指针，数组等

通过指针变量p访问其成员变量name,有两种方式：

１．p.name  &取地址运算符
2. (*p).name　　*指针解引用

类型别名与类型定义的区别

append导致底层数组重新分配内存了，ap中的a这个slice的底层数组和外面的不是一个，
并没有改变外面的。



字符串拼接的４种方式：

１．　str = "abc" + "123"
2. fmt.Sprintf("abc%d",123)
3.strings.Joint()
4. buffer.WriteString()


赋值
var x interface{} = nil
var x error =nil

nil值。
nil只能赋值给指针，chan,func,interface,map或slice类型的变量

error类型是一种内置接口类型


Go 面试每天一篇（第 8 天）

