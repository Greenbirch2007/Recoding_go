Go 面试每天一篇（第 1 天）

package main

import (
    "fmt"
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println("打印前") }()
    defer func() { fmt.Println("打印中") }()
    defer func() { fmt.Println("打印后") }()

    panic("触发异常")
}


Go 面试每天一篇（第 2 天）

package main

import "fmt"


func main(){
	slice := []int{0,1,2,3}
	m := make(map[int]*int)
	for key,val := range slice{
		m[key] = &val
}
	for k,v := range m{
		fmt.Println(k,"->",*v)
}

for range循环的时候会创建每个元素的副本，而不是元素的引用，所以m[key] = &val取的都是变量val的地址，
所以最后map中的所有元素的值都是变量val的地址

在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。
如果有多个返回值必须加上括号();如果只有一个返回值且命名也必须加上括号()


new(T)和make(T,args)是go语言内建函数，用来分配内存，但适用的类型不同



new(T)会为T类型的新信值分配已置零的内存空间，并且返回地址(指针)，即类型为*T的值。
返回一个指针，该指针指向新分配的，类型为T的零值。适用与值类型，如数组，结构体等


make(T,args)返回初始化之后的T类型的值，这个值并不是T类型的零值，
也不是指针*T,是经过初始化之后的T的引用。
make()只用于slice,map和channel

new([]int)之后的list是一个*[]int类型的指针，不能对之子很执行append操作
可以使用make()初始化之后再用。
map和channel建议使用make()或字面量的方式初始化，不要用new()


append()的第二个参数不能直接使用slice,
需要使用...操作符，将一个切片追加到另一个切片上：append(s1,s2...)
或直接跟上元素,形如append(s1,1,2,3)



x:=100

这种声明方式的显示：
１．必须使用显示初始化
２．　不能提供数据类型，编译器会自动推导
３．　只能在函数内部使用简短模式

结构体的比较
1. 结构体只能比较是否相等，但是不能比较大小
２．　相同类型的结构体才能够记性比较，结构体是否相同不但与属性类型有关，
还与属性顺序相关，sn3与sn1是不同的结构体


３．　如果struct的所有成员都可以比较，则该struct就可以通过==或!=进行比较是否相等，
比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等。


不可以比较的：　切片，map,函数
可以比较的：bool,数值型，字符，指针，数组等

通过指针变量p访问其成员变量name,有两种方式：

１．p.name  &取地址运算符
2. (*p).name　　*指针解引用

类型别名与类型定义的区别

append导致底层数组重新分配内存了，ap中的a这个slice的底层数组和外面的不是一个，
并没有改变外面的。



字符串拼接的４种方式：

１．　str = "abc" + "123"
2. fmt.Sprintf("abc%d",123)
3.strings.Joint()
4. buffer.WriteString()


赋值
var x interface{} = nil
var x error =nil

nil值。
nil只能赋值给指针，chan,func,interface,map或slice类型的变量

error类型是一种内置接口类型


Go 面试每天一篇（第 8 天）


１．init()函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等
２．一个包可以出现多个init()函数，一个源文件也可以包含多个init()函数
３．　同一个包中多个init()函数的执行顺序没有明确定义，但是不同包的init函数是
根据包导入的依赖关系决定的
4. init()函数在代码中不能被显示调用，不能被引用(赋值给函数变量)，否则出现编译错误
５．　一个包被引用多次，如 A import B,C import B,A import C
B被引用多次，但B包只会初始化一次
６．　引入包，不可出现死循环，即A import B,B import A　这样会出现编译错误

类型选择，类型选择的语法：　i.(type),其中i是接口,type是固定关键字，需要注意的是，只有接口类型才可以使用类型选额

打印一个map中不存在的值时，返回元素类型的零值。

m的类型是map[person]int,因为m中不存在p，所以打印int类型


操作符[i,j] .基于数组(切片)可以使用操作符[i,j]创建新的切片，从索引i,到索引j结束，截取已有数组(切片)的任意部分，
返回新的切片，新切片的值包含原数组(切片)的i索引的值,但是不包含j索引的值。
i,j都是可选的，i如果省略，默认是0,j如果省略，默认是原数组(切片)的长度。i,j都不超过这个长度值


假设底层数组的大小为k,截取之后获得的切片的长度和容量的计算方法：
长度: j-i
容量：k-i

截取操作符还可以有第三个参数，形如[i,j,k],第三个参数k用来限制新切片的容量，
但不能超过原数组(切片)的底层数组大小。截取获得的切片的长度和容量分别为：j-i,k-i



go中的数组是值类型，可比较，另一方面，数组的长度也是数组类型的组成部分


cap()函数适用于array,slice,channel

当且晋档接口的动态值和动态类型都为nil时，接口类型值才为nil

删除map不存在的键值对时，不会报错，相当于没有任何作用
获取不存在的键值对时，返回值类型对应的零值，返回返回0


%d 表示输出十进制数字，+表示输出数值的符号，这里不能取反


结构体嵌套。在嵌套结构体中,People称为内部类型，Teacher称为外部类型

通过嵌套，内部类型的属性，方法可以为外部类型所有，就像是外部类型自己的一样。
此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样
内部类型的方法就会被"屏蔽"

常量，go语言字符串是只读的

指针，incr()函数里的p是*int类型的指针，指向的是main()函数的变量p的地址。
第2行代码是将该地址的值执行一个自增操作，incr()返回自增后的结果

nil切片和空切片。nil切片和nil相等，一般用来表示一个不存在的切片；
空切片和nil不相等，表示要给空的集合

UTF-8编码中，十进制数字65对应的符号是A

一个类型可以实现多个接口，结构体Work分别实现了接口A,B
所以接口变量a,b调用各自的方法ShowA(),ShowB()


Go 面试每天一篇（第 16 天）

