Go 面试每天一篇（第 1 天）

package main

import (
    "fmt"
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println("打印前") }()
    defer func() { fmt.Println("打印中") }()
    defer func() { fmt.Println("打印后") }()

    panic("触发异常")
}


Go 面试每天一篇（第 2 天）

package main

import "fmt"


func main(){
	slice := []int{0,1,2,3}
	m := make(map[int]*int)
	for key,val := range slice{
		m[key] = &val
}
	for k,v := range m{
		fmt.Println(k,"->",*v)
}

for range循环的时候会创建每个元素的副本，而不是元素的引用，所以m[key] = &val取的都是变量val的地址，
所以最后map中的所有元素的值都是变量val的地址

在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。
如果有多个返回值必须加上括号();如果只有一个返回值且命名也必须加上括号()


new(T)和make(T,args)是go语言内建函数，用来分配内存，但适用的类型不同



new(T)会为T类型的新信值分配已置零的内存空间，并且返回地址(指针)，即类型为*T的值。
返回一个指针，该指针指向新分配的，类型为T的零值。适用与值类型，如数组，结构体等


make(T,args)返回初始化之后的T类型的值，这个值并不是T类型的零值，
也不是指针*T,是经过初始化之后的T的引用。
make()只用于slice,map和channel

new([]int)之后的list是一个*[]int类型的指针，不能对之子很执行append操作
可以使用make()初始化之后再用。
map和channel建议使用make()或字面量的方式初始化，不要用new()


append()的第二个参数不能直接使用slice,
需要使用...操作符，将一个切片追加到另一个切片上：append(s1,s2...)
或直接跟上元素,形如append(s1,1,2,3)



x:=100

这种声明方式的显示：
１．必须使用显示初始化
２．　不能提供数据类型，编译器会自动推导
３．　只能在函数内部使用简短模式

结构体的比较
1. 结构体只能比较是否相等，但是不能比较大小
２．　相同类型的结构体才能够记性比较，结构体是否相同不但与属性类型有关，
还与属性顺序相关，sn3与sn1是不同的结构体


３．　如果struct的所有成员都可以比较，则该struct就可以通过==或!=进行比较是否相等，
比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等。


不可以比较的：　切片，map,函数
可以比较的：bool,数值型，字符，指针，数组等

通过指针变量p访问其成员变量name,有两种方式：

１．p.name  &取地址运算符
2. (*p).name　　*指针解引用

类型别名与类型定义的区别

append导致底层数组重新分配内存了，ap中的a这个slice的底层数组和外面的不是一个，
并没有改变外面的。



字符串拼接的４种方式：

１．　str = "abc" + "123"
2. fmt.Sprintf("abc%d",123)
3.strings.Joint()
4. buffer.WriteString()


赋值
var x interface{} = nil
var x error =nil

nil值。
nil只能赋值给指针，chan,func,interface,map或slice类型的变量

error类型是一种内置接口类型


Go 面试每天一篇（第 8 天）


１．init()函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等
２．一个包可以出现多个init()函数，一个源文件也可以包含多个init()函数
３．　同一个包中多个init()函数的执行顺序没有明确定义，但是不同包的init函数是
根据包导入的依赖关系决定的
4. init()函数在代码中不能被显示调用，不能被引用(赋值给函数变量)，否则出现编译错误
５．　一个包被引用多次，如 A import B,C import B,A import C
B被引用多次，但B包只会初始化一次
６．　引入包，不可出现死循环，即A import B,B import A　这样会出现编译错误

类型选择，类型选择的语法：　i.(type),其中i是接口,type是固定关键字，需要注意的是，只有接口类型才可以使用类型选额

打印一个map中不存在的值时，返回元素类型的零值。

m的类型是map[person]int,因为m中不存在p，所以打印int类型


操作符[i,j] .基于数组(切片)可以使用操作符[i,j]创建新的切片，从索引i,到索引j结束，截取已有数组(切片)的任意部分，
返回新的切片，新切片的值包含原数组(切片)的i索引的值,但是不包含j索引的值。
i,j都是可选的，i如果省略，默认是0,j如果省略，默认是原数组(切片)的长度。i,j都不超过这个长度值


假设底层数组的大小为k,截取之后获得的切片的长度和容量的计算方法：
长度: j-i
容量：k-i

截取操作符还可以有第三个参数，形如[i,j,k],第三个参数k用来限制新切片的容量，
但不能超过原数组(切片)的底层数组大小。截取获得的切片的长度和容量分别为：j-i,k-i



go中的数组是值类型，可比较，另一方面，数组的长度也是数组类型的组成部分


cap()函数适用于array,slice,channel

当且晋档接口的动态值和动态类型都为nil时，接口类型值才为nil

删除map不存在的键值对时，不会报错，相当于没有任何作用
获取不存在的键值对时，返回值类型对应的零值，返回返回0


%d 表示输出十进制数字，+表示输出数值的符号，这里不能取反


结构体嵌套。在嵌套结构体中,People称为内部类型，Teacher称为外部类型

通过嵌套，内部类型的属性，方法可以为外部类型所有，就像是外部类型自己的一样。
此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样
内部类型的方法就会被"屏蔽"

常量，go语言字符串是只读的

指针，incr()函数里的p是*int类型的指针，指向的是main()函数的变量p的地址。
第2行代码是将该地址的值执行一个自增操作，incr()返回自增后的结果

nil切片和空切片。nil切片和nil相等，一般用来表示一个不存在的切片；
空切片和nil不相等，表示要给空的集合

UTF-8编码中，十进制数字65对应的符号是A

一个类型可以实现多个接口，结构体Work分别实现了接口A,B
所以接口变量a,b调用各自的方法ShowA(),ShowB()


Go 面试每天一篇（第 16 天）

数组或切片的截取操作。截取操作有带有２个或３个参数，形如[i:j]和[i:j:k]
假设截取对象的底层数组长度为１，在操作符[i:j]中，如果省略i，默认为０
如果省略j，默认底层数组的长度，截取得到的切片长度和容量计算长度是j-i,l-i

操作符[i:j:k],k主要是用来限制切片的容量，但是不能大于数组的长度l,截取
得到的切片长度和容量计算方法是j-i,k-i


只声明了map m,并没有分配内存空间，不能直接赋值，需要使用make()

v,k := m["b"]当key为b的元素不存在的时候，v会返回值类型对应的零值,k返回false


接口的静态类型。a,b具有相同的动态类型和动态值，分别是结构体work和{3};
a的静态类型是A,b的静态类型是B
接口A不包括方法showB(),
接口B也不包括方法showA()

所以编译错误

当多值赋值时，:=左边的变量无论声明与否都可以

defer ，返回值　　返回参数是匿名，具名的问题

类型断言

变量person是一个指针变量


person.age 此时是将28当做defer函数的参数，会把28缓存在栈中，等到最后执行
该defer语句的时候取出，即输出28


defer缓存的是结构体Person{28}的地址，最终Person{28}的age被重新赋值为29，所以
defer语句最后执行的时候，依靠缓存的地址取出的age是29

闭包引用，输出29

defer的执行顺序为先进后出，即3  2   1 

被调用函数里的defer语句在返回之前就会被执行

Ａ声明的是nil切片;B声明的是长度和容量都为0的空切片

第一种切片声明不会分配内存，有限选择


函数参数为interface{}时可以接收任何类型的参数，包括用户自定义类型等，
即使是接收指针类型也用interface{},而不是使用*interface{}


永远不要使用一个指针指向一个接口类型，因为它已经是一个指针

f()函数返回参数是指针类型，所以可以用&取结构体的指针
如果填*f()，则p是S类型
如果填f()，则p是*S类型，
不过都可以使用p.m取得结构体的成员

golang的字符串类型是不能赋值nil的，也不能跟nil比较

defer关键字后面的函数或方法想要执行必须先注册，return之后的defer是不能注册的，也就不能执行后面的函数或方法

golang中切片底层的数据结构是数组，当使用s1[1:]获得切片s2,和s1共享同一个底层数组，这会导致s2[1] =4 语句影响s1

而append操作会导致底层数组扩容，生成新的数组，因为追加数据后的s2不会影响s1

代码和变量的作用域

Go 面试每天一篇（第 25 天）
map的输出是无序的


基于类型创建的方法必须定义在同一个包内

值类型Student没有实现接口的Speak()方法

而是指针类型*Student实现该方法

Go 面试每天一篇（第 27 天）

iota是golang语言的常量计数器，只能在常量的表达式中使用

iota在const关键字出现时被重置为0,const中每新增一行常量声明将使iota计数一次。

我们分配给变量p的值明明是nil,然而p却不是nil.
记住一点，当且仅当动态值和动态类型都为nil时，接口类型值才为nil

给变量p赋值之后，p的动态值是nil,但是动态类型却是*Student,是一个nil指针，
所以相等条件不成立

iota的用法，类型的String()方法

根据iota的用法推断出South的值是３：另外，如果类型定义了String()方法，
当使用fmt.Printf(),fmt.Print(),fmt.Println()会自动使用String()方法，实现字符串的打印

cannot assign to struct field m["foo"].x in map

对于类似x = y的赋值操作，必须直到X的地址，才能够将Y的值赋给X,
但是go中的map的value本身是不可寻址的

有两个解决办法

１．使用临时变量
２．　修改数据结构

go中不同类型是不能比较的，而数组长度是数组类型的一部分，
所以[...]int{1}和[2]int{1}是两种不同的类型，不能比较；

切片是不能比较的

变量作用域。问题出在操作符:=,对于使用:=定义的变量，
如果新变量与同名已定义的变量不在同一作用域中，那么go会新定义这个变量。
对于本例，main()函数里的p是新定义的变量，会遮住全局变量p,
导致执行到bar()时程序，全局变量p依然还是nil,程序随即Crash


不会出现死循环，能正常结束

循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数


for range使用短变量声明(:=)的形式迭代变量，需要注意的是，变量i,v在每次循环体中
都会被重用，而不是重新声明

各个goroutine中输出的i,v值都是for range循环结束后的i,v最终值，
而不是各个goroutine启动时的i,v值。可以理解为闭包引用，使用的是上下文环境的值

两种可行的fix方法

1. 使用函数传递

2. 使用临时变量保留当前值


fefer是go语言提供的一种用于注册延迟调用的机制，每次defer都会把函数
压入栈中，当前函数返回前再把延迟函数取出并执行

defer语句并不会马上执行，而是会进入一个栈，函数return前，
会按先进后出的(FILO)的顺序，也就是最先被定义的defer语句最后执行。
先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；
否则，如果如果前面先执行，那后面函数的依赖就没有了


使用defer最容易踩坑的地方是和带命名返回参数的函数一起使用时

defer语句定义时，对外部变量的而引用是有两种方式的
分别是作为函数参数和作为闭包引用。作为函数参数，则在defer定义时就把值传递给defer,
并被缓存起来；作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定
当前的值

避免掉坑的关键是要理解这套语句

return xxx

这条语句并不是一个原子指令，经过编译后，编程了三条指令

1. 返回=xxx
2. 调用defer函数
3. 空的return


1,3 步才是return语句真正的命令，第2步是defer定义的语句，这里就有可能
会操作返回值


func f1()(r int){
	// 1. 赋值
	r = 0
	// 2. 闭包引用，返回值被修改
	defer func(){
		r++
	}()
	// 3. 空的return
	return
}



defer 是闭包引用，返回值被修改，所以f()返回1


func f()(r int){
	t :=5
	// 1. 赋值
	defer func(){
		t =t +5
	}()
	
	//3. 空的return
	return
}


第二步没设计返回值r的操作，所以返回5


func f3()(r int){
	// 1. 赋值
	r =1
	// 2. r 作为函数参数，不会修改要返回的那个r值
	defer func(r int){
		r = r+5
	}(r)
	// 3. 空的return
	return


}

第二步，r是作为函数参数使用，是一份复制，defer语句里面的r和外面的r
其实是两个变量，里面变量的改变不会影响外层r,所以不是返回6,而是返回1


func increaseB()(r int){
	// 1. 赋值
	r = 0
	// 2. 闭包引用，r++
	defer func(){
		r++
	}()
	// 3. 空return
	return 
}


func increaseA() int{
	var i int
	defer func(){
		i++
	}()
	return i
}


函数increaseA()是匿名返回值，返回局部变量，
同时defer函数也会操作这个局部变量。对于匿名返回值来说，可以假定
有一个存储返回值，比如嘉定返回值变量为anony

annoy = i
i++
return

由于i是整型，会将拷贝给anony,所以defer语句中修改i值，对函数
返回值不造成影响，所以返回0

三步拆分法：
1.第一步执行r = n+1
2.接着执行第二个defer,由于此时f()未定义，引发异常，随机执行
第一个defer,异常被recover(),程序正常执行，
3. 最后return


range 表达式是副本参与循环，参数循环的是a的副本，而不是真正的a
假设b是a的副本，则range循环代码如下


for i,v := range b{
	if i == o{
		a[1] = 12
		a[2] =14

	}
	r[i] =v

}

因此无论a被如何修改，其副本b依旧保持原值，并且参与循环的是b,
因此，v从b中取出的仍旧是a的原值，而非修改后的值

修复代码中，使用*[5]int range 表达式，其副本依旧是一个指向
原数组a的指针，因此后续所有循环中均是&a指向的原数组亲自参与的，
因此v能从 &a的指向的原数组中取出a修改的值

可变函数，append()操作


go提供的语法糖... , 可以将slice传进可变函数，不会创建新的
切片。第一次调用change()时，append()操作使切片底层数组
发生了扩容，原slice的底层数组不会改变；
第二次调用change()函数时，使用了操作符[i,j]获得一个新的切片，
假定为slice1,它的底层数组和原切片底层数组是重合的，
不过slice1的长度，容量分别是2,5
所以在change()函数中对slice1底层数组的修改会影响到原切片

切片在go的内部结构有一个指向底层数组的指针，当range表达式发生赋值
时，副本的指针依旧指向原底层数组，所以对切片的修改都会反应到底层数组上，
所以通过v可以获得修改后的数组元素


Go 面试每天一篇（第 33天）
for range 使用短变量声明(:=)的形式迭代变量时，变量i,value在每次循环体中都会被重要，而不是重新声明

for range map是无序的，如果第一次循环到A,则输出

协程和线程都可以实现程序的并发执行
通过channel来进行协程间的通信

for 循环支持continue和break来自控制循环，但是它提供了一个更高级的
break,可以选择中断哪一个循环

for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量

多重赋值分为两步，有先后顺序：
1. 计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式
2. 赋值


会计算s[i-1]，等号右边是两个表示是常量，所以赋值运算等同于i,s[0] = 2,"Z"


强制类型转化


单个case中，可以出现多个结果选项
只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case

类型断言，方法集

自增自减操作

i++,i--在go语言中是语句，不是表达式，
因此不能赋值给另外的变量

j = i++
i+=+
此外没有++i,--i

select 会随机选择一个可用通道做收发操作，所以可能触发异常，也可能不会


1. 给一个nil channel发送数据，造成永远阻塞
2. 从一个nil channel接收数据，造成永远阻塞
3. 给一个已经关闭的channel发送数据，引起panic
4. 从一个已经关闭的channel接收数据，如果缓冲区中为空，
则返回一个零值


cannot take the address of i.常量

常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段
直接展开，作为指令数据使用，所以常量无法寻址


函数返回值类型。nil可以用作interface,function,pointer,
map,slice和channel的"空值"
但是如果不特别指定的话，go语言不能识别类型，所以
会报错：cannot use nil ass type string in return argument


异常的触发：
1. 空指针解析
2. 下标越界
3. 除数为0
4. 调用panic函数

无缓冲的channel是同步的，而有缓冲的channel是非同步的

interface的内部结构，我们知道接口除了有静态类型，还有动态类型和动态值，
当且仅当动态值和动态类型都为nil时，接口类型值才为nil,
这里的x的动态类型是*int,所以x不为nil


select 机制用来处理异步IO问题
select机制最大的一条限制就是每个case语句里必须是一个IO操作
golang在语言级别支持select关键字

有方向的channel不可以被关闭

1. map需要初始化才能使用
2. 指针不支持索引


Go 面试每天一篇（第 42天）

golang中，大括号不能放在单独的一行

字面量初始化切片时候，可以指定索引，没有指定索引的元素会在前一个索引基础
之上加一，所以输出[1 0 2 3]
而不是[1 3 2]

指针，p是指针变量，指向变量v,*p++操作的意思是
取出变量v的值并执行加一操作，所以v的最终值是2


指针是指向另一个地址的值

什么是内存？

计算机内存，即RAM,可以看做是一串盒子，一个接一个地排成一行


每个盒子(或称为单元格)都标有一个唯一的数字，数字按顺序递增；
这是单元格的地址，其所在的内存位置


每一个单元格存储一个值。如果你知道某个单元格的内存地址，就可以
访问该单元格并读取里面的内容。
或用另外一个值替换该单元格内之前的值


CPU所做的一切都是为获取和存储值到内存单元中

什么是变量?

编写一段代码读取存储在内存地址为200的值，将其乘以3并将结果存储在内存
地址为201的位置，伪代码如下


1. 读取存储在内存地址为200的值，并将其暂存在CPU中
2. 将存储在CPU中的值乘以3
3. 将存储在CPU中的值存入内存地址为201的位置

这是早期的编写方式，程序员将保留一个内存位置列表，包括
谁使用它，何时使用以及存储在其中的值表示什么


这也意味着在编写程序期间，必须给存储在内存中的每一个可能的值
分配一个地址。这种方式使得在程序运行时动态地将内存分配给
变量变得异常困难

变量只是一个由数字字母组成的，标识存储的位置I位置的假名

存储位置---->变量(假名)

这是我们为内存位置提供的方便记忆的名称
之前的程序
1. 读取变量a中存储的值并将其放入CPU中
2. 将其乘以3
3. 将结果存入变量b
可以不再需要直接讨论内存位置，也不再需要跟踪它们，把这些繁重
的工作交给编译器处理


var a =6
var b = a*3


编译器将确保为变量a和b分配唯一的内存为孩子，以便根据需要保存它们的值



当我们调用一个带参数的函数时，参数是原值的拷贝

zero()函数不会改变主函数中x的原值，但是如果我们想要这样做

一种实现办法就是使用一种指针的特殊数据类型

指针指向的是内存中值的存储地址，而不是值本身。通过使用指针*int,
zero()函数能够修改原始变量


the * and & operator


在go中，指针由*字符和存储值的类型表示。在zero()函数中，xPtr是
指向int类型的指针

*也用于指针变量的解引用，这使得我们可以访问指针指向的值。
当我们写*xPtr = 0时，我们在说"将整型0存储在xPtr指向的内存位置"
如果我们尝试执行xPtr = 0,将会得到一个编译器错误，因为xPtr不是一个int型变量，
而是*int型，它只能被赋予一个*int型的值


最后，我们可以使用&操作符获取变量的地址。&x返回的值是*int型，
因为x是int型。这允许我们修改原始变量。
main()函数中的&x和zero()函数中的xPtr指的是相同的内存位置


另外一个获取指针的方法是使用内置函数new()

new()接受以类型作为参数，分配足够的内存来满足该类型的值，并返回指向该内存的指针

new() 和&作用都是指针化
new()是类型指针化
&是变量指针化


golang，具有垃圾回收的编程语言，这意味着当变量不再使用时，内存会自动回收。


指针和引用

c,c++支持指针
c++,python,java等支持引用

指针和引用非常类似，都用来让一个变量提供对另一个变量的访问

指针是go语言的核心。

指针变量存储的是另一个变量的地址

引用变量指向另外一个变量。

int i = 3; // 这里定义了变量i
int *ptr = &i; //之类定义了一个指向变量i内存地址的指针ptr
int &ref = i; //定义了一个指向变量i的引用ref


不仅操作符不同，而且使用的方法不同。对于指针，必须使用*操作符来解引用
对于引用，不需要任何操作符。


指针可以重分配，而引用不能。指针可以被分配另一个不同的地址

如果我使用引用处理，我们将无法通过*ap更改b的值，并将其反映在*ap2中。
因为一旦你复制了一个引用，它们就各自独立，没有任何联系。
然而，它们可能指向相同的变量，但你操作引用时将会改变它指向，而不是指向的值


通过变量就可以操作存储在内存中的值，进行赋值，加减乘除等
一个变量对应一段内存空间，这段空间就存储了该变量相对应类型的值。

指针的值就对应变量的地址，只通过指针，就可以更新或读取变量的值，
而需要用到变量名

声明了*int类型的指针变量ptr,通过取地址运算符&获得指向整型变量i的地址。
可以说，指针ptr指向变量i，或ptr指针保存了变量i的地址


指针声明


指针指向一个变量的内幕才能地址。要想使用指针，必须先声明


var var_name ,*var_type

//var_name是指针名称，var_type 指针所指向的变量的类型

var i int =10
str := "go"


注意：*int类型的指针，说明该指针指向的一定是int类型的变量，*string类型也类似

*int类型的指针，指向的变量若是string类型的，编译器编译的就会报错

如何使用指针

主要有3步：

1.声明

var px *int = &x// 1.声明并初始化

也可以用new()
var px = new(int)
px = &x

var py = &y //2. 省略指针类型，编译器自动判断
//px,py := &x, &y //3. 使用:=

关于空指针

一个指针已声明而没有赋值时，称为空指针，为nil
任何类型的指针的零值都是nli

如果ip != nil为真，那么p是指向某个有效变量。指针之间也是可以进行相等测试的，只有当
它们指向同一个变量或全部时nil时相等

指针作为函数采纳数使用


指针包含的是一个变量的地址，如果将一个指针作为参数传递给函数，
就可以通过指针来更新变量的值

不常用的newHanshu 


new函数也是创建变量的一个方法，new(type)表示一个type类型的
匿名函数，并初始化为type类型的零值，返回变量的地址，指针类型为*type

用new函数创建变量和普通变量声明语句方式创建变量没有什么区别，
除了不需要声明一个临时变量的名字外


创建变量，并返回变量地址


func newA() *int{
	return new(int)
}

func newB() *int{
	var i int
	return &i
}
实际编程还是多用具体类型创建变量

未使用变量。如果有未使用的变量代码将编译失败
函数中声明的变量必须要使用，但可以有未使用的
全局变量，函数的拿书未使用也是可以的

如果你给位还是用的变量赋新值，代码也会编译齿白


如果类型实现String()方法，当格式化输出时会自动使用String()方法。


Go 面试每天一篇（第44天）
