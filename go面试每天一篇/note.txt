Go 面试每天一篇（第 1 天）

package main

import (
    "fmt"
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println("打印前") }()
    defer func() { fmt.Println("打印中") }()
    defer func() { fmt.Println("打印后") }()

    panic("触发异常")
}


Go 面试每天一篇（第 2 天）

package main

import "fmt"


func main(){
	slice := []int{0,1,2,3}
	m := make(map[int]*int)
	for key,val := range slice{
		m[key] = &val
}
	for k,v := range m{
		fmt.Println(k,"->",*v)
}

for range循环的时候会创建每个元素的副本，而不是元素的引用，所以m[key] = &val取的都是变量val的地址，
所以最后map中的所有元素的值都是变量val的地址

在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。
如果有多个返回值必须加上括号();如果只有一个返回值且命名也必须加上括号()


new(T)和make(T,args)是go语言内建函数，用来分配内存，但适用的类型不同



new(T)会为T类型的新信值分配已置零的内存空间，并且返回地址(指针)，即类型为*T的值。
返回一个指针，该指针指向新分配的，类型为T的零值。适用与值类型，如数组，结构体等


make(T,args)返回初始化之后的T类型的值，这个值并不是T类型的零值，
也不是指针*T,是经过初始化之后的T的引用。
make()只用于slice,map和channel

new([]int)之后的list是一个*[]int类型的指针，不能对之子很执行append操作
可以使用make()初始化之后再用。
map和channel建议使用make()或字面量的方式初始化，不要用new()


append()的第二个参数不能直接使用slice,
需要使用...操作符，将一个切片追加到另一个切片上：append(s1,s2...)
或直接跟上元素,形如append(s1,1,2,3)



x:=100

这种声明方式的显示：
１．必须使用显示初始化
２．　不能提供数据类型，编译器会自动推导
３．　只能在函数内部使用简短模式

结构体的比较
1. 结构体只能比较是否相等，但是不能比较大小
２．　相同类型的结构体才能够记性比较，结构体是否相同不但与属性类型有关，
还与属性顺序相关，sn3与sn1是不同的结构体


３．　如果struct的所有成员都可以比较，则该struct就可以通过==或!=进行比较是否相等，
比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等。


不可以比较的：　切片，map,函数
可以比较的：bool,数值型，字符，指针，数组等

通过指针变量p访问其成员变量name,有两种方式：

１．p.name  &取地址运算符
2. (*p).name　　*指针解引用

类型别名与类型定义的区别

append导致底层数组重新分配内存了，ap中的a这个slice的底层数组和外面的不是一个，
并没有改变外面的。



字符串拼接的４种方式：

１．　str = "abc" + "123"
2. fmt.Sprintf("abc%d",123)
3.strings.Joint()
4. buffer.WriteString()


赋值
var x interface{} = nil
var x error =nil

nil值。
nil只能赋值给指针，chan,func,interface,map或slice类型的变量

error类型是一种内置接口类型


Go 面试每天一篇（第 8 天）


１．init()函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等
２．一个包可以出现多个init()函数，一个源文件也可以包含多个init()函数
３．　同一个包中多个init()函数的执行顺序没有明确定义，但是不同包的init函数是
根据包导入的依赖关系决定的
4. init()函数在代码中不能被显示调用，不能被引用(赋值给函数变量)，否则出现编译错误
５．　一个包被引用多次，如 A import B,C import B,A import C
B被引用多次，但B包只会初始化一次
６．　引入包，不可出现死循环，即A import B,B import A　这样会出现编译错误

类型选择，类型选择的语法：　i.(type),其中i是接口,type是固定关键字，需要注意的是，只有接口类型才可以使用类型选额

打印一个map中不存在的值时，返回元素类型的零值。

m的类型是map[person]int,因为m中不存在p，所以打印int类型


操作符[i,j] .基于数组(切片)可以使用操作符[i,j]创建新的切片，从索引i,到索引j结束，截取已有数组(切片)的任意部分，
返回新的切片，新切片的值包含原数组(切片)的i索引的值,但是不包含j索引的值。
i,j都是可选的，i如果省略，默认是0,j如果省略，默认是原数组(切片)的长度。i,j都不超过这个长度值


假设底层数组的大小为k,截取之后获得的切片的长度和容量的计算方法：
长度: j-i
容量：k-i

截取操作符还可以有第三个参数，形如[i,j,k],第三个参数k用来限制新切片的容量，
但不能超过原数组(切片)的底层数组大小。截取获得的切片的长度和容量分别为：j-i,k-i



go中的数组是值类型，可比较，另一方面，数组的长度也是数组类型的组成部分


cap()函数适用于array,slice,channel

当且晋档接口的动态值和动态类型都为nil时，接口类型值才为nil

删除map不存在的键值对时，不会报错，相当于没有任何作用
获取不存在的键值对时，返回值类型对应的零值，返回返回0


%d 表示输出十进制数字，+表示输出数值的符号，这里不能取反


结构体嵌套。在嵌套结构体中,People称为内部类型，Teacher称为外部类型

通过嵌套，内部类型的属性，方法可以为外部类型所有，就像是外部类型自己的一样。
此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样
内部类型的方法就会被"屏蔽"

常量，go语言字符串是只读的

指针，incr()函数里的p是*int类型的指针，指向的是main()函数的变量p的地址。
第2行代码是将该地址的值执行一个自增操作，incr()返回自增后的结果

nil切片和空切片。nil切片和nil相等，一般用来表示一个不存在的切片；
空切片和nil不相等，表示要给空的集合

UTF-8编码中，十进制数字65对应的符号是A

一个类型可以实现多个接口，结构体Work分别实现了接口A,B
所以接口变量a,b调用各自的方法ShowA(),ShowB()


Go 面试每天一篇（第 16 天）

数组或切片的截取操作。截取操作有带有２个或３个参数，形如[i:j]和[i:j:k]
假设截取对象的底层数组长度为１，在操作符[i:j]中，如果省略i，默认为０
如果省略j，默认底层数组的长度，截取得到的切片长度和容量计算长度是j-i,l-i

操作符[i:j:k],k主要是用来限制切片的容量，但是不能大于数组的长度l,截取
得到的切片长度和容量计算方法是j-i,k-i


只声明了map m,并没有分配内存空间，不能直接赋值，需要使用make()

v,k := m["b"]当key为b的元素不存在的时候，v会返回值类型对应的零值,k返回false


接口的静态类型。a,b具有相同的动态类型和动态值，分别是结构体work和{3};
a的静态类型是A,b的静态类型是B
接口A不包括方法showB(),
接口B也不包括方法showA()

所以编译错误

当多值赋值时，:=左边的变量无论声明与否都可以

defer ，返回值　　返回参数是匿名，具名的问题

类型断言

变量person是一个指针变量


person.age 此时是将28当做defer函数的参数，会把28缓存在栈中，等到最后执行
该defer语句的时候取出，即输出28


defer缓存的是结构体Person{28}的地址，最终Person{28}的age被重新赋值为29，所以
defer语句最后执行的时候，依靠缓存的地址取出的age是29

闭包引用，输出29

defer的执行顺序为先进后出，即3  2   1 

被调用函数里的defer语句在返回之前就会被执行

Ａ声明的是nil切片;B声明的是长度和容量都为0的空切片

第一种切片声明不会分配内存，有限选择


函数参数为interface{}时可以接收任何类型的参数，包括用户自定义类型等，
即使是接收指针类型也用interface{},而不是使用*interface{}


永远不要使用一个指针指向一个接口类型，因为它已经是一个指针

f()函数返回参数是指针类型，所以可以用&取结构体的指针
如果填*f()，则p是S类型
如果填f()，则p是*S类型，
不过都可以使用p.m取得结构体的成员

golang的字符串类型是不能赋值nil的，也不能跟nil比较

defer关键字后面的函数或方法想要执行必须先注册，return之后的defer是不能注册的，也就不能执行后面的函数或方法

golang中切片底层的数据结构是数组，当使用s1[1:]获得切片s2,和s1共享同一个底层数组，这会导致s2[1] =4 语句影响s1

而append操作会导致底层数组扩容，生成新的数组，因为追加数据后的s2不会影响s1

代码和变量的作用域

Go 面试每天一篇（第 25 天）
map的输出是无序的


基于类型创建的方法必须定义在同一个包内

值类型Student没有实现接口的Speak()方法
而是指针类型*Student实现该方法

Go 面试每天一篇（第 27 天）
