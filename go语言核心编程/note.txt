
李文塔


go语言的三大特性：类型系统，接口和并发

go语言编程类型的图书类型

１．基础全面型

２．源码深入型

３．　专业领域型


第１章　基础知识

每种语言都有其独特的应用领域：
在嵌入式领域，汇编和c是首选
在操作系统领域，c是首选
在系统级服务器编程领域，c++是首选
在企业级应用程序和web应用领域，java是


１．１．１　go的诞生北京

(1) 摩尔定律接近失效后多核服务器已经成为主流，当前的编程语言对并发的支持不是很好，
不能很好地发挥多核CPU的威力。
(2) 程序越大，编译速度越慢
(3) 语言越来越复杂

并发，编译速度，编程复杂度

1.1.2 语言特性

语言组织
所有的高级语言都使用源代码来表达程序，主要包括


１．标识符和关键字
２．变量和常量
３．　运算符
４．表达式
５．　简单语句
６．　控制结构


类型系统

１．动静特性：动态语言还是静态语言
２．　类型强弱：强类型还是弱类型
３．　基本数据类型：包括类型及其支持的运算和操作集合
４．　自定义数据类型：包括类型及其支持的运算和操作集合

抽象特性

１．函数：是否支持函数，匿名函数，高阶函数，闭包等
２．　面向对象：是否支持面向对象
３．多态：如何支持多态
４．接口：是否支持接口，以及接口实现模式

元编程特性

１．泛型：是否支持泛型
２．　反射：是否支持反射，反射的能力

运行和跨平台语言特性

１．编译模式：是编译可执行程序，还是编译成中间代码，还是解释器解释执行
２．　运行模式：直接由OS加载运行，还是由虚拟机加载执行
３．　内存管理：是否支持垃圾回收
４．　并发支持：是否原生支持并发，还是库支持
５．交叉编译：是否支持交叉编译
６．　跨平台支持：是否支持多个皮糖

语言软实力特性
１．库：标准库和第三方库是否丰富，好用，高效
２．　框架：是否有出众的框架
３．语言自身兼容性：语言规范是否
４．语言的他影响力

go

支持顺序，循环，分支，静态语言，支持运行时动态类型
强类型，支持隐式类型推导，类型安全，支持type自定义
支持函数，类型组合支持面向对象，接口
Duck模型，通过接口支持

没有泛型支持，有反射支持
编译成可执行程序

直接运行，支持自动垃圾回收
协程(语言原生支持)，支持交叉编译，支持跨平台

应用领域：
云计算基础设施软件，中间件，区块链


将新知识与已经掌握的旧知识进行对比，
将新知识链接到旧知识里面，最终形成一个知识体系。

技能就是把已经掌握的抽象成解决问题的认知模型，这些
认知模型能够直到摸解决某个领域和相似领域的问题

main是可执行程序的包名，所有的go源程序文件头部必须有一个
包声明语句，go通过包来管理命名空间

import 引用一个头部包fmt,可以是标准库的包，也可以是第三方或自定义的
包，fmt是标准输入/输出包

func关键字声明定义一个函数，函数名为main,main代表go程序入口函数

fmt包里面的Printf函数，函数实参是一个字符串字面量，在标准输出
\n是一个转义符，表示换行

go源代码的特征

１．源程序以.go为后缀
2. 源程序默认为UTF-8编码
3. 标识符区分大小写
4. 语句结尾的分号可以省略
5. 函数以func开头，函数体开头的"{"　必须在函数头所在行尾部，不能单独起一行
６、　字符串字面量使用""""(双引号)括起来
7. 调用表里面的方法通过点"."访问符，比如示例中的fmt.Printf
8. main函数所在的包名必须是main


go build hello.go
./hello

1.3 go词法单元


现代高级语言的源程序内部的几个概念：
１．token
2.关键字
3. 标识符
4. 操作符
5. 分隔符
6. 字面量

1.3.1 token

token是构成源程序的基本不可再分割的单元。
编译器编译源程序的第一步就是将源程序分割为一个个独立的
token,这个过程就是词法分析。

go语言的token可以分为关键字，标识符，操作符，分隔符和字面量等


go的toke分隔符有两类：
１．操作符
２．自身没有特殊函数，仅用来分隔其他token,被称为纯分隔符


操作符：操作符就是一个天然的分隔符，同时其自身也是一个token,

sum := a+b

纯分隔符：其本身不具备任何语法含义，只作为其他token的分割
功能。博爱看空格，制表符，换行符和回车符，多个相邻的空格或
制表符会被编译器看作分隔符处理，比如 package main

这是一个包声明的语句，pakcage和main之间可以有任意多个
空格或制表符，go编译器会将其作为一个分隔符处理，最后
分离出来两个token:package 和main



1.3.2 标识符

go语言预声明的标识符包括关键字，内置数据类型标识符，常量值
标识符，内置函数和空白标识符。在写go源程序的过程中，
用户自定义标识符用在包名，函数名，自定义类型名，变量名和
常量名等


关键字

break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var


１．引导程序整体结构的８个关键字


package //定义包名的关键字
import //导入包名关键字
const //　常量声明关键字
var //变量声明关键字
func //函数定义关键字
defer //延迟执行关键字
go // 并发语法糖关键字
return //函数返回关键字

2. 声明符合数据结构的４个关键字

struct //定义结构类型关键字
interface //定义接口类型类型关键字
map  //声明或创建map类型关键字
chan //声明或创建通道类型关键字

3. 控制程序结构的１３个关键字

if else // if else语句关键字
for range break continue //for循环使用的关键字
switch select type case default fallthrough // switch和select 语句使用的关键字

goto //goto跳转语句关键字

内置数据类型标识符(20个)

丰富的内置类型支持是高级语言的基本特性，基本类型也是构造用户自定义类型的基础。
为了标识符每种内置数据类型，go定义了一套预声明标识符，这些标识符用在变量或常量声明时，

内置数据类型标识符(20个)

数值(16个)
	整型(12个)
		byte int int8 int16 int32 int64
		uint uint8 uint16 uint32 uint64 uintptr
	浮点型(2个)
		float32 float64

	复数型(2个)
		complex64 complex128


字符和字符串型(2个)
string rune
接口型(1)
error


go是一种强类型静态编译型语言，在定义变量和常量时需要显式地指出数据类型，
go也支持自动类型推导，在声明初始化内置类型变量时，go可以自动地进行类型推导。
在定义新类型或函数时，必须显式地带上乐行标识符。

内置函数 １５个

make new len cap append copy delete panic recover close
complex real image Print Println


内置函数也是高级语言的一种语法糖，由于其是语言内置的，不需要用import 引入，内置函数
具有全局可见性。注意到其都是以小写字母开头的，但是并不影响其全局可用性。

常量值标识符(4个)
true false // true和false表示bool　类型的两常量值：真和假
iota  //用在连续的枚举的声明中
nil // 指针/引用型的变量的默认值就是nil


go的常量值标识代表的是一个常量值，这个常量值表达特殊的汉所以，
不好使用产量字面量直接表达时，就使用一个预先声明的标识符代替


空白标识符(1个)



空白标识符有特殊的汉所以，用来声明一个匿名的变量，该变量在赋值表达式的左端，空白标识符引用通常被用作
占位，比如忽略函数多个返回值中的一个和强制编译器做类型检查

１.3.3 操作符和分隔符


操作符就是语言所使用的符合集合，包括运算符，显式的分隔符，
纯粹的分隔符有４个：　空格，制表符，回车和换行


算术运算符(5个)
+ - * / %

位运算符(6个)
& | ^ &^ >> <<

赋值和赋值复核运算符(13个)

 :=  = += -= *=   &= |= ^= &^= >>= <<=

比较运算符(6个)

> >= < <= == !=


括号(6个)
() {} []

逻辑运算符(3个)

&& || !


自增自减操作符(2个)

++ --

注意，golang中自增，自减操作符是语句不是表达式

其他运算符(6个)

: , ; . ... <-


1.3.4 字面常量

编程语言源程序中表示固定值的符号叫做字面常量，简称字面量。

字面量可以被编程语言编译器直接转换为某个类型的值。
go的字面量可以出现在两个地方：
一是，用于常量和变量的初始化，而是用于在表达式里或作为函数调用实参。
变量初始化语句汇总如果没有显式地指定变量类型，则go编译器会结合字面量的值自动
进行类型推断。go中的字面量只能表达基本类型的值，go不支持用户定义的字面量


字面量有如下几类


１．整型字面量(Integer literals)
43
2.浮点型字面量
2.3

3. 复数类型字面量

4. 字符型字面量

go的源码采用的是UTF-8的编码方式，UTF-8的字符占用的字节数可以有1~4个字节，
Rune字符常量也有很多表现形式，但是使用" '' "(单引号)将其括住


'a'
'本'
'\t'
５．　字符串字面量

字符串字面量的基本表现形式就是使用" "" "(双引号)，将字符序列包括在内，双引号里面可以是
UTF-8的字符字面量，也可以是其编码值

"\n"
"\""
"Hello,world! \n"
"中国人"

go的源程序基本构成：
１．关键字引起程序的基本结构
２．内置类型标识符辅助声明变量和常量
3. 字面量辅助变量和常量的初始化
4. 分隔符帮助go编译器识别各个token
5. 操作符和变量，关键字一起构成丰富的语法单元


1.4 变量和常量

高级语言通过一个标识符来绑定一块特定的内存，后续对特定的内存的操作都可以使用该标识符来代替。

这种绑定某个存储单元的标识符又可以分为两类：
一类是变量，一类是常量

变量表示指向的内存可以被修改，常量表示指向的内存不能被修改

1.4.1 变量
变量：使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时指定的类型决定，
该内存地址里面存放的内容可以改变
go的基本类型变量声明有两种：
１．　显式的完整声明

var varName dataType [ = value]
go的变量声明后就会立即为其分配空间

var a int=1

2. 短类型声明

varName := value

:= 声明只能出现在函数内(包括在方法内)
此时go编译器自动进行数据类型推断
go支持多个类型同时声明并赋值

a,b := 1,"hello"



变量具有如下几个睡醒
１．变量名
２．　变量值

变量实际指向的是地址里存放的值，变量的值具体怎么解析是由变量的类型来决定的。
在初始化变量值时，可以使用字面量，也可以使用其他的变量名

3. 变量存储和生存期

go语言提供自动内存管理，通常程序员不需要特别关注变量的生存期和存放位置。编译器使用
栈逃逸技术能够自动为变量分配空间：可能在栈上，也可能在堆上

4. 类型信息

类型决定了该变量存储的值怎么解析，以及支持哪些操作和运算，不同类型的变量支持
的操作和运算集是不一样的

５．　可见型和作用域

go内部使用统一的命名空间对变量进行管理，每个变量都有一个唯一的名字，
包名是这个名字的前缀


1.4.2 常量

常量使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义常量时指定
的类型决定，而且该内存地址里面存放的内容不可以改变。
go中常量分为布尔型，字符串型和数值型常量。常量存储在程序的只读段里
预声明标识符iota用在常量声明中，其初始值为0.一组多个常量同时声明时其值逐行增加，
iota可以看作自增的枚举变量，专门用来初始化常量

1.5 基本数据类型
go是一种强类型的静态编译语言，类型是高级语言的基础，有了类型，高级语言才能对不同类型抽象
出不同的运算，

go内置七类基本数据类型(20个具体子类型)

布尔类型:bool
整型：byte int int
浮点型:float32 float64
复数
字符:rune
字符串：string
错误类型：error

1.5.1 布尔类型

var ok bool
ok = true

ok := false

布尔类型数据和整型数据不能进行相互转换

var a bool
a = 1
比较表达式和逻辑表达式的结果都是布尔类型数据

var b bool = (x>y) && (x>0)

if和for语句的条件部分一定是布尔类型的值或表达式

if a<= b{


for;tune ;{}

声明的布尔型变量如不指定初始化值，则默认为false
var b bool 


1.5.2  z整型


var a int =1
var b int32 =2
b =a

整型支持算术运算和位运算，算术表达式和位操作表达式的结果还是整型

1.5.3 浮点型


(1) 浮点数字面量被自动类型推断为float64类型

var b :=10.00
(2) 计算机很难进行浮点数的精确表示和存储，因此两个浮点数之间不应该使用== 或!= 进行比较操作，
高精度科学计算应该使用math标准库

１．５．４　复数类型


1.5.5 字符串

go语言将字符串作为一种原生的基本数据类型，字符串的初始化可以使用字符串字面量

var a = "hello,world"

(1) 字符串是常量，可以通过类似数组的索引访问其字节单元，但是不能修改某个字节的值

var a = "hello world"
	b:= a[0]
	
(2) 字符串转换为切片[]byte(s)要慎用，尤其是当数据量较大时(每转换一次都需要复制内容)
(3) 字符串尾部不包含NULL字符
(4)　字符串类型底层实现是一个二元的数据结构，一个是指针指向字节数组的起点，
另一个是长度

(5) 基于字符串创建的切片和原字符串指向相同的底层字符数组，一样不能修改，对字符串的切片操作返回的子串让然是string,而非slice
a := "hello"

(6) 字符串和切片的转换：字符串可以转换为字节数组，也可以转换为Unicode的字数组

b := []byte(a)
c := []rune(a)

(7) 字符串的运算


1.5.6 rune类型

go内置两种字符类型：一种是byte的字节类类型(byte是uint的别名)
另一种是表示Unicode编码的字符rune.
rune　在go内部是int32类型的别名，占用4个字节。
go语言默认的字符编码是UTF-8类型的，如果需要特殊的编码转换，则使用Unicode/UTF-8标准包


１．６　复合数据类型

指针，数组，切片，字典(map)，通道，结构体和接口

*pointerType // 指针类型使用*后面跟其指向的类型名
[n] elementType //数组类型使用[n]后面跟数组元素类型表示,n表示该数组的长度
[] elementType //切片类型使用[] 后面跟切片元素类型表示
map [keyType] valueType //map 类型使用map[键类型]值类型来表示
chan valueType //通道使用chan后面跟通道元素类型来表示

struct{
	feildType feildType
}  // 结构体类型使用struct{}将各个结构字段括起来表示

interface{ // 接口类型使用interface{}将各个方法括起来表示
	method1(inputParams)(returnParams)
}


1.6.1 指针



go语言支持指针，指针的声明类型为*T,go同样支持多级指针**T
通过在变量名前加&来获取变量的地址

(1) 指针赋值
*T = ,表示指针声明
=*T,表示取指针指向的值

var a =1
p := &a

(2) 结构体指针访问结构体字段仍然使用.操作
type User struct{
	name string
	age int
}

andes := User{
	name:"andes",
	age :18,
}
p := &andes
fmt.Println(p.name) // p.name 通过.操作符访问成员变量

(3) go不支持指针的运算

(4) 函数中允许返回局部变量的地址

go编译器使用"栈逃逸"机制将这种局部变量的空间分配在堆上。

func sum(a,b int) *int{
	sum := a+b
	return &sum //允许，sum会分配在heap上
}


1.6.2 数组

数组的类型名是[n]elementType,其中n是数组长度，elementType是数组元素类型。比如一个包含2个int类型元素
的数组类型可表示为[2]int.
数组一般在创建时通过字母量初始化，单独声明一个数组类型变量而不进行初始化是没有意义的

var arr [2]int //声明一个有两个整型的数组，但元素默认值都是0,一般很少使用

array := [...]float64{7.0,8.5,9.1} // [...]后面跟字面量初始化列表

数组初始化

a := [3]int{1,2,3} //指定长度和初始化字面量
a := [...]int{1,2,3} // 不指定长度，但是由后面的初始化列表数量来确定其长度
a := [3]int{1:1,2:3} //　指定总长度，并通过索引值进行初始化，没有初始化元素时使用类型默认值

a := [...]int{1:1,2:3} //不指定总长度，通过索引值进行初始化，数组长度由最后一个索引值确定，没有
		指定索引的元素被初始化为类型的零值


数组的特定啊
(1) 数组创建万长度就固定了，不可以再追加元素
(2) 数组是值类型的，数组赋值或作为函数参数都是值拷贝
(3) 数组长度是数组类型的组成部分，[10]int和[20]int表示不同的类型
(4) 可以根据数组创建切片


数组相关操作

(1) 数组元素访问

a := [...]int{1,2,3}

b := a[0]
for i,v := range a{}

(2) 数组长度

a := [...]int{1,2,3}
alengh := len(a)
for i:=0 ; i<alengh;i++{
	}

1.6.3 切片

go语言的数组的定长性和值拷贝限制了其使用场景，go提供了
另一种数据类型slice(中文为切片)
这是一种变长数组，其数据饥饿哦股中有指向数组的指针，所以
也是一种引用类型

type slice struct{
array unsafe.Pointer
len int
cap int
}

go为切片维护三个元素---指向底层数组的指针，切片的元素数量和
底层数组的容量

(1) 切片的创建

由数组创建

创建语法：array[b:e]
array表示数组名;b表示开始索引，可以不指定，默认是0;
e表示结束索引，可以不指定，
默认是len(array)
array[b:e]表示创建一个包含e-b个元素的切片，
第一个元素是array[b],最后一个元素是array[e-1]



通过内置函数make创建切片

注意：由make创建的切片各元素被默认初始化为切片元素类型的零值


// len =10,cap =10

a := make([]int,10)

// len = 10,cap =15

这里要注意:直接声明切片类西藏变量是没有意义的

此时切片a的底层的数据结构如图

(2) 切片支持的操作

内置函数len()返回切片长度
内置函数cap()返回切片底层数组容量
内置函数append()对切片追加元素
内置函数copy()用于复制一个切片

(3) 字符串和切片的相关转化

1.6.4 map

go语言内置的字典类型为map


map[K]T
K可以是任意可以进行比较的类型，T是值类型。map也是一种引用类型

(1) map的黄建
使用字面量创建


使用内置的make函数创建

make(map[K]T) // map的容量使用默认值
make(map[K],len) // map的容量使用给定的len值

(2) map支持的操作

1. map的单个键值对访问格mapName[key]，更新某个key的值时mapName[key]
放到等号左边，访问某个key的值时mapName[key]放在等号的右边

2. 可以使用range遍历一个map类似变量，但是不保证每次迭代元素的顺序

3. 删除map中的某个键值，使用如下语法:delete(mapName,key)
delete是内置函数，用来删除map中的某个键值对

4. 可以使用内置的len()函数返回map中的键值对数量


注意

go内置的map不是并发安全的，并发安全的map可以使用标准包sync中的map


不要直接修改map value内某个元素的值，如果向修改map的某个键值，则必须
整体赋值


1.6.5 struct


go中的struct类型和C类似， 也称为结构体，由多个不同类型元素组合而成。
这里有两层：
1. struct结构中的类型可以是任意类型
2. struct的存储空间是连续的，
其字段按照声明时的顺序存放(注意字段之间有对齐要求)


struct有两种形式：一种是struct类型字面量，另一种
是使用type声明的自定义struct类型

(1) struct类型字面量

struct类型字面量的声明格式如下


struct {
	FeildName FeildType
}


(2) 自定义struct类型。自定义struct类型声明格式如下：

type  TypeName struct{
	FeildName FeildType}


实际使用struct字面量的场景不多，更多的时候是通过type自定义一个
新的类型来实现的。
type 是自定义类型的关键字，不但支持struct类型的创建，
还支持任意其他子定义类型的创建。


(3) struct类型变量的初始化

type Person struct{
	Name string
	Age int
}


type Student struct{
	*Person
	Number int
}


//按照类型声明顺序，逐个赋值
// 不推荐这种初始化方式，一旦struct增加字段，则整个初始化语句会报错


a := Person{"Tom",31}




//推荐这种使用Feild名字的初始化方式，没有指定的字段则默认初始化为类型的零值

p := &Person{
	Name:"tata",
	Age:12,
}


s := Student {
	Person:p,
	Number:110,
}


其他复合类型

接口(Interface),通道(chan)


1.7 控制接口


程序指令都是线性地存放在存储器上。

程序执行从本质上来说就是两种模式：顺序和跳转



顺序就是按照程序指令在存储器上的存放顺序逐条执行
跳转就是遇到跳转指令就跳转到某处继续线性执行

go是一门高级语言，起源程序虽然经过了高度的抽象并封装了很多语法糖，但
还是跳不出这个模式(暂时不考虑goroutine引入并发后的执行视图变化)

顺序在Go里面体现在从main函数开始逐条向下执行，就像我们的程序源代码
顺序一样：跳转在Go里面体现为多个语法糖，包括goto语句和函数调用，
分支(if,switch,select)，循环(for)
跳转分为两种：一种是无条件跳转，比如函数调用和goto语句：一种是有条件的
跳转，比如分支和循环

顺序语句很简单，就是我们天然写程序的从前往后的顺序



go的源代码的熟悉并不一定是编译后最终可执行的程序的指令顺序

1.7.1 if语句

特点

1. if后面的条件判断子句不需要用小括号括起来
2. {必须放在行尾，和if或if else放在一行
3. if后面可以带一个简单的初始化语句，并以分号分割，该简单语句
声明的变量的作用域是整个if语句块，包括后面的else if和else分支

4. Go语言没有条件运算符(a>b?a:b),这也符合Go的设计哲学，
只提供一种方法做事情

5. if分支语句遇到return后直接返回，遇到break则跳过break下方
的if语句块

if x<= y{
	return y
}else{
	return x
}

一个完整的if else的语句示例


if x := f(); x< y{ //初始化语句中的声明变量x
	return x
} else if x> z{ //x在else if里面一样可以被访问
	return z
}else{
	return y
}


最佳实践

1.尽量减少条件语句的复杂度，如果条件语句太多，太复杂，则建议放到函数里面
封装起来
2. 尽量减少if语句的嵌套层次，通过重构让代码变得扁平，便于阅读


if err,file := os.Open("xxxx"); err == nil{
	defer file.Close()
	//do something
	}else{
		return nil,err
}

修改后的代码

err,file := os.Open("xxx")
if err != nil{
	return nil,err
}
defer file.Close()
//do something


17.2 switch语句


switch语句会根据传入的参数检测并执行符合条件的分支

switch的语法特点：


1.7.3 for语句
return 和函数调动

return语句也能引发控制流程的跳转，用于函数和方法的退出。

函数和方法的调用也能引发程序控制流的跳转，

第2章 函数

函数是程序执行的一个基本语法结构，go语言的
很多特性是基于函数这个基础实现的
命名类型的方法本质上是一个函数，类型方法是go面向
对象的实现基础
接口，其底层同样是指针和函数将接口和接口实例连接起来的
甚至go并发语法糖go也是函数

1. 函数是一种类型，函数类型变量可以像其他类型变量一样使用
可以作为其他函数的参数或返回值，也可以直接调用执行
２．　函数支持多值返回。
３．　支持闭包
４．　函数支持可变参数

2.1 基本概念

２．１．１　函数定义

函数是go程序源代码的基本构造单位，一个函数包括如下几个部分
函数声明关键字func,
函数名
参数列表
返回列表
函数体

func funcName(param-list)(result-list){
	function-body
}


函数的特点

(1) 函数可以没有输入参数，也可以没有返回值(默认返回0)

func A(){
	//do something
}

func A()int{
	//do something
	return1
}

(2) 多个相邻的相同类型的参数可以使用简写模式


func add(a,b int) int{
	// a int,b int 可以简写为 a,b int
	return a+b
}
(3) 支持有名的返回值，参数名就相当于函数体内最外层的局部变量
命名返回值变量会被初始化为类型零值，最后的return可以
不带参数名直接返回


// sum　相当于函数内局部变量，被初始化为领

func add(a,b int) (sum int){
	sum = a+b
	return // return sum的简写模式
	// sum := a+b
	//如果是sum := a+b,则相当于新声明一个sum	
	// 变量命名返回变量sum覆盖
	//return sum // 最后需要显式地调用return sum

(4) 不支持默认值参数
(5) 不支持函数重载
(6) 不支持函数嵌套，严格地说是不支持函数的嵌套定义，
但支持嵌套匿名函数

func add(a,b int)(sum int){
	anonymous := func(x,y int)int{
		return x+y
}
	return anonymous(a,b)


2.1.2  多值返回
go函数支持多值返回，定义多值返回的返回参数列表时要使用"()"包裹，
支持命名参数的返回


func swap(a,b int)(int,int){
	return b,a
}

习惯用法：

１．如果多值返回值有错误类型，则一般将错误类型作为最后一个返回值
２．　有关多值返回的内部实现原理


2.1.3 实参到形参的传递

go函数实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，那是
因为参数传递的是指针值的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本

二者指向同一地址，本质上参数传递仍然是值拷贝

2.1.4 不定参数

Go函数支持不定数目的形式参数，不定参数声明使用param...type的语法格式

函数的不定参数有如下特点：

（１）　所有的不定从桉树类型必须是相同的
（２）　不定参数必须是函数的最后一个参数
（３）　不定参数名在函数体内相当于切片，对切片的操作同样适合对不定
参数的操作

func sum(arr...int)(sum int){
	for _,v := range arr{ // 此时arr就相当于切片，可以使用range访问
	sum += v
	}
	return
}


(4) 切片可以作为参数传递给不定参数，切片名后要加上"..."

func sum(arr ...int)(sum int){
	for _,v := range arr{
		sum += v
	}
	return 
}


func main(){
	slice := []int{1,2,3,4}
	array := [...]int{1,2,3,4}

	//数组不可以作为实参传递给不定参数的函数

	sum(slice...)
}

(5) 形参为不定参数的函数和形参为切片的函数类型不相同。

func suma(arr ...int)(sum int){
	for v := range arr {
		sum += v
		}
	return
}


func sumb(arr []int)(sum int){
	for v:= range arr{
		sum +=v
	}
	return 
}


// suma 和sumb的类型并不一样

fmt.Printf("%T \n",suma) // func(...int) int
fmt.Printf("%T \n",sumb) // func([]int) int

2.2 函数签名和匿名函数


２．２．１　　函数签名

函数类型又叫函数签名，一个函数的类型就是函数定义首行去掉函数名，参数名和{
，可以使用fmt.Printf的"%T"格式化参数打印函数的类型

两个函数类型相同的条件是，拥有相同的形参列表和返回值列表(列表元素的次序，个数
和类型都相同)，形参名可以不同

func add(a,b int) int {return a+b}

func sub(x int,y int)(c int) {c=x-y;return c}


可以使用type定义函数类型，函数类型变量可以作为函数的参数或返回值

函数类型和map,slice,chan一样，实际函数类型变量和函数名都可以
当做指针变量，该指针指向函数代码的开始位置。
通常说函数类型变量是一种引用类型，未初始化的函数类型的
变量的默认值是nil


Go中函数是"第一公民"(first class)
有名函数的函数名可以看作函数类型的常量，可以直接使用函数名调用函数，也可以
直接赋值给函数类型变量，后续通过该变量来调用该函数

package main

func sum(a,b int) int{
	return a+b
}

func main(){
	sum(3,4) //直接调用
	f := sum // 有名函数可以直接赋值给变量
	f(1,2)
}

2.2.2 匿名函数


GO提供两种函数：有名函数和匿名函数。匿名函数可以看作函数字面量，所有直接使用
函数类型变量的地方都可以由匿名函数代替。
匿名函数可以直接赋值给函数变量，当做实参，也可以作为返回值，还可以直接被调用

2.6 defer

Go函数里提供了defer关键字，可以注册多个延迟调用，这些调用以先进后出(FILO)
的顺序在函数返回前被执行。这有点类似与Java语言中异常处理的finanly子句。
defer常用于保证一些资源最终一定能够得到回收和释放


defer后面必须是函数或方法的调用，不能是语句，否则会报expression　in defer
must be function call错误

defer函数的实参在注册时通过值拷贝传递进去。下面的代码，
实参a的值在defer注册时通过值通过值拷贝传递金融区，后续
a++并不会影响defer语句最后的输出结果

func f() int{
	a := 0
	defer func(i int){
		println("defer i=",i)
	}(a)

	a++
	return a
}

//defer 打印结果
defer i=0
defer 语句必须先注册后才能执行，如果defer位于return之后，则defer因为
没有注册，不会执行

主动调用os.Exit(int)退出进程时，defer将不再被执行(即使defer
已经提前注册)

defer的好处是可以在一定程度上避免资源泄露，特别是在很多return语句，有多个资源需要关闭
的场景中，很容易漏掉资源的关闭操作

func CopyFile(dst,src string)(w int64,err error){
	src,err := os.Open(src)
	if err != nil {
		return
	}
	dst, err := os.Create(dst)
	if err != nil{
		//src 很容易被忘记关闭
		src.Close()
		return
	}
	w. err = io.Copy(dst,src)
	dst.Close()
	src.Close()
	return
}


使用defer改写后，在打开资源无报错后直接调用defer关闭资源，一旦
养成这样的编程习惯，很难会忘记资源的释放


func CopyFile(dst,src string)(w int64,err error){
	src,err := os.Open(src)
	if err != nil{
		return
	}
	defer src.Close()

	dst, err := os.Create(dst)
	if err != nil{
		return	
	}
	defer dst.Close()

	w,err = io.Copy(dst,src)
	return
}


defer语句额位置不当，有可能导致panic,一般defer语句放在错误检查语句之后，
defer有明显的副作用：defer会推迟资源的释放，defer尽量不要放到循环语句里面，
将大函数内部的defer语句单独拆分成一个小函数是一种好的策略

另外，defer相对于普通的函数调用需要间接的数据结构的支持，
相对于普通函数调用有一定的性能损耗


defer中最好不要对有名返回值参数进行操作，否则报错


２．４　闭包

２．４．１　概念

闭包是由函数及其相关引用环境组合而成的实体，一般通过在匿名函数中引用
外部函数的局部变量或包全局变量构成

闭包＝函数＋引用环境变量

闭包对闭包外的环境引入是直接引用，编译器检测到闭包，会将闭包引用的外部变量分配到堆上


如果函数返回的闭包引用咧该函数的局部变量(参数或函数内部变量)


(1) 多次调用该函数，返回的多个闭包所引用的外部变量是多个副本，原因是每次调用
函数都会局部变量分配内存。
(2) 用一个闭包函数多次，如果该闭包修改了其引用的外部变量，则每一次调用该
闭包对该外部变量都有影响，因为闭包函数共享外部引用

f和g引用的是不同的a

如果一个函数调用返回的闭包引用了全局变量，则每次调用都会影响到全局变量


如果函数返回的闭包引用的是全局变量a,则多次调用该函数返回的多个闭包引用的都是同一个
a.同理，调用一个闭包多次引用的也是同一个a.
此时如果闭包中修改了a值的逻辑，则每次闭包调用都会影响全局变量a的值。
使用闭包是为了减少全局变量，所以闭包引用全局变量不是好的编程方式


同一个函数返回的多个闭包共享该函数的局部变量


2.4.2 闭包的价值


闭包最初的目的是减少全局变量，在函数调用的过程中隐式地传递共享变量，
有其有用的一面：但是这种隐秘的共享变量的方式带来的坏处是不够直接，
不够清晰，除非是非常有价值的地方，一般不建议使用闭包


对象是附有行为的数据，而闭包是附有数据的行为，类在定义时已经显式地集中
定义了行为，但是闭包中的数据没有显式地集中声明的地方，
这种数据和行为耦合的模型不是一种推荐的编程模型，闭包仅仅
是锦上添花的东西，不是不可缺少的


2.5 panic和recover


这两个内置函数用来处理go的运行时错误(runtime errors)
panic用来主动抛出错误，
recover用来捕获panic抛出的错误

２．５．	　基本概念

panic(i interface{})
recover() interface{}


引发panic有两种情况，一种是程序主动调用panic函数，另一种是程序产生运行的错误
由运行时检测并抛出

发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层
向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获
或运行到最外层函数而退出

panic的参数是一个空接口类型interface{}，所以任意类型的变量都可以传递给panic(空即可欧)

调用panic的方法非常简单：panic(xxx)


panic不但可以在函数正常流程中抛出，在defer逻辑里也可以再次调用panic或
抛出panic

defer里面的panic能够被后续执行的defer捕获

recover()用来捕获panic,阻止panic继续向上传递。recover()和defer
一起使用，但是recover()只有在defer后面的函数体内被直接调用
才能捕获panic终止异常，否则返回nil,
异常继续向外传递

defer func(){
	println("defer inner")
	recover()
}()


func except(){
	recover()
}


func test(){
	defer except()
	panic("test panic")
}


可以有连续多个panic被抛出，连续多个panic的场景只能出现在的延迟调用
里面，否则不会出现多个panic被抛出的场景，但只有最后一次panic能被捕获


包中init函数引发的panic只能在init函数中捕获，在main中无法被捕获，
原因是init函数先于main执行，函数并不能捕获内部新启动的goroutine所抛出的panic



2.5.2 使用场景

什么情况下主动调用panic函数抛出panic?

一般有两种情况：
(1) 程序遇到了无法正常执行下去的错误，主动调动panic函数
结束程序运行
(2) 在调试程序时，通过主动调用panic实现快速退出，panic
打印出堆栈能够更快地定位错误

为了保证程序的健壮性，需要主动在程序的分支流程上使用recover()拦截
运行时错误

Go提供了两种处理错误的方式，一种是借助panic和recover的抛出
捕获机制，另一种是使用error错误类型。

2.6 错误处理

2.6.1 error

Go语言内置错误接口类型error.任何类型只要实现Error() string方法，
都可以传递error接口类型变量。Go语言典型的错误处理方式是将
error作为函数最后一个返回值。
在调用函数时，通过检测其返回的error值是否为nil来进行错误处理


type error　interface{
	Error() string
}

Go 语言标准库提供的两个函数返回实现了error接口的具体类型实例，
一般的错误可以使用这两个函数进行封装。遇到复杂的错误，用户也可以
自定义错误类型，只要其实现error接口接口

错误处理的最佳实践


１．　在多个返回值的函数中，error通常作为函数最后一个返回值

２．　如果一个函数返回error类型变量，则先用if语句处理error!=nil
的异常场景，正常逻辑放到if语句块的后面，保持代码平坦
3. defer语句应该放到err判断的后面，不然有可能产生panic
4. 在错误逐级向上传递的过程汇总，错误信息应该不断地丰富和完善，
而不是简单地抛出下层调用的错误，这在错误日志分析时非常有用和友好


2.6.2 错误和异常


异常和错误在现代编程语言中

错误(errors)
未捕获错误－异常(untrapped error)
可捕获错误(trapped error)
compile errors
runtime errors
logic errors

Go是一门类型安全的语言，其运行时不会出现这种编译器和运行时
都无法捕获的错误，不会出现untrapped error,
Go语言不存在所谓的异常，出现的"异常"全是错误

Go程序需要处理的这些错误可以分为两类：

一类是运行时错误(runtime errors),此类错误语言的运行时能够捕获，
并采取错误－－隐式或显式地抛出panic

一类是程序逻辑错误：程序执行错误不符合预期，但不会引发运行时错误


Go对于错误提供了两种处理机制：
（１）　通过函数返回错误类型的值来处理错误
(2) 通过panic打印程序调用栈，终止程序执行来处理错误

所以对错误的处理也有两种方法，一种是通过返回一个错误类型值来处理错误，ｍ
另一种是直接调用panic抛出错误，退出程序

Go是静态强类型语言，程序的大部分错误是可以在编译器检测到的，
但

２．７　底层实现

２．７．１　函数调用规约。

Go函数使用的是caller-save的模式，即由调用者负责保存寄存器，
所以在函数的头尾不会出现push ebp;mov esp ebp这样的代码

２．７.2 汇编基础


第３章类型系统


３．１　类型简介


简单类型和复合类型

３．１．１　命名类型和未命名类型

类型可以通过标识符来表示，这种类型称为命名类型。

一个类型由预声明类型，关键字和操作符组合而成，这个类型称为未命名类型。
未命名类型又称我类型字面量(Type Literal)


Go语言的基本类型中的复合类型：数组(array),切片(slice)
字典(map),通道(channel),指针(pointer)
函数字面量(function),结构(struct)和接口(interface)
都属于类型字面量，也都是未命名类型

所以 *int,[]int,[2]int,map[k]v都是未命名类型

(1) 未命名类型和类型字面量是等价的，我们通常是Go语言基本类型中的复合类型
就是类型字面量

(2) 通常所说的Go语言基本类型中的简单类型就是这２０个预声明类型，它们都属于
命名类型
(3) 预声明类型是命名类型的一种，另一类命名类型是自定义类型


3.1.2 底层类型

3.1.3 类型相同和类型赋值

类型可直接赋值

不同类型的变量之间一般是不能直接相互赋值的，除非满足一定的条件。


3.1.4 类型强制转换

var a T = (T)(b)，使用括号将类型和要转换的变量或表达式的值括起来


非常量类型的变量x可以强制转化并传递给类型T,需要满足如下的条件：
(1) x可以直接赋值给T类型变量
(2) x的类型和T具有相同的底层类型
(3) x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型
(4) x的类型和T都是整型，或都是浮点型
(5) x的整数值或[]byte类型的值，T是string类型
(7)x是一个字符串，T是[]byte或[]rune
字符串和字节切片之间的转换最常见

s := "hello,世界"
var a []byte
a = []byte(s)
var b string
b = string
var c []rune
c = []rune(s)
fmt.Printf("%T\n",a) 
fmt.Printf("%T\n",b)
fmt.Printf("%T\n",c)

注意
(1) 数值类型和string类型之间的相互转化可能造成值部分丢失；其他的转化仅仅是类型
转换，不会造成值的改变。string和数字之间的转换看可使用标准库strconv
(2)Go语言没有语言机制支持指针和interger之间的直接转换，可以使用标准
库中的unsafe包进行处理


3.2 类型方法


３．２．１　自定义方法

自定义类型。用户自定义类型使用关键字type,其语法格式是type newtype oldtype



自定义struct类型


struct XXXname struct{
	Field1 type1
}


type errorString struct{
	s string
｝

struct　初始化


type Person struct{
	name string
	age int
}

(1) 按照字段顺序进行初始化


a : = Person{"name",18}

b := Person{
	"andes",
	18,
	}


c := Person{
	"andes",
	18}


(2) 指定字段名进行初始化

a : = Person{name:"andes",age:18}


如果"}"独占一行，则最后一个字段的后面一定要带上逗号

(3) 使用new创建内置函数，字段默认初始化为其类型的零值，
返回值是指向结构的指针

p := new(Person)

//此时name为"",age是0


一般使用struct都不会将所有字段初始化为零值

(4) 一次初始化一个字段

(5) 使用构造函数进行初始化


当结构发生变化时，构造函数可以屏蔽细节

func New(text string) error{
	return &errorString{text}
}


type errorString struct{
	s string}



结构字段的特点


结构的字段你可以是任意的类型，基本类型，接口类型，
指针类型，函数类型都可可以作为struct的字段

结构字段的类型名必须唯一，struct字段类型可以是普通类型，
也可以是指针，另外，结构支持内嵌自身的指针，这也是
实现树形和链表等复杂数据结构的基础


//标准库　container/list


type Element struct{
	//指向自身类型的指针
	next,prev *Element
	list *List
	Value interface{}
}


匿名字段

在定义struct的过程中，


// 标准库${GOROOT}/src/os/type.go 内的一个匿名的指针字段
type File struct{
	*file //os specfilec
}


var i interface{}

自定义接口类型




// Reader是自定义接口类型，属于命名类型

type Reader interface{
	Read(p []byte) (n int,err error)
}


3.2.2 方法


go语言的类型方法是一种对类型行为的封装。
其显式地将对象实例或之后怎作为函数的第一个参数，
并且参数名可以自己指定，而不强制要求一定是this或self.
这个对象实例或指针称为方法的接收者(reciever)


// 类型方法接收者是值类型

func(t TypeName)MethodName(ParamList)(Returnlist){
	//method body 
}


//类型方法接收者是指针

func (t *TypeName)MethodName(ParaList)(Returnlist){
	//method body}


Go语言的而理性方法


go语言的类型方法本质上就是一个函数，没有使用隐式的指针

类型方法的特点

(1) 可以为命名类型增加方法(除了接口)，非命名类型不能自定义方法

(2) 为类型增加方法有一个心智，就是方法的定义必须和类型的定义在同一个包中

(3) 方法的命名空间的可见性和变量一样，大写开头的方法可以在包外
被访问，否则只能在包内可见

(4) 使用type定义的自定义类型是一个新类型，新类型不能调用原有类型的
方法，但是底层累心支持的运算可以被新类型继承




3.3  方法调用

类型方法本质上是函数，只是采用了一种特殊的语法书写
类型方法咋调用上也很灵活，

调用方法，方法集，方法变量和方法表达式


３．３．１　一般调用


类型方法的一般调用方式


TypeInstanceName.MethodName(ParamList)

TypeInstanceName:类型实例名或指向实例的指针变量名
MethodName：类型方法名
ParamList：方法实参

type  T struct{
	a int
}

func (t T ) Get() int{
	return t.a
}


func (t *T)Set (i int){
	t.a = i
}


var t = &T{}

//普通方法调用

t.Set(2)


//普通方法调用

t.Get()


3.3.2 方法值(method value)


变量x的静态类型是T,M是类型T的一个方法，x.T被称为方法值(method value)
x.T是一个函数类型变量，可以赋值给其他变量，并像普通的函数名一样使用


f := x.M
f(args...)


等价于
x.M(args...)


方法值(method value)其实是一个带有闭包的函数变量，其底层实现
原理和带有闭包的匿名函数类似，接收者被隐式地绑定到方法值(method value)
的闭包环境中。
后续调用不需要再显地传递接收者

type T struct{
	a int
}


func (t T) Get() int{
	return t.a
}

func (t *T) Print(){
	fmt.Printf("%p, %v,%s \n",t,t,t.a)
}
var t = &T{}


//method value


f := t.Set


//方法值调用

f(2) 
t.Print()

//方法值调用

f(3)
t.Print()

3.3.3 方法表达式(method expression)


方法表达式相当于提供一种语法将类型方法调用
显式地转换为函数调用，接收者(receiver)
必须显式地传递进去。下面定义一个类型T,增加两个方法，方法Get的接收者
为T,方法Set的接收这类型为*T


type T struct {
	a int
}

func (t *T) Set(i int) {
	t.a = i
}


func (t T) Get() int{
	return t.a
}


func (t *T) Print(){
	fmt.Printf("%p. %v, %d \n",t,t,t.a)
}



表达式T.Get和(*T).Set被称为方法表达式(method expression)
方法表达式可以看作函数名，只不过这个函数的首个参数是接收着的实例或指针。
T.Get的函数签名是func(t T)int,(*T).Set的函数前面是func(t *T,i int)
注意，这里的T.Get不能携程(*T).Get
(*T).Set也不能写成T.Set,在方法表达式中编译器不会做自动转换，，

//如下方法表达式调用都是等价的


t := T{a:1}


//普通方法调用


t.Get(t)



//方法表达式调用
(T).Get(t)

//方法表达式调用

f1 := T.Get;f1(t)

//方法表达式调用
f2 := (T).Get;f2(t)


//如下方法表达式调用都是等价的

(*T).Set(&t,1)
f3 := (*T).Set;f3(&t,1)


通过方法值和方法表达式可以看到：go的方法底层是基于函数实现的，
只是语法格式不同，本质是一样的

3.3.4 方法集(method set)

命名类型方法接收这两种类型，一个值乐行，另一个是指针类型，
这个和函数是一样的，前者的形参是值类型，后者的形参是
指针类型。无论接收者是什么类型，方法和函数的实参传递都是
值拷贝。如果接收者是值类型，则传递的是值的副本；
如果接收者是指针类型，则传递的是指针的副本

接收者是Int类型的方法集合(method set):
func (i Int) Print()
func　(a Int) Max(b Int) Int


接收者是*Int 类型的方法集合(method set)


func (i *Int)Set(a Int)


类型的方法集总结如下：

(1) T类型的方法集是S
(2) *T类型的方法集是S和*S




3.3.5 值调用和表达式调用的方法集


具体类型实例变量直接调用其方法时，编译器会所调用方法进行
自动转换，即使接收者是指针的方法，仍然可以使用值类型变量
进行调用。

(1) 通过类型字面量显式的进行值调用和表达式调用，可以看到在这种情况下
编译器不会做自动转换，会进行严格的方法集检查

type Data struct{}

func (Data) TestValue(){}



3.4 组合和方法集

结构类型(struct)为go提供了强大的类型扩展，主要体现在两个方面：
第一，struct可以嵌入任意其他类型的字段
第二，struct可以嵌套自身的指针类型的字段。

这两个特性决定了struct类型有着强大的表达力，几乎可以表示任意
的数据结构。同时，集合结构类型的方法，"数据＋方法"
可以灵活地表达程序逻辑



3.4.1 组合

使用type定义的新类型不会继承原有类型的方法，有个特例就是命名结构类型，
命名结构类型可以嵌套其他的命名类型的字段，外层的结构类型
是可以调用嵌入字段类型的方法，这种调用既可以显式的调用，
也可以隐式的调用。这就是Go的"继承"
准确的说是Go的"组合"
因为Go语言没有继承的语义，结构和字段之间是"has a"的关系
而不是"is a"的关系
没有父子的概念，仅仅是整体和局部的概念，所以后续这种
嵌套的结构和字段的关系为组合


struct中的组合非常灵活，可以表现为水平的字段扩展，由于struct
可以嵌套其他struct字段，所以组合也可以分层次扩展。
struct类型中的字段称为"内嵌字段"

内嵌字段的访问和方法调用遵照的规约


内嵌字段的初始化和访问

struct的字段访问使用点操作符".",struct的字段可以嵌套很多层，
只要内嵌的字段是唯一的即可，不需要使用全路径进行访问。

可以使用z.a 代替z.Y.X.a

package main


type X struct{
	a int
}



type Y struct{
	X
	b int
}


type Z struct{
	Y
	c int
}


func main(){
	x := X{a:1}

	y := Y{
		X:x,
		b:2,
	}

	z := Z{
		Y:y,
		c:3,
}

	println(z.a, z.Y.a,z.Y.X.a)

	z = Z{}
	z.a = 2
	println(z.a,z.Y.a,z.Y.X.a)
}



在struct的多层嵌套中，不同嵌套层次可以有相同的字段，此时最好
使用完全路径进行访问和初始化。
在实际数据结构的定义中应该尽量避开相同的字段，以免在使用中出现歧义


package main


type X struct{
	a int
}


type Y struct{
	X
	a int
}


type Z struct{
	Y
	a int
}


func main(){
	x := X{a:1}
	y := Y{
		X:x,
		a:2,
}


	z := Z{
		Y:y,
		a:3,
	}

	println(z.a,z.Y.a,z.Y.X.a)


	z = Z{}

	z.a = 4
	z.Y.a =5
	z.Y.X.a =6

	println(z.a,z.Y.a,z.Y.X.a)
}


内嵌字段的方法调用

struct类型方法调用也可以使用点操作符，不同嵌套层次的字段可以有
相同的方法，外层变量调用内嵌字段的方法时也可以像嵌套字段的
访问一样使用简化模式。


如果外层字段和内层字段有相同的方法，则使用简化模式
访问外层的方法会覆盖内层的方法。即在简写模式下，
Go编译器优先从外向内逐层查找方法，同名方法中外层的方法能够
覆盖内层的方法。这个特性有点类似于面向对象编程中，子类覆盖
父类的同名方法


package main


import "fmt"


type X struct{
	a int
}


type Y struct{
	X
	b int
}


type Z struct{
	Y
	c int
}


func (x X) Print(){
	fmt.Printf("In X,a=%d\n",x.a)

}


func (x X) XPrint(){
	fmt.Printf("In X,a=%d\n",x.a)
}


func (y Y) Print(){
	fmt.Printf("In Y,b=%d\n",y.b)
}


func (z Z) Print(){
	fmt.Printf("In Z,c=%d\n",z.c)
	//显式的完全路调动内嵌字段的方法

	z.Y.Print()
	z.Y.X.Print()
}



3.4.2 组合的方法集



组合结构的方法集有如下规则


１．　若类型S包含匿名字段T,则S的方法集包含T的方法集合

２．若类型S包含匿名字段*T,则S的方法集包含T和*T方法集

３.不管类型S中嵌入的匿名字段是T还是*T,*s方法集总是包含
T和*T方法集合


３．５　函数类型

一种是函数字面量类型(未命名类型)，另一种是函数命名类型

函数字面量类型

有名函数和匿名

函数声明＝函数名＋函数签名


１．　函数也是一种类型，可以在函数字面量类型的基础上定义一种命名函数类型
２．　有名函数和匿名函数的函数起那么与命名函数类型的底层类型相同，
它们之间可以进行类型转换
3. 可以为有名函数类型添加方法，这种为一个函数类型添加方法的技巧很有效
４．　为有名函数类型添加方法，使其与接口打通关系，使用接口的地方
可以传递函数类型的变量，这位函数到接口的转换开启了大门



第４章　接口


接口是一个编程规约，也是一组方法签名的集合。Go的接口是非侵入式的设计
一个具体类型实现接口不需要在语法上显式地声明，只要具体类型的方法集
是接口方法集的超集，就代表该类型实现了接口

编译器在编译时会进行方法集的校验。
接口是没有具体实现逻辑的，也不能定义字段



变量和实例

实例，代表具体类型的变量，接口变量只有值和类型的概念，
所以接口类型变量仍然称为接口变量，接口内部存放的具体类型
变量被称为接口指向的"实例"
接口只有声明没有实现，所以定义一个新接口，通常
变成声明一个新接口，定义接口和声明接口二者通用，代表相同的意思


空接口

最常用的接口字面量类型就是空接口interface{},由于空接口的方法集
为空，所以任意类型都被认为实现了空接口，任意类型的实例都可以赋值或传递
给空接口，包括非命名类型的实例

注意

非命名了类型由于不能定义自己的方法，所以方法集为空，因此其类型变量
除了传递给空接口，不能传递给任何其他接口



４．１　基本概念


４．１．１　　接口声明


go语言的接口分为接口字面量和接口命名乐行，接口的声明使用interface关键字


in接口字面量类型的声明语法：

interface {
	MethodSignature1
}




接口命名类型使用type关键字声明

type InterfaceName interface{
	MethodSignature1
}



使用接口字面量的场景很少，一般只有空接口interface{}类型变量的声明
才会使用。

接口定义大括号内可以是方法声明的集合，也可以嵌入另一个接口
类型匿名字段，还可以是二者的混合。接口支持嵌入匿名接口字段，
就是一个接口定义里面可以包括其他接口


type Reader interface{
	Read(p []byte)(n int,err error)
}


type Writer interface{
	Write(p []byte)(n int,err error)
}


type ReadWriter interface{
	Reader
	Writer
}


type ReadWriter interface{
	Reader
	Write(p []byte)(n int,err error)
}


type ReadWriter interface{
	Read(p []byte) (n int,err error)
	Write(p []byte)(n int,err error)
}


方法声明

函数签名是函数的字面量类型，函数签名是不包括函数名的，而函数声明
是值带上函数名的函数签名。
接口定义使用方法声明，而不是方法签名，因为方法名是接口的组成部分


方法声明　＝　方法名＋方法签名




声明新接口类型的特点：

１．　接口的命名一般以"er"结尾
２．　接口定义的内部方法声明不需要func引导
３．　在接口定义中，只有方法声明没有方法实现



４．１．２　j接口初四花

单纯地声明一个接口变量没有任何意义，接口只有被初始化为具体的类型时才有意义

接口作为一个胶水层或抽象层，起到抽象和适配的作用。
没有初始化的接口变量，其默认值是nil

接口绑定具体类型的实例的过程称为接口初始化，
接口变量支持两种直接初始化方法，具体ｒｕｘａ　

实例赋值接口


接口被初始化后，调用接口的方法就相当于调用接口绑定的具体类型的方法，
这就是接口调用的语义


接口变量赋值接口变量


已经初始化的接口类型变量a直接赋值给另一个接口变量b,要求b的方法集是a的
方法集的子集。

此时go编译器会在编译时进行方法集静态检查。

这个过程也是接口初始化的一种凡是，此时接口变量b绑定的具体实例是接口变量a
绑定的具体实例的副本


4.1.3 接口方法调用


接口方法调用和普通的函数调用是有区别的，接口方法调用的最终地址是在运行期决定的
将具体类型变量赋值给接口后，会使用具体而理性的方法指针初始化接口变量，
当调用接口变量的方法时，实际上是间接地调用实例的方法。接口方法调用
不是一种直接的调用，有一定的运行开销

直接调用未初始化的接口变量的方法会产生panic


4.1.4 接口的动态类型和静态类型

动态类型


接口绑定的具体实例的类型称为接口的动态类型。接口可以绑定不同类型的实例，
所以接口的动态类型是随着其绑定的不同类型实例而发生变化的


4.2 接口运算

接口是一个抽象的类型，

编程过程中有时需要确认已经已经初始化的接口变量指向实例的具体类型是什么
也需要检查运行时的接口类型


go语言提供两种语法结构来支持这两种需求，分别是类型断言和接口类型查询



4.2.1 类型断言( Type Assertion)

接口类型断言的语法形式

i.(TypeName)

i必须是接口变量，如果是具体类型变量会报错

TypeName可以是接口类型名，也可以是具体类型名


接口查询的两层含义

(1) 如果TypeName是一个具体类型名，则类型断言用于判断
接口变量i绑定的实例类型是否就是具体类型TypeName

(2) 如果TypeName是一个接口类型名，则类型断言用于判断
接口变量i绑定的实例了TypeName接口


接口断言的两种语法表现:

直接赋值模式如下

o :=i.(TypeName)

语义分析：

1.TypeName是具体类型名，此时如果接口i绑定的实例类型
就是具体类型TypeName,则变量o的类型就是TypeName,
变量o的值就是接口绑定的实例值的副本(当然实例可能是
指针值，那就是指针值的副本)
2.TypeName是接口类型名，如果接口i绑定的实例类型
满足接口类型TypeName,则变量o的类型就是接口类型
TypeName,o底层绑定的具体类型实例是i绑定的实例的
副本
3. 如果两种情况都不满足，则程序抛出panic


comma,ok表达式模式

if o,ok := i.(TypeName);ok {}


4.2.2 类型查询(Type Switches)

接口类型查询的

switch v:=i.(type){
case type1:
	xxx
case type2:
	xxx
default:
	xxx


语义分析

接口查询有两层汉所以，一是查询一个接口变量底层板顶的底层变量的具体类型是
什么，二是查询接口变量绑定的底层变量是否还实现了其他接口


(1) i必须是接口类型


具体类型实例的类型是静态的，在类型声明后就不再变化，
所以具体类型的变量不存在类型查询，类型查询一定是对一个
接口变量进行操作。上文中的i必须是接口变量，
如果i是未初始化接口变量，则v的值是nil


var i io.Reader

switch v:=i.(type) {
	// 此处i是为初始化的接口变量，所以v为il
case nil:
	fmt.Printf("%T\n",v) // nil
default:
	fmt.Printf("default")

}


2. case字句后面可以跟非接口类型名，也可以跟接口类型名
匹配是按照case子句的顺序进行的

如果case后面是一个接口乐行名，且接口变量i绑定的实例类型实现了
该接口类型的方法，则匹配成功，v的类型是接口类型，
v底层绑定的实例是i绑定具体类型实例的副本


如果case后面是一个具体类型名，且接口变量i绑定的实例类型和该具体
类型相同，则匹配成功，此时v就是该具体类型变量，
v的值是i绑定的实例值的副本

fallthrough不能在Type Switch语句中使用

注意

go和很多标准库使用的格式

switch i:= i.(type){}


推荐的方法是将i.(type)赋值给一个新变量


switch v:= i.(type){}

类型查询和类型断言


(1) 类型查询和类型断言具有相同的用以，只是语法格式不同
二者都能判定的实例的具体类型，以及判断接口变量绑定的实例是否满足另一个接口类型

(2) 类型查询使用case字句一次判断多个类型，类型断言一次只能
判断一个类型，当然类型断言也可以使用if else语句达到同样的效果


4.2.3 接口优点和使用形式


接口优点：

(1) 解耦：
复杂系统进行垂直和水平的分割是常用的设计手段，在
层与层之间使用接口进行抽象和解耦是一个好的编程内测了
(2)实现泛型
由于现阶段Go语言不支持泛型，使用空接口作为函数或方法
参数能够用在需要泛型的场景中

接口使用形式

接口类型是"第一公民"，可以用在任何使用变量的地方，使用灵活，方便解耦，
1. 作为结构内嵌字段
2. 作为函数或方法的形参
3. 作为函数或方法的返回值
4.作为其他接口定义的嵌入字段

4.3 空接口

4.3.1 基本概念

没有任何方法的接口，称为空接口。空接口表示为interface{}
系统中任何类型都符合空接口的要求，空接口有点类似Java语言中的Object,
不同点，go中的基本类型int,float,string也符合空接口。
go的类型系统里面没有类的概念，所有的类型都是一样的身份，
没有java里面对基本类型的开箱和转箱的操作

所有的类型都是统一的。
go语言的的空接口类似c语言中的void*
只不过void*是指针，而go语言的空接口内部封装了指针而已

4.3.2 空接口的用途

空接口和泛型

go语言没有泛型，如果一个函数需要接收任意类型的参数，则参数类型可以
使用空接口类型，这是弥补没有泛型的一种手段

//典型的就是fmt标准包的print函数

func Fprint(w io.Writer,a ...interface{}) (n int,err error)

空接口和反射


空接口是发射实现的基础，反射库就是将相关具体的类型转换并赋值给空接口后
才去处理，
4.3.3 空接口和nil

空接口表示真的为空，接口有类型和值两个该你那

空接口有两个字段，一个是实例类型，另一个指向绑定实例的指针，
只有两个都为nil时，空接口才为nil


4.4 接口内部实现


接口是Go语言类型系统的灵魂，是go语言实现多态和反射的基础。

Duck类型的接口完全是解耦接口和具体实现者。

定义接口只需要简单声明一个方法和即可，定义新类型时不需要显式
地声明要实现的接口，接口的使用也要很简单

把复杂留给自己，把简单留给用户

接口的底层是如何实现的？如何实现动态调用？
接口的动态调用到底有多大的额外开销？


建立一个接口运行的动态视图。使用了如下技术手段
1. 从语言运行时中抽取部分源码，讲解接口实现中涉及的基本数据结构
2. 从反汇编的代码上分析接口实现机制
3. 从编译的可执行文件中寻找线索


4.4.1 数据结构

接口变量必须初始化才有意义，没有初始化的接口变量的默认值是nil,
没有任何意义。

具体类型实例化传递给接口称为接口的实例化。
在接口的实例化的过程中，编译器通过特定的数据结构描述这个构成

首先介绍费空接口的内部数据结构的，空接口的底层更简单

飞空接口的底层数据结构是iface,位于src/runtime/runtime2.go中


iface数据结构

非空接口初始化的过程就是初始化一个iface类型的结构

type iface struct{
	tab *itab  //itab存放类型及方法指针信息
	data unsafe.Pointer //数据信息
}


可以看到iface结构很简单，有两个指针类型字段

1. itab:用来存放接口自身类型和绑定的实例类型及实例相关的函数指针，
2. 数据指针data:指向接口绑定的实例的副本，接口的初始化也是一种值拷贝


data指向具体的实例数据，如果传递给接口的值类型，则data指向的是实例的副本，
如果传递给接口的指针类型，则data指向指针的副本。

无论接口的转换，还是函数调用，
itab数据结构，itab是接口内部函数的核心和基础



type itab struct{
	iter *interfacetype //接口自身的静态类型
	_type *_type //_type就是接口存放的具体实例的类型(动态而类型)
	// bash存放具体类型的hash值
	has unit32 
	_	[4]byte
	fun [1]uintptr
}



itab有5个字段


inner是指向接口类型元信息的指针

_type是指接口存放的具体类型元信息的指针，iface里的data指针
指向的是该类型的值。一个类型信息，另一个类型的值

hash是具体类型的Hash值，_type里面也有hash

注意

Go语言类型元信息最初由编译器负责构建，并以表的形式存放在编译后的
对象文件中，再由链接器在链接时进行段合并，符号重定向(填充某些值)
这些类型信息在接口的动态调用和反射中被运行时引用


//描述接口的类型

type interfacetype struct{
	type _type //类型通用部分
	pkgpath name //接口所属包的名字信息，name内存放的不仅
	// 有名称，还有描述信息
	mhdr []inmethod //接口的方法
}

//接口方法元信息


type imethod struct{
	name nameOff //方法名在编译后的section里面的偏移量
	ityp typeOff //方法类型在编译后的section里面偏移量
}


4.4.2 接口调用过程分析

4.4.3 接口调用代价


接口动态调用过程，这个过程有两部分多余消耗，一个是接口实例化的过程，
二就是iface结构建立的过程，一旦实例化后，这个接口和具体类型的
itab数据结构是可以复用的;另一个是接口的方法调用，
它是一个函数指针的间接调用。同时我们应考虑到接口调用是一种动态的计算
后的跳转调用，这对现代的计算机CPU的执行很不友好，会导致
CPU缓冲失效和分支预测失败，这也有一部分的性能损失。
当然最直接的办法就是对比测试，看看接口动态调用的性能损失到底有多大


测试用例

4.4.4 空接口数据结构


空接口interface{}是没有任何方法集的接口，所以空接口内部不需要维护和
动态内存分配相关的数据结构itab
空接口只关心存放的具体类型是什么，具体类型的值是什么

所有空接口的底层数据结构也很简单


type eface struct{
	_type *_type
	data unsafe.Pointer
}


从eface的数据结构可以看出，空接口不是真的为空，
其保留了具体实例的类型和值拷贝，即便存放的具体类型是空的，
空接口也不是空的



由于空接口自身没有方法集，所以空接口变量实例化后的真用途不是接口方法的
动态调用。空接口在go语言中真正的意义是支持多态。

有如下几种方式使用了空接口
(将空接口类型还原)

(1) 通过接口类型断言
(2) 通过接口类型查询
(3) 通过反射

接口类型断言和接口类型查询


使用中的技巧，可以继续分析接口断言，接口查询和接口赋值
的内部实现机制

第5章 并发

未来多核是主要的发展方向，硬件对软件领域的影响显著，

软件的并发和并行处理也是未来的方发行


并发编程范式，使用context标准库和go语言并发调度模型


5.1 并发基础


5.1.1 并发和并行


并行意味着程序在任意时刻都是同时运行的
并发意味着程序在单位时间内是同时运行的


并行就是在任一粒度的时间内都具备同时执行的能力：最简单的
并行就是多机，多台机器并行处理


并发是在规定的时间内多个请求都得到执行和处理，强调的是给
外界的感觉，实际上内部可能是分时操作的。

并发重在避免阻塞，使程序不会因为一个阻塞而停止处理。
并发典型的应用场景：分时操作系统就是一种并发设计(忽略多核CPU)


并行是硬件和操作系统开发者重点考虑的问题，作为应用层的成员

唯一可以选择的就是充分利用操作系统提供的API和程序语言特性，
结合实际需求设计出具有良好并发结构的程序，提升程序的并发程序
车里能力。现代程序操作系统能够提供的最基础的并发模型就是多线程和
多进程；编程语言这一层级可以进一步封装来提升程序的并发处理能力



在当前的计算机体系下：并行具有瞬时性，并发具有过程性；并发在于结构
并行在于执行。应用程序具备好的并发结构，操作系统才能更好地利用
硬件并发执行，同时避免阻塞等待，合理地进行调度，
提升CPU利用率。应用成程序员提升程序并发处理能力的一个重要
手段是程序设计良好的并发结构



5.1.2  goroutine



操作系统可以进行线程和进程的调度，本身具备并发处理能力，
但进程切换代价还是过于高昂，进程切换需要保存现场，耗费较多的时间。
如果应用程序能在用户层再构筑一级调度，将并发的粒度进一步降低，
是不是可以更大限度地提升程序运行效率呢？
GO语言的并发就是基于这个思想实现的，
go语言在语言层面支持这种并发模式

Go并发执行体是goroutine

go关键字紧跟一个函数，函数的返回值被忽略


通过go+匿名函数形式启动goroutine

goroutine的特性：


1. go的执行是非阻塞的，不会等待
2. go后面的函数的返回值会被忽略
3. 调度器不能保证多个goroutine的执行次序
4. 没有父子groutine的概念，所有的goroutine是平等地被调度和执行的
5. Go程序在执行时会单独为main函数创建一个goroutine,
遇到其他go关键字再去创建其他的goroutine

6. Go没有暴露goroutine_id给用户，所以不能在一个goroutine
里面显式地操作另一个goroutine，不过runtime包提供了一些函数
访问和设置goroutine的相关信息




1. func  GOMAXPROCS


func GOMAXPROCS(n int)用来设置或查询可以并发执行的goroutine数目
n大于表示设置GOMAXPROCS值，否则表示查询当前的GOMAXPROCS值


2. func Goexit


func Goexit()是结束当前goroutine的运行，Goexit在结束当前goroutine
运行之前会调用当前goroutine已经注册的defer.


Goexit并不会产生panic,所以该goroutine defer里面的recover
调用都会返回nil




3. func Gosched

func Gosched()是放弃当前调度执行机会，将当前goroutine放到队列
中等待下次被调度



只有goroutine还是不够的，多个goroutine之间还需要通信，同步
协同等


5.1.3 chan

chan是一个关键字，是channel的简单些。通道


goroutine是Go语言里面的并发执行体，通道是goroutine之间通信和同步的
重要组件。
Go的哲学是"不要通过共享内存来通信，而是通过通信来共享内存"
通道是Go通过通信来共享内存的载体


通道是有类型的，可以简单地把它理解为有类型的管道。
声明一个简单的通道语句为chan dataType


但是简单声明一个通道变量没有任何意义，a并没有初始化，其值是nil

Go语言提供一个内置函数make来创建tongdao

//创建一个无缓冲的通道，通道存放元素的类型为dataType


make(chan datatype)


//创建一个有10个缓冲的通道，通道存放元素的类型为dataType


make(chan datatype,10)

通道分为无缓冲的通道和有缓冲的通道，Go提供内置函数len和cap，无缓冲的
通道的len和cap都是0,有缓冲的通道的len代表没有被读取的元素数，
cap带代表整个通达的容量，无缓冲的通道既可以用于通信，
也可以用于两个goroutine的同步，有缓冲的通道主要用于通信


为避免main goroutine过早退出，特意"sleep"一段时间。有了通道

后，可以使用无缓冲的通道来实现goroutines之间的同步等待


goroutine运行结束后退出，写到缓冲通道中的数据不会小时，它可以缓冲和适配两个
goroutine处理速率不一致的情况，缓冲通道和消息队列，
有削峰和增大吞吐量的功能

操作不同状态的chan会引发三种行为

panic
(1) 向已经关闭的通道写数据会导致panic

最佳时间是由写入者关闭通道，能最大程序地避免向已经关闭的通道
写数据而导致的panic
(2) 重复关闭的通道会导致panic



阻塞

(1) 向未初始化的通道写数据或读数据都会导致当前的goroutine的永久阻塞
(2) 向缓冲区已满的通道写入数据会导致goroutine阻塞
(3) 通道中没有数据，读取该通道会导致goroutine阻塞


非阻塞

(1) 读取已经关闭的通道不会引发阻塞，而是立即返回通道元素类型的零值，
可以使用comma,ok语法判断通道是否已经关闭

(2) 向有缓冲且没有满的通道读/写不会引发阻塞



5.1.4 WaitGroup

讲了goroutine和chan,一个用于并发，另一个用于通信。
没有缓冲的通道具有同步的功能，除此之外，sync包也提供了多个goroutine
同步的机制，主要是通过WaitGroup实现的。


主要数据结构和操作如下


type WaitGroup struct{
	// contains filtered or unexported files
}


//添加等待信号

func (wg *WaitGroup) Add(delta int)


//释放等待信号

func (wg *WaitGroup) Done()

//等待

func (wg *WaitGroup) Wait()


WaitGroup用来等待多个goroutine完成，main goroutine调用
Add设置需要等待goroutine的数目，每一个goroutine结束时调用Done,

Wait()被main用来等待所有的goroutine完成


使用sync.WaitGroup完成多个goroutine之间的协同工作

5.1.5 select 

select 是类UNIX系统提供的一个多路复用系统api,Go语言借用多路复用的概念

提供了select 关键字，用于多路监听多个通道。当监听的通道没有状态
是可读或可写的，select是阻塞的；只要监听的通道中有一个状态是可读或可写
的，则select 就不会阻塞，而是要进入处理就绪通道的分支流程。


如果监听的通道有多个可读或可写的状态，则select随机选取一个处理


5.1.6 扇入(Fan in )和扇出(Fan out)

编程中经常遇到"扇入和扇出"两个概念


扇入，是指多路通道聚合到一条通道中处理，Go语言最简单的扇入就是使用seleect
聚合多条通道服务

扇出：是指将一条通道发散到多条通道中处理，在Go语言里面具体实现就是使用
go关键字启动多个goroutine并发处理



扇入是合
扇出是分


当生产者的速度很慢时，需要使用扇入技术聚合多个生产者满足消费者，
比如很耗时的加密、解密服务；
当消费者的速度很慢时，需要使用扇出技术，比如web服务器并发请求处理
扇入和扇出是Go并发编程中常用的技术



5.1.7 通知退出机制




读取已经关闭的通道不会引起阻塞，也不会导致panic,
(2) 多个goroutine增强型生成器

(3) 有时希望生成器能够自动退出，可以借助Go通道的退出通知机制
(close channel to broadcast)实现


(4) 一个融合了并发，缓冲，退出通知等多重特性的生成器

5.2.2 管道 

通道可以分为两个方向，一个是读，一个是写。

假如一个函数的输入参数和输出参数都是相同的chan类型，则该函数可以调用
自己，最终形成一个调用链。

当然多个具有相同参数类型也能组成一个调用链。

这很像UNIX系统的管道，是一个有类型的管道



下面演示go程序这种程序处理能力

5.2.3 每个请求一个goroutine



这种并发模式相对比较简单，就是来一个请求或任务就启动一个goroutine
去处理，典型的就是Go中的HTTP server服务。


下面为golang语言的http标准库处理请求的方式


计算100个自然数的和来举例，将计算任务拆分为多个task,
每个task启动一个goroutine进行处理


程序逻辑

1.InitTask函数构建task并发送到task通道中
2. 分发任务函数DistributeTask为每个task启动一个goroutine处理
任务，等待其处理完成，然后关闭结果通道
3. ProcessResult函数读取并统计所有的结果


这几个函数分别在不同的goroutine中运行，它们通过通道和sync.WaitGroup
进行通信和同步

不固定goroutine工作池

5.2.4 固定worker工作池

服务器编程中使用最多的就是通过线程池来提升服务的并发处理能力。


在Go语言编程中，一样可以轻松地构建固定数目的goroutines作为工作线程池


下面以计算多个整数的和为例子，说明这种并发范式

程序中除了主要的main goroutine,还开启了如下几类goroutine:

(1) 初始化任务的goroutine
(2) 分发任务的goroutine
(3) 等待所有worker结束通知，然后关闭结构通道的goroutine



main函数负责拉起上述goroutine,并从结果通道获取最终的结果


程序采用三个通道，分别是：
(1) 传递task 任务的通道
(2) 传递task 结果的通道 
(3) 接收worker处理完任务后发送通知的通道


程序的逻辑

1. 构建task并发传送到task通道中
2. 分别启动n个工作线程，不停地从task通道中获取任务，然后将结果写入
结果通道。如果任务通道被关闭，则负责收敛结果的goroutine发送通知，
告诉其当前worker已经完成工作


3. 收敛结果的goroutine接收到所有task已经处理完毕的信号后，
主动关闭结果通道
4. main中的函数ProcessResult读取并统计所有的结果

5.2.5 future模式

编程中经常遇到在一个流程中需要调用多个子调用的情况，这些子调用相互之间
没有依赖，如果串行地调用，则耗时会很长，此时可以使用Go并发编程中的
future模式



future模式的基本工作原理：
1. 使用chan作为函数参数
2. 启动goroutine调用函数
3. 通过chan传入参数
4. 做其他的可以并行处理的事情
5. 通过chan异步获取结果



future最大的好处是将函数的同步调用转换为异步调用，适用于一个交易需要多个
子调用且这些子调用没有依赖的场景。实际情况可能比上面的示例更加复杂

要考虑错误和异常的处理，



future模式工作流程



5.3 context标准库


Go中的goroutine之前没有父与子的关系，也就是没有所谓子进程退出后的通知机制，
多个goroutine都是平行地被调度，多个goroutine如何协作工作涉及通信，
同步，通知和退出四个方面


通信：chan通道当然是goroutine之间通信的基础，注意这里的通信主要是
指程序的数据通道


同步：不带缓冲的chan提供了一个天然的同步等待机制；当然sync.WaitGroup
也为多个goroutine协同工作提供一种同步等待机制

通知：这个通知和上面通信的数据不一样，通知通常不是业务数据，而是管理，控制流
数据。要处理这个也好办，在输入端绑定两个chan,一个用于业务流数据，另一个用于
异常通知数据，然后通过select收敛进行池。这个方案可以解决简单的问题，
但不是一个通用的解决方案

退出：goroutine之间没有父子关系，如何通知goroutine退出？
可以通过增加一个单独的通道，借助通道和select的广播机制(close channel to 
broadcast) 实现退出


Go语言在语法上处理某个goroutine退出通知机制很简单。

实际编程中goroutine会拉起新的goroutine,新的goroutine又会来气另一个新的
goroutine，最终形成一个树状的结构，由于goroutine里并没有父子的概念，
这个树状的结果只是在程序员头脑中抽象出来的，
程序的执行模型并没有维护这么一个树状结构，怎么通知这个树状上的所有
goroutine退出？
仅依靠语法层面的支持显然比较难处理。

标准库context解决这个问题
它提供两种功能：退出通知和元数据传递


context库的设计目录就是跟踪goroutine调用，在其内部维护一个调用树，
并在这些调用树中传递通知和元数据

5.3.1 context的设计目的


context库的设计目录就是跟踪goroutine调用树，并在这些goroutine
调用树中传递通知和元数据。两个目的：


(1) 退出通知机制-通知可以传递给整个goroutine调用树上的每一个goroutine
(2) 传递数据-数据可以传递给整个goroutine调用树上的每一个goroutine

5.3.2 基本数据结构

先理解context包的整体工作机制：第一个创建Context的goroutine被称为root节点。root节点负责创建一个实现Context接口的具体对象，并将该对象作为参数
传递到其新拉起的goroutine,下游的goroutine可以继续封装该对象，再传递到
更下游的goroutine

Context对象在传递的过程中最终形成一个树状的数据结构，这样通过位于root结点
(树的根节点)的Context对象就能遍历整个Context对象树，通知和消息就可以通过
root结点传递出去，实现了上游goroutine对下游goroutine的消息传递


Context接口

Context是一个基本接口，所有的Context对象都要实现该接口，context的使用者
在调用接口中使用Context作为参数类型


type Context interface{
	//如果Context　实现了超时控制，则该方法返回ok true,deadline为超时实现
	// 否则 ok为false


	Deadline() (deadline time.Time,ok bool)

	// 后端被调的goroutine应该监听该方法的返回的chan,一便及时释放资源

	Done() <-chan struct{}

	//Done 返回的chan收到通知的时候，才可以访问Err()获知因为什么原因被取消
	Err() error

	//可以访问上游goroutine传递给下游goroutine的值

	Value (key interface{}) interface{}

}


canceler 接口


canceler 接口是一个扩展接口，规定了取消通知的Context具体类型需要实现的接口

context包中的具体类型*cancelCtx 和*timerCtx都实现了该接口

//一个context对象如果实现了canceler接口，则可以被取消


type canceler interface{
	//创建cancel接口实例的goroutine调用cancel方法通知后续创建的goroutine退出
	cancel(removeFromParent bool,err error)
	// Done方法返回的chan需要后端goroutine来监听，并及时退出
	Done() <-chan struct{}

}


13190191933
empty Context结构


emptyCtx 实现了Context接口，但不具备任何功能，因为其所有的方法都是空实现。
其存在的目的是作为Context对象树的根(root节点)
因为context包的使用思路就是不停地调用context包提供的包装函数来创建
具有特殊功能的Context实例，每一个Context实例的创建都以上一个Context对象
为参数，最终形成一个树状的结构


//emptyCtx实现了Context接口


type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time,ok bool){
	return
}


func (*emptyCtx) Done() <-chan struct{}{
	return nil
}



func (*emptyCtx) Err() error {
	return nil
}



func (*emptyCtx) Value(key interface{}) interface{}{
	return nil
}



package 定义了两个全局变量和两个封装函数，返回两个emptyCtx实例对象，实例
使用时通过调用这两个封装函数来构造Context的root节点


cancelCtx 是一个实现了Context接口的具体类型，同时实现了conceler接口


conceler具有退出通知方法。注意退出通知机制不但能通知自己，也能逐层通知其children节点


timerCtx 是一个实现了Context接口的具体类型，内部封装了cancelCtx类型实例，
同时有一个deadline变量，用来实现定时退出通知

valueCtx　是一个实现了Context接口的具体类型，内部封装了Context接口类型，
同时封装了一个k/v的存储变量。valueCtx可用来传递通知信息


5.3.3 API函数

下面这两个函数是构造Context取消树的根节点对昂，根节点对象用作后续With
包装函数的实参


func Background() Context
func TODO() Context



Ｗith 包装函数用来构建不同功能的Context具体对象
(1) 创建一个带有退出通知的Context具体对象，内部创建一个cancelCtx的类型实例
(2) 创建一个带有超时通知的Context具体对象，内部创建一个timerCtx的
类型实例。

(3) 创建一个带有超时通知的Context具体对象，内部创建一个timerCtx的类型实例，
(4) 创建一个能够传递数据的Context具体对象，内部创建一个valueCtx的类型实例



这些函数都有一个共同的特点－parent参数，其实这就是实现Context通知树的必备条件

在goroutine的调用链中，Context的实例被逐层地包装并传递，每层又可以对传进来
的Context实例再封装自己所需的功能，整个调用树需要一个数据结构来维护，
这个维护逻辑在这些包装函数内部实现


5.3.4 辅助函数


5.3.5 context的用法

context包的一般流程

(1) 创建一个Context根对象
(2) 包装上一步创建的Context对象，使其具有特定的功能
(3) 将上一步创建的对象作为实参传给后续启动的并发函数(通常作为函数的第一个函数)
每个并发函数内部可以继续使用包装函数对传进来的Context对象进行包装，
添加自己所需的功能
(4) 顶端的goroutine在超时后调用cancel退出通知函数，通知后端的所有goroutine
释放资源

(5) 后端的goroutine通过select监听Context.Done()返回的chan,及时响应前端
goroutine的退出通知，一般停止本次处理，释放所占用的资源


5.3.6 使用context传递数据的争议

要清楚使用context包主要是解决goroutine的通知退出，传递数据是其一个额外
功能。可以使用它传递一些元信息，总之使用context传递的信息不能影响
正常的业务流程，程序不要期待在context中传递一些必需的参数等

没有这些参数，程序也应该能正常工作


在context中传递数据的坏处


1. 传递的都是interface{}类型的值，编译器不能进行严格的类型校验
2. 从interface{}到具体类型需要使用类型断言和接口查询，有一定的
运行期开销和性能损失
3. 值在传递过程中有可能被后续的服务覆盖，且不易被发现
4. 传递信息不简明，比较晦涩；不能通过代码或文档一眼看到传递的是什么，
不利于后续维护

context 应该传递什么数据

1. 日志信息
２．　调试信息
３．　不影响业务主逻辑的可选数据


context包提供的核心的功能是多个goroutine之间的退出通知机制，传递数据
只是一个辅助功能，应谨慎使用context传递数据


5.4 并发模型

5.4.1 CSP


将并发系统抽象为Channel和Process两个部分，Channel用来传递消息，
Process用于执行，Channel和Process之间相互独立，没有从属关系，
消息的发送和接收有严格的时序限制。
Go语言主要借鉴了Channel和Process的概念，
在Go中Channel就是通道，Process就是goroutine


5.4.2 调度模型


(1) 尽可能让每个CPU核心都有事情做
(2) 尽可能提高每个CPU核心做事情的效率



多进程模型


进程都能被多核CPU并发调度，优点是每个进程都有自己独立的内存空间，
隔离性好，健壮性好；缺点是进程比较中，进程的切换消耗较大，
进程间的通信需要多次在内核区和用户区之间复制数据



多线程模型

这里的多线程是指启动多个内核线程进行处理，线程的有点是通过共享
内存进行通信更快捷，切换代价小；缺点是多个线程共享内存空间，
极易导致数据访问混乱，某个线程误操作内存挂掉可能
危机整个线程组，健壮性不高


用户级多线程模型


用户级多线程又分为两种情况：一种是M:1的方式，M个用户线程对应一个内核
进程，这种情况很容易是因为一个系统阻塞，其他用户线程都会被阻塞，
不能利用机器多核的优势。

还有一种模式就是M:N的方式，M个用户线程对应N个内核线程，这种模式
一般需要语言运行时或库的支持，效率最高



程序并发处理的要求越来越高，但是不能无限制地增加系统线程数，线程数过多会
导致操作系统的调度开销变大，单个线程的单位时间内被分配的运行时间减少，
单个线程的运行速度降低，单靠增加系统线程数不能满足要求。为了不让系统
线程无限膨胀，于是就有了协程的概念。

协程是一种用户态的轻量级线程，协程的调度完全由用户态程序控制，协程拥有
自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，
在切回来的时候，恢复先前保存的寄存器上下文和栈，每个内核线程可以对应
多个用户协程，当一个协程执行体阻塞了，调度器会调度另一个协程执行，
最大效率地利用操作系统分给系统线程的时间片。
前面提到的用户级线程模型就是一种协程模型，尤其以M:N模型最为高效



１．控制了系统线程数，保证每个线程的运行时间片充足
2. 调度层能进行用户态的切换，不会导致单个协程阻塞整个程序的情况，尽量
减少上下文切换，提升运行效率



协程是一种高效，理想的执行模型。Go的并发执行模型就是一种变种的协程模型



５．４．３　并发和调度


go余元在语言层面引入了goroutine

1. goroutine 可以在用户空间调度，避免了内核态和用户态的切换导致的成本
２．　goroutine是语言原生支持的，语法简洁，屏蔽了大部分复杂底层实现
３．　goroutine更小的栈空间允许用户创建成千上万的实例

goroutine调度模型。Go的调度模型抽象出三个实体：M P G

G(goroutine)


G是Go运行时对goroutine的抽象描述，G中存放并执行的代码入口地址，
上下文，运行环境(关联的P和M),运行栈等执行相关的元信息


G的新建，休眠，恢复，停止都受到Go运行时的管理。Go运行时的监控线程会监控
G的调度，G不会长久地阻塞系统线程，运行时的调度器会自动切换到其他Ｇ
上继续运行。G新建或恢复时会添加到运行队列，等待M取出并运行



Go启动初始化过程

１．　分配和检查栈空间
２．　初始化参数和环境变量
３．　当前运行线程标记为m0,m0是程序启动的主线程
４．　调用运行时初始化函数runtime.schedinit进行初始化

主要是初始化内存空间分配器，GC，生成空闲P列表

５．　在m0上调度第一个G,这个Ｇ运行runtime.main函数


runtime.main会拉起运行时的监控线程，然后调用main包的init()初始化函数，最后
执行main函数

在程序启动过程中会初始化空闲P列表，P是在这个时候被创建的，同时第一个G
也是在初始化过程中被创建的，后续的有go并发调度的地方都有可能
创建G,由于Ｇ只是一个数据结构，并不是执行实体，所以Ｇ是可以被复用的

在需要Ｇ结构时，首先要去P的空闲G列表里面寻找运行结束的goroutine,
其G会被缓存起来


每个并发调用都会初始化一个新的G任务，然后唤醒M执行任务，这个唤醒不是特定唤醒
某个线程去工作，而是先尝试获取当前线程M,如果无法获取，则从全局调度的
空闲M列表中获取可用的M,如果没有可用的，则新建M,然后绑定P和G进行运行。

所以M和P不是一一对应的，M是按需分配的，但是运行时会设置一个上限值(默认是10000)
超出最大值将导致程序崩溃


M线程里有管理调度和切换堆栈的逻辑，但是M必须拿到P后才能运行，可以看到M
是自驱动的，但是需要P的配合


抢占调度

抢占调度的原因

１．　不让某个G长久地被系统调用阻塞，阻碍其他G运行
２．不让某个Ｇ一直占用某个M不释放
３．　避免全局队列里面的G得不到执行

抢占调度的策略


１．　在进入系统调用(syscall)前后，各封装一层代码检测G的章台，当检测到当前的G
已经被监控线程抢占调度，则M停止执行当前G，进行调度切换

２．　监控线程经过一段时间检测感知到P运行超过一定时间，取消P和M的关联，这也是一种更高层次的调度


３．　监控线程经过一段时间检测感知到G一直运行，超过了一定的时间，设置G标记，
G执行栈扩展逻辑检测到抢占标记，根据相关条件决定是否抢占调度

Go程序运行时比较复杂的，涉及内存分配，垃圾回收，goroutine调度和通信
管理等诸多方面。整个运行时的初始化过程也很繁琐


第６章　反射

在计算机科学中，反射是指计算机程序在运行时(Run time)可以访问，检测和修改
本身状态或行为的一种能力。

反射就是程序能够在运行时动态地查看自己的状态，并且允许修改自身的行为

p200

	
