
李文塔


go语言的三大特性：类型系统，接口和并发

go语言编程类型的图书类型

１．基础全面型

２．源码深入型

３．　专业领域型


第１章　基础知识

每种语言都有其独特的应用领域：
在嵌入式领域，汇编和c是首选
在操作系统领域，c是首选
在系统级服务器编程领域，c++是首选
在企业级应用程序和web应用领域，java是


１．１．１　go的诞生北京

(1) 摩尔定律接近失效后多核服务器已经成为主流，当前的编程语言对并发的支持不是很好，
不能很好地发挥多核CPU的威力。
(2) 程序越大，编译速度越慢
(3) 语言越来越复杂

并发，编译速度，编程复杂度

1.1.2 语言特性

语言组织
所有的高级语言都使用源代码来表达程序，主要包括


１．标识符和关键字
２．变量和常量
３．　运算符
４．表达式
５．　简单语句
６．　控制结构


类型系统

１．动静特性：动态语言还是静态语言
２．　类型强弱：强类型还是弱类型
３．　基本数据类型：包括类型及其支持的运算和操作集合
４．　自定义数据类型：包括类型及其支持的运算和操作集合

抽象特性

１．函数：是否支持函数，匿名函数，高阶函数，闭包等
２．　面向对象：是否支持面向对象
３．多态：如何支持多态
４．接口：是否支持接口，以及接口实现模式

元编程特性

１．泛型：是否支持泛型
２．　反射：是否支持反射，反射的能力

运行和跨平台语言特性

１．编译模式：是编译可执行程序，还是编译成中间代码，还是解释器解释执行
２．　运行模式：直接由OS加载运行，还是由虚拟机加载执行
３．　内存管理：是否支持垃圾回收
４．　并发支持：是否原生支持并发，还是库支持
５．交叉编译：是否支持交叉编译
６．　跨平台支持：是否支持多个皮糖

语言软实力特性
１．库：标准库和第三方库是否丰富，好用，高效
２．　框架：是否有出众的框架
３．语言自身兼容性：语言规范是否
４．语言的他影响力

go

支持顺序，循环，分支，静态语言，支持运行时动态类型
强类型，支持隐式类型推导，类型安全，支持type自定义
支持函数，类型组合支持面向对象，接口
Duck模型，通过接口支持

没有泛型支持，有反射支持
编译成可执行程序

直接运行，支持自动垃圾回收
协程(语言原生支持)，支持交叉编译，支持跨平台

应用领域：
云计算基础设施软件，中间件，区块链


将新知识与已经掌握的旧知识进行对比，
将新知识链接到旧知识里面，最终形成一个知识体系。

技能就是把已经掌握的抽象成解决问题的认知模型，这些
认知模型能够直到摸解决某个领域和相似领域的问题

main是可执行程序的包名，所有的go源程序文件头部必须有一个
包声明语句，go通过包来管理命名空间

import 引用一个头部包fmt,可以是标准库的包，也可以是第三方或自定义的
包，fmt是标准输入/输出包

func关键字声明定义一个函数，函数名为main,main代表go程序入口函数

fmt包里面的Printf函数，函数实参是一个字符串字面量，在标准输出
\n是一个转义符，表示换行

go源代码的特征

１．源程序以.go为后缀
2. 源程序默认为UTF-8编码
3. 标识符区分大小写
4. 语句结尾的分号可以省略
5. 函数以func开头，函数体开头的"{"　必须在函数头所在行尾部，不能单独起一行
６、　字符串字面量使用""""(双引号)括起来
7. 调用表里面的方法通过点"."访问符，比如示例中的fmt.Printf
8. main函数所在的包名必须是main


go build hello.go
./hello

1.3 go词法单元


现代高级语言的源程序内部的几个概念：
１．token
2.关键字
3. 标识符
4. 操作符
5. 分隔符
6. 字面量

1.3.1 token

token是构成源程序的基本不可再分割的单元。
编译器编译源程序的第一步就是将源程序分割为一个个独立的
token,这个过程就是词法分析。

go语言的token可以分为关键字，标识符，操作符，分隔符和字面量等


go的toke分隔符有两类：
１．操作符
２．自身没有特殊函数，仅用来分隔其他token,被称为纯分隔符


操作符：操作符就是一个天然的分隔符，同时其自身也是一个token,

sum := a+b

纯分隔符：其本身不具备任何语法含义，只作为其他token的分割
功能。博爱看空格，制表符，换行符和回车符，多个相邻的空格或
制表符会被编译器看作分隔符处理，比如 package main

这是一个包声明的语句，pakcage和main之间可以有任意多个
空格或制表符，go编译器会将其作为一个分隔符处理，最后
分离出来两个token:package 和main



1.3.2 标识符

go语言预声明的标识符包括关键字，内置数据类型标识符，常量值
标识符，内置函数和空白标识符。在写go源程序的过程中，
用户自定义标识符用在包名，函数名，自定义类型名，变量名和
常量名等


关键字

break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var


１．引导程序整体结构的８个关键字


package //定义包名的关键字
import //导入包名关键字
const //　常量声明关键字
var //变量声明关键字
func //函数定义关键字
defer //延迟执行关键字
go // 并发语法糖关键字
return //函数返回关键字

2. 声明符合数据结构的４个关键字

struct //定义结构类型关键字
interface //定义接口类型类型关键字
map  //声明或创建map类型关键字
chan //声明或创建通道类型关键字

3. 控制程序结构的１３个关键字

if else // if else语句关键字
for range break continue //for循环使用的关键字
switch select type case default fallthrough // switch和select 语句使用的关键字

goto //goto跳转语句关键字

内置数据类型标识符(20个)

丰富的内置类型支持是高级语言的基本特性，基本类型也是构造用户自定义类型的基础。
为了标识符每种内置数据类型，go定义了一套预声明标识符，这些标识符用在变量或常量声明时，

内置数据类型标识符(20个)

数值(16个)
	整型(12个)
		byte int int8 int16 int32 int64
		uint uint8 uint16 uint32 uint64 uintptr
	浮点型(2个)
		float32 float64

	复数型(2个)
		complex64 complex128


字符和字符串型(2个)
string rune
接口型(1)
error


go是一种强类型静态编译型语言，在定义变量和常量时需要显式地指出数据类型，
go也支持自动类型推导，在声明初始化内置类型变量时，go可以自动地进行类型推导。
在定义新类型或函数时，必须显式地带上乐行标识符。

内置函数 １５个

make new len cap append copy delete panic recover close
complex real image Print Println


内置函数也是高级语言的一种语法糖，由于其是语言内置的，不需要用import 引入，内置函数
具有全局可见性。注意到其都是以小写字母开头的，但是并不影响其全局可用性。

常量值标识符(4个)
true false // true和false表示bool　类型的两常量值：真和假
iota  //用在连续的枚举的声明中
nil // 指针/引用型的变量的默认值就是nil


go的常量值标识代表的是一个常量值，这个常量值表达特殊的汉所以，
不好使用产量字面量直接表达时，就使用一个预先声明的标识符代替


空白标识符(1个)



空白标识符有特殊的汉所以，用来声明一个匿名的变量，该变量在赋值表达式的左端，空白标识符引用通常被用作
占位，比如忽略函数多个返回值中的一个和强制编译器做类型检查

１.3.3 操作符和分隔符


操作符就是语言所使用的符合集合，包括运算符，显式的分隔符，
纯粹的分隔符有４个：　空格，制表符，回车和换行


算术运算符(5个)
+ - * / %

位运算符(6个)
& | ^ &^ >> <<

赋值和赋值复核运算符(13个)

 :=  = += -= *=   &= |= ^= &^= >>= <<=

比较运算符(6个)

> >= < <= == !=


括号(6个)
() {} []

逻辑运算符(3个)

&& || !


自增自减操作符(2个)

++ --

注意，golang中自增，自减操作符是语句不是表达式

其他运算符(6个)

: , ; . ... <-


1.3.4 字面常量

编程语言源程序中表示固定值的符号叫做字面常量，简称字面量。

字面量可以被编程语言编译器直接转换为某个类型的值。
go的字面量可以出现在两个地方：
一是，用于常量和变量的初始化，而是用于在表达式里或作为函数调用实参。
变量初始化语句汇总如果没有显式地指定变量类型，则go编译器会结合字面量的值自动
进行类型推断。go中的字面量只能表达基本类型的值，go不支持用户定义的字面量


字面量有如下几类


１．整型字面量(Integer literals)
43
2.浮点型字面量
2.3

3. 复数类型字面量

4. 字符型字面量

go的源码采用的是UTF-8的编码方式，UTF-8的字符占用的字节数可以有1~4个字节，
Rune字符常量也有很多表现形式，但是使用" '' "(单引号)将其括住


'a'
'本'
'\t'
５．　字符串字面量

字符串字面量的基本表现形式就是使用" "" "(双引号)，将字符序列包括在内，双引号里面可以是
UTF-8的字符字面量，也可以是其编码值

"\n"
"\""
"Hello,world! \n"
"中国人"

go的源程序基本构成：
１．关键字引起程序的基本结构
２．内置类型标识符辅助声明变量和常量
3. 字面量辅助变量和常量的初始化
4. 分隔符帮助go编译器识别各个token
5. 操作符和变量，关键字一起构成丰富的语法单元


1.4 变量和常量

高级语言通过一个标识符来绑定一块特定的内存，后续对特定的内存的操作都可以使用该标识符来代替。

这种绑定某个存储单元的标识符又可以分为两类：
一类是变量，一类是常量

变量表示指向的内存可以被修改，常量表示指向的内存不能被修改

1.4.1 变量
变量：使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时指定的类型决定，
该内存地址里面存放的内容可以改变
go的基本类型变量声明有两种：
１．　显式的完整声明

var varName dataType [ = value]
go的变量声明后就会立即为其分配空间

var a int=1

2. 短类型声明

varName := value

:= 声明只能出现在函数内(包括在方法内)
此时go编译器自动进行数据类型推断
go支持多个类型同时声明并赋值

a,b := 1,"hello"



变量具有如下几个睡醒
１．变量名
２．　变量值

变量实际指向的是地址里存放的值，变量的值具体怎么解析是由变量的类型来决定的。
在初始化变量值时，可以使用字面量，也可以使用其他的变量名

3. 变量存储和生存期

go语言提供自动内存管理，通常程序员不需要特别关注变量的生存期和存放位置。编译器使用
栈逃逸技术能够自动为变量分配空间：可能在栈上，也可能在堆上

4. 类型信息

类型决定了该变量存储的值怎么解析，以及支持哪些操作和运算，不同类型的变量支持
的操作和运算集是不一样的

５．　可见型和作用域

go内部使用统一的命名空间对变量进行管理，每个变量都有一个唯一的名字，
包名是这个名字的前缀


1.4.2 常量

常量使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义常量时指定
的类型决定，而且该内存地址里面存放的内容不可以改变。
go中常量分为布尔型，字符串型和数值型常量。常量存储在程序的只读段里
预声明标识符iota用在常量声明中，其初始值为0.一组多个常量同时声明时其值逐行增加，
iota可以看作自增的枚举变量，专门用来初始化常量

1.5 基本数据类型
go是一种强类型的静态编译语言，类型是高级语言的基础，有了类型，高级语言才能对不同类型抽象
出不同的运算，

go内置七类基本数据类型(20个具体子类型)

布尔类型:bool
整型：byte int int
浮点型:float32 float64
复数
字符:rune
字符串：string
错误类型：error

1.5.1 布尔类型

var ok bool
ok = true

ok := false

布尔类型数据和整型数据不能进行相互转换

var a bool
a = 1
比较表达式和逻辑表达式的结果都是布尔类型数据

var b bool = (x>y) && (x>0)

if和for语句的条件部分一定是布尔类型的值或表达式

if a<= b{


for;tune ;{}

声明的布尔型变量如不指定初始化值，则默认为false
var b bool 


1.5.2  z整型


var a int =1
var b int32 =2
b =a

整型支持算术运算和位运算，算术表达式和位操作表达式的结果还是整型

1.5.3 浮点型


(1) 浮点数字面量被自动类型推断为float64类型

var b :=10.00
(2) 计算机很难进行浮点数的精确表示和存储，因此两个浮点数之间不应该使用== 或!= 进行比较操作，
高精度科学计算应该使用math标准库

１．５．４　复数类型


1.5.5 字符串

go语言将字符串作为一种原生的基本数据类型，字符串的初始化可以使用字符串字面量

var a = "hello,world"

(1) 字符串是常量，可以通过类似数组的索引访问其字节单元，但是不能修改某个字节的值

var a = "hello world"
	b:= a[0]
	
(2) 字符串转换为切片[]byte(s)要慎用，尤其是当数据量较大时(每转换一次都需要复制内容)
(3) 字符串尾部不包含NULL字符
(4)　字符串类型底层实现是一个二元的数据结构，一个是指针指向字节数组的起点，
另一个是长度

(5) 基于字符串创建的切片和原字符串指向相同的底层字符数组，一样不能修改，对字符串的切片操作返回的子串让然是string,而非slice
a := "hello"

(6) 字符串和切片的转换：字符串可以转换为字节数组，也可以转换为Unicode的字数组

b := []byte(a)
c := []rune(a)

(7) 字符串的运算


1.5.6 rune类型

go内置两种字符类型：一种是byte的字节类类型(byte是uint的别名)
另一种是表示Unicode编码的字符rune.
rune　在go内部是int32类型的别名，占用4个字节。
go语言默认的字符编码是UTF-8类型的，如果需要特殊的编码转换，则使用Unicode/UTF-8标准包


１．６　复合数据类型

指针，数组，切片，字典(map)，通道，结构体和接口

*pointerType // 指针类型使用*后面跟其指向的类型名
[n] elementType //数组类型使用[n]后面跟数组元素类型表示,n表示该数组的长度
[] elementType //切片类型使用[] 后面跟切片元素类型表示
map [keyType] valueType //map 类型使用map[键类型]值类型来表示
chan valueType //通道使用chan后面跟通道元素类型来表示

struct{
	feildType feildType
}  // 结构体类型使用struct{}将各个结构字段括起来表示

interface{ // 接口类型使用interface{}将各个方法括起来表示
	method1(inputParams)(returnParams)
}


1.6.1 指针



go语言支持指针，指针的声明类型为*T,go同样支持多级指针**T
通过在变量名前加&来获取变量的地址

(1) 指针赋值
*T = ,表示指针声明
=*T,表示取指针指向的值

var a =1
p := &a

(2) 结构体指针访问结构体字段仍然使用.操作
type User struct{
	name string
	age int
}

andes := User{
	name:"andes",
	age :18,
}
p := &andes
fmt.Println(p.name) // p.name 通过.操作符访问成员变量

(3) go不支持指针的运算

(4) 函数中允许返回局部变量的地址

go编译器使用"栈逃逸"机制将这种局部变量的空间分配在堆上。

func sum(a,b int) *int{
	sum := a+b
	return &sum //允许，sum会分配在heap上
}


1.6.2 数组

数组的类型名是[n]elementType,其中n是数组长度，elementType是数组元素类型。比如一个包含2个int类型元素
的数组类型可表示为[2]int.
数组一般在创建时通过字母量初始化，单独声明一个数组类型变量而不进行初始化是没有意义的

var arr [2]int //声明一个有两个整型的数组，但元素默认值都是0,一般很少使用

array := [...]float64{7.0,8.5,9.1} // [...]后面跟字面量初始化列表

数组初始化

a := [3]int{1,2,3} //指定长度和初始化字面量
a := [...]int{1,2,3} // 不指定长度，但是由后面的初始化列表数量来确定其长度
a := [3]int{1:1,2:3} //　指定总长度，并通过索引值进行初始化，没有初始化元素时使用类型默认值

a := [...]int{1:1,2:3} //不指定总长度，通过索引值进行初始化，数组长度由最后一个索引值确定，没有
		指定索引的元素被初始化为类型的零值


数组的特定啊
(1) 数组创建万长度就固定了，不可以再追加元素
(2) 数组是值类型的，数组赋值或作为函数参数都是值拷贝
(3) 数组长度是数组类型的组成部分，[10]int和[20]int表示不同的类型
(4) 可以根据数组创建切片


数组相关操作

(1) 数组元素访问

a := [...]int{1,2,3}

b := a[0]
for i,v := range a{}

(2) 数组长度

a := [...]int{1,2,3}
alengh := len(a)
for i:=0 ; i<alengh;i++{
	}

1.6.3 切片

go语言的数组的定长性和值拷贝限制了其使用场景，go提供了
另一种数据类型slice(中文为切片)
这是一种变长数组，其数据饥饿哦股中有指向数组的指针，所以
也是一种引用类型

type slice struct{
array unsafe.Pointer
len int
cap int
}

go为切片维护三个元素---指向底层数组的指针，切片的元素数量和
底层数组的容量

(1) 切片的创建

由数组创建

创建语法：array[b:e]
array表示数组名;b表示开始索引，可以不指定，默认是0;
e表示结束索引，可以不指定，
默认是len(array)
array[b:e]表示创建一个包含e-b个元素的切片，
第一个元素是array[b],最后一个元素是array[e-1]



通过内置函数make创建切片

注意：由make创建的切片各元素被默认初始化为切片元素类型的零值


// len =10,cap =10

a := make([]int,10)

// len = 10,cap =15

这里要注意:直接声明切片类西藏变量是没有意义的

此时切片a的底层的数据结构如图

(2) 切片支持的操作

内置函数len()返回切片长度
内置函数cap()返回切片底层数组容量
内置函数append()对切片追加元素
内置函数copy()用于复制一个切片

(3) 字符串和切片的相关转化

1.6.4 map

go语言内置的字典类型为map


map[K]T
K可以是任意可以进行比较的类型，T是值类型。map也是一种引用类型

(1) map的黄建
使用字面量创建


使用内置的make函数创建

make(map[K]T) // map的容量使用默认值
make(map[K],len) // map的容量使用给定的len值

(2) map支持的操作

1. map的单个键值对访问格mapName[key]，更新某个key的值时mapName[key]
放到等号左边，访问某个key的值时mapName[key]放在等号的右边

2. 可以使用range遍历一个map类似变量，但是不保证每次迭代元素的顺序

3. 删除map中的某个键值，使用如下语法:delete(mapName,key)
delete是内置函数，用来删除map中的某个键值对

4. 可以使用内置的len()函数返回map中的键值对数量


注意

go内置的map不是并发安全的，并发安全的map可以使用标准包sync中的map


不要直接修改map value内某个元素的值，如果向修改map的某个键值，则必须
整体赋值


1.6.5 struct


go中的struct类型和C类似， 也称为结构体，由多个不同类型元素组合而成。
这里有两层：
1. struct结构中的类型可以是任意类型
2. struct的存储空间是连续的，
其字段按照声明时的顺序存放(注意字段之间有对齐要求)


struct有两种形式：一种是struct类型字面量，另一种
是使用type声明的自定义struct类型

(1) struct类型字面量

struct类型字面量的声明格式如下


struct {
	FeildName FeildType
}


(2) 自定义struct类型。自定义struct类型声明格式如下：

type  TypeName struct{
	FeildName FeildType}


实际使用struct字面量的场景不多，更多的时候是通过type自定义一个
新的类型来实现的。
type 是自定义类型的关键字，不但支持struct类型的创建，
还支持任意其他子定义类型的创建。


(3) struct类型变量的初始化

type Person struct{
	Name string
	Age int
}


type Student struct{
	*Person
	Number int
}


//按照类型声明顺序，逐个赋值
// 不推荐这种初始化方式，一旦struct增加字段，则整个初始化语句会报错


a := Person{"Tom",31}




//推荐这种使用Feild名字的初始化方式，没有指定的字段则默认初始化为类型的零值

p := &Person{
	Name:"tata",
	Age:12,
}


s := Student {
	Person:p,
	Number:110,
}


其他复合类型

接口(Interface),通道(chan)


1.7 控制接口


程序指令都是线性地存放在存储器上。

程序执行从本质上来说就是两种模式：顺序和跳转



顺序就是按照程序指令在存储器上的存放顺序逐条执行
跳转就是遇到跳转指令就跳转到某处继续线性执行

go是一门高级语言，起源程序虽然经过了高度的抽象并封装了很多语法糖，但
还是跳不出这个模式(暂时不考虑goroutine引入并发后的执行视图变化)

顺序在Go里面体现在从main函数开始逐条向下执行，就像我们的程序源代码
顺序一样：跳转在Go里面体现为多个语法糖，包括goto语句和函数调用，
分支(if,switch,select)，循环(for)
跳转分为两种：一种是无条件跳转，比如函数调用和goto语句：一种是有条件的
跳转，比如分支和循环

顺序语句很简单，就是我们天然写程序的从前往后的顺序



go的源代码的熟悉并不一定是编译后最终可执行的程序的指令顺序

1.7.1 if语句

特点

1. if后面的条件判断子句不需要用小括号括起来
2. {必须放在行尾，和if或if else放在一行
3. if后面可以带一个简单的初始化语句，并以分号分割，该简单语句
声明的变量的作用域是整个if语句块，包括后面的else if和else分支

4. Go语言没有条件运算符(a>b?a:b),这也符合Go的设计哲学，
只提供一种方法做事情

5. if分支语句遇到return后直接返回，遇到break则跳过break下方
的if语句块

if x<= y{
	return y
}else{
	return x
}

一个完整的if else的语句示例


if x := f(); x< y{ //初始化语句中的声明变量x
	return x
} else if x> z{ //x在else if里面一样可以被访问
	return z
}else{
	return y
}


最佳实践

1.尽量减少条件语句的复杂度，如果条件语句太多，太复杂，则建议放到函数里面
封装起来
2. 尽量减少if语句的嵌套层次，通过重构让代码变得扁平，便于阅读


if err,file := os.Open("xxxx"); err == nil{
	defer file.Close()
	//do something
	}else{
		return nil,err
}

修改后的代码

err,file := os.Open("xxx")
if err != nil{
	return nil,err
}
defer file.Close()
//do something


17.2 switch语句


switch语句会根据传入的参数检测并执行符合条件的分支

switch的语法特点：


1.7.3 for语句
return 和函数调动

return语句也能引发控制流程的跳转，用于函数和方法的退出。

函数和方法的调用也能引发程序控制流的跳转，

第2章 函数

函数是程序执行的一个基本语法结构，go语言的
很多特性是基于函数这个基础实现的
命名类型的方法本质上是一个函数，类型方法是go面向
对象的实现基础
接口，其底层同样是指针和函数将接口和接口实例连接起来的
甚至go并发语法糖go也是函数

1. 函数是一种类型，函数类型变量可以像其他类型变量一样使用
可以作为其他函数的参数或返回值，也可以直接调用执行
２．　函数支持多值返回。
３．　支持闭包
４．　函数支持可变参数

2.1 基本概念

２．１．１　函数定义

函数是go程序源代码的基本构造单位，一个函数包括如下几个部分
函数声明关键字func,
函数名
参数列表
返回列表
函数体

func funcName(param-list)(result-list){
	function-body
}


函数的特点

(1) 函数可以没有输入参数，也可以没有返回值(默认返回0)

func A(){
	//do something
}

func A()int{
	//do something
	return1
}

(2) 多个相邻的相同类型的参数可以使用简写模式


func add(a,b int) int{
	// a int,b int 可以简写为 a,b int
	return a+b
}
(3) 支持有名的返回值，参数名就相当于函数体内最外层的局部变量
命名返回值变量会被初始化为类型零值，最后的return可以
不带参数名直接返回


// sum　相当于函数内局部变量，被初始化为领

func add(a,b int) (sum int){
	sum = a+b
	return // return sum的简写模式
	// sum := a+b
	//如果是sum := a+b,则相当于新声明一个sum	
	// 变量命名返回变量sum覆盖
	//return sum // 最后需要显式地调用return sum

(4) 不支持默认值参数
(5) 不支持函数重载
(6) 不支持函数嵌套，严格地说是不支持函数的嵌套定义，
但支持嵌套匿名函数

func add(a,b int)(sum int){
	anonymous := func(x,y int)int{
		return x+y
}
	return anonymous(a,b)


2.1.2  多值返回
go函数支持多值返回，定义多值返回的返回参数列表时要使用"()"包裹，
支持命名参数的返回


func swap(a,b int)(int,int){
	return b,a
}

习惯用法：

１．如果多值返回值有错误类型，则一般将错误类型作为最后一个返回值
２．　有关多值返回的内部实现原理


2.1.3 实参到形参的传递

go函数实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，那是
因为参数传递的是指针值的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本

二者指向同一地址，本质上参数传递仍然是值拷贝

2.1.4 不定参数

Go函数支持不定数目的形式参数，不定参数声明使用param...type的语法格式

函数的不定参数有如下特点：

（１）　所有的不定从桉树类型必须是相同的
（２）　不定参数必须是函数的最后一个参数
（３）　不定参数名在函数体内相当于切片，对切片的操作同样适合对不定
参数的操作

func sum(arr...int)(sum int){
	for _,v := range arr{ // 此时arr就相当于切片，可以使用range访问
	sum += v
	}
	return
}


(4) 切片可以作为参数传递给不定参数，切片名后要加上"..."

func sum(arr ...int)(sum int){
	for _,v := range arr{
		sum += v
	}
	return 
}


func main(){
	slice := []int{1,2,3,4}
	array := [...]int{1,2,3,4}

	//数组不可以作为实参传递给不定参数的函数

	sum(slice...)
}

(5) 形参为不定参数的函数和形参为切片的函数类型不相同。

func suma(arr ...int)(sum int){
	for v := range arr {
		sum += v
		}
	return
}


func sumb(arr []int)(sum int){
	for v:= range arr{
		sum +=v
	}
	return 
}


// suma 和sumb的类型并不一样

fmt.Printf("%T \n",suma) // func(...int) int
fmt.Printf("%T \n",sumb) // func([]int) int

2.2 函数签名和匿名函数


２．２．１　　函数签名

函数类型又叫函数签名，一个函数的类型就是函数定义首行去掉函数名，参数名和{
，可以使用fmt.Printf的"%T"格式化参数打印函数的类型

两个函数类型相同的条件是，拥有相同的形参列表和返回值列表(列表元素的次序，个数
和类型都相同)，形参名可以不同

func add(a,b int) int {return a+b}

func sub(x int,y int)(c int) {c=x-y;return c}


可以使用type定义函数类型，函数类型变量可以作为函数的参数或返回值

函数类型和map,slice,chan一样，实际函数类型变量和函数名都可以
当做指针变量，该指针指向函数代码的开始位置。
通常说函数类型变量是一种引用类型，未初始化的函数类型的
变量的默认值是nil


Go中函数是"第一公民"(first class)
有名函数的函数名可以看作函数类型的常量，可以直接使用函数名调用函数，也可以
直接赋值给函数类型变量，后续通过该变量来调用该函数

package main

func sum(a,b int) int{
	return a+b
}

func main(){
	sum(3,4) //直接调用
	f := sum // 有名函数可以直接赋值给变量
	f(1,2)
}

2.2.2 匿名函数


GO提供两种函数：有名函数和匿名函数。匿名函数可以看作函数字面量，所有直接使用
函数类型变量的地方都可以由匿名函数代替。
匿名函数可以直接赋值给函数变量，当做实参，也可以作为返回值，还可以直接被调用

2.6 defer

Go函数里提供了defer关键字，可以注册多个延迟调用，这些调用以先进后出(FILO)
的顺序在函数返回前被执行。这有点类似与Java语言中异常处理的finanly子句。
defer常用于保证一些资源最终一定能够得到回收和释放


defer后面必须是函数或方法的调用，不能是语句，否则会报expression　in defer
must be function call错误

defer函数的实参在注册时通过值拷贝传递进去。下面的代码，
实参a的值在defer注册时通过值通过值拷贝传递金融区，后续
a++并不会影响defer语句最后的输出结果

func f() int{
	a := 0
	defer func(i int){
		println("defer i=",i)
	}(a)

	a++
	return a
}

//defer 打印结果
defer i=0
defer 语句必须先注册后才能执行，如果defer位于return之后，则defer因为
没有注册，不会执行

主动调用os.Exit(int)退出进程时，defer将不再被执行(即使defer
已经提前注册)

defer的好处是可以在一定程度上避免资源泄露，特别是在很多return语句，有多个资源需要关闭
的场景中，很容易漏掉资源的关闭操作

func CopyFile(dst,src string)(w int64,err error){
	src,err := os.Open(src)
	if err != nil {
		return
	}
	dst, err := os.Create(dst)
	if err != nil{
		//src 很容易被忘记关闭
		src.Close()
		return
	}
	w. err = io.Copy(dst,src)
	dst.Close()
	src.Close()
	return
}


使用defer改写后，在打开资源无报错后直接调用defer关闭资源，一旦
养成这样的编程习惯，很难会忘记资源的释放


func CopyFile(dst,src string)(w int64,err error){
	src,err := os.Open(src)
	if err != nil{
		return
	}
	defer src.Close()

	dst, err := os.Create(dst)
	if err != nil{
		return	
	}
	defer dst.Close()

	w,err = io.Copy(dst,src)
	return
}


defer语句额位置不当，有可能导致panic,一般defer语句放在错误检查语句之后，
defer有明显的副作用：defer会推迟资源的释放，defer尽量不要放到循环语句里面，
将大函数内部的defer语句单独拆分成一个小函数是一种好的策略

另外，defer相对于普通的函数调用需要间接的数据结构的支持，
相对于普通函数调用有一定的性能损耗


defer中最好不要对有名返回值参数进行操作，否则报错


２．４　闭包

２．４．１　概念

闭包是由函数及其相关引用环境组合而成的实体，一般通过在匿名函数中引用
外部函数的局部变量或包全局变量构成

闭包＝函数＋引用环境变量

闭包对闭包外的环境引入是直接引用，编译器检测到闭包，会将闭包引用的外部变量分配到堆上


如果函数返回的闭包引用咧该函数的局部变量(参数或函数内部变量)


(1) 多次调用该函数，返回的多个闭包所引用的外部变量是多个副本，原因是每次调用
函数都会局部变量分配内存。
(2) 用一个闭包函数多次，如果该闭包修改了其引用的外部变量，则每一次调用该
闭包对该外部变量都有影响，因为闭包函数共享外部引用

f和g引用的是不同的a

如果一个函数调用返回的闭包引用了全局变量，则每次调用都会影响到全局变量


如果函数返回的闭包引用的是全局变量a,则多次调用该函数返回的多个闭包引用的都是同一个
a.同理，调用一个闭包多次引用的也是同一个a.
此时如果闭包中修改了a值的逻辑，则每次闭包调用都会影响全局变量a的值。
使用闭包是为了减少全局变量，所以闭包引用全局变量不是好的编程方式


同一个函数返回的多个闭包共享该函数的局部变量


2.4.2 闭包的价值


闭包最初的目的是减少全局变量，在函数调用的过程中隐式地传递共享变量，
有其有用的一面：但是这种隐秘的共享变量的方式带来的坏处是不够直接，
不够清晰，除非是非常有价值的地方，一般不建议使用闭包


对象是附有行为的数据，而闭包是附有数据的行为，类在定义时已经显式地集中
定义了行为，但是闭包中的数据没有显式地集中声明的地方，
这种数据和行为耦合的模型不是一种推荐的编程模型，闭包仅仅
是锦上添花的东西，不是不可缺少的


2.5 panic和recover


这两个内置函数用来处理go的运行时错误(runtime errors)
panic用来主动抛出错误，
recover用来捕获panic抛出的错误

２．５．	　基本概念

panic(i interface{})
recover() interface{}


引发panic有两种情况，一种是程序主动调用panic函数，另一种是程序产生运行的错误
由运行时检测并抛出

发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层
向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获
或运行到最外层函数而退出

panic的参数是一个空接口类型interface{}，所以任意类型的变量都可以传递给panic(空即可欧)

调用panic的方法非常简单：panic(xxx)


panic不但可以在函数正常流程中抛出，在defer逻辑里也可以再次调用panic或
抛出panic

defer里面的panic能够被后续执行的defer捕获

recover()用来捕获panic,阻止panic继续向上传递。recover()和defer
一起使用，但是recover()只有在defer后面的函数体内被直接调用
才能捕获panic终止异常，否则返回nil,
异常继续向外传递

defer func(){
	println("defer inner")
	recover()
}()


func except(){
	recover()
}


func test(){
	defer except()
	panic("test panic")
}


可以有连续多个panic被抛出，连续多个panic的场景只能出现在的延迟调用
里面，否则不会出现多个panic被抛出的场景，但只有最后一次panic能被捕获


包中init函数引发的panic只能在init函数中捕获，在main中无法被捕获，
原因是init函数先于main执行，函数并不能捕获内部新启动的goroutine所抛出的panic



2.5.2 使用场景

什么情况下主动调用panic函数抛出panic?

一般有两种情况：
(1) 程序遇到了无法正常执行下去的错误，主动调动panic函数
结束程序运行
(2) 在调试程序时，通过主动调用panic实现快速退出，panic
打印出堆栈能够更快地定位错误

为了保证程序的健壮性，需要主动在程序的分支流程上使用recover()拦截
运行时错误

Go提供了两种处理错误的方式，一种是借助panic和recover的抛出
捕获机制，另一种是使用error错误类型。

2.6 错误处理

2.6.1 error

Go语言内置错误接口类型error.任何类型只要实现Error() string方法，
都可以传递error接口类型变量。Go语言典型的错误处理方式是将
error作为函数最后一个返回值。
在调用函数时，通过检测其返回的error值是否为nil来进行错误处理


type error　interface{
	Error() string
}

Go 语言标准库提供的两个函数返回实现了error接口的具体类型实例，
一般的错误可以使用这两个函数进行封装。遇到复杂的错误，用户也可以
自定义错误类型，只要其实现error接口接口

错误处理的最佳实践


１．　在多个返回值的函数中，error通常作为函数最后一个返回值

２．　如果一个函数返回error类型变量，则先用if语句处理error!=nil
的异常场景，正常逻辑放到if语句块的后面，保持代码平坦
3. defer语句应该放到err判断的后面，不然有可能产生panic
4. 在错误逐级向上传递的过程汇总，错误信息应该不断地丰富和完善，
而不是简单地抛出下层调用的错误，这在错误日志分析时非常有用和友好


2.6.2 错误和异常


异常和错误在现代编程语言中

错误(errors)
未捕获错误－异常(untrapped error)
可捕获错误(trapped error)
compile errors
runtime errors
logic errors

Go是一门类型安全的语言，其运行时不会出现这种编译器和运行时
都无法捕获的错误，不会出现untrapped error,
Go语言不存在所谓的异常，出现的"异常"全是错误

Go程序需要处理的这些错误可以分为两类：

一类是运行时错误(runtime errors),此类错误语言的运行时能够捕获，
并采取错误－－隐式或显式地抛出panic

一类是程序逻辑错误：程序执行错误不符合预期，但不会引发运行时错误


Go对于错误提供了两种处理机制：
（１）　通过函数返回错误类型的值来处理错误
(2) 通过panic打印程序调用栈，终止程序执行来处理错误

所以对错误的处理也有两种方法，一种是通过返回一个错误类型值来处理错误，ｍ
另一种是直接调用panic抛出错误，退出程序

Go是静态强类型语言，程序的大部分错误是可以在编译器检测到的，
但

２．７　底层实现

２．７．１　函数调用规约。

Go函数使用的是caller-save的模式，即由调用者负责保存寄存器，
所以在函数的头尾不会出现push ebp;mov esp ebp这样的代码

２．７.2 汇编基础


第３章类型系统


３．１　类型简介


简单类型和复合类型

３．１．１　命名类型和未命名类型

类型可以通过标识符来表示，这种类型称为命名类型。

一个类型由预声明类型，关键字和操作符组合而成，这个类型称为未命名类型。
未命名类型又称我类型字面量(Type Literal)


Go语言的基本类型中的复合类型：数组(array),切片(slice)
字典(map),通道(channel),指针(pointer)
函数字面量(function),结构(struct)和接口(interface)
都属于类型字面量，也都是未命名类型

所以 *int,[]int,[2]int,map[k]v都是未命名类型

(1) 未命名类型和类型字面量是等价的，我们通常是Go语言基本类型中的复合类型
就是类型字面量

(2) 通常所说的Go语言基本类型中的简单类型就是这２０个预声明类型，它们都属于
命名类型
(3) 预声明类型是命名类型的一种，另一类命名类型是自定义类型


3.1.2 底层类型

3.1.3 类型相同和类型赋值

类型可直接赋值

不同类型的变量之间一般是不能直接相互赋值的，除非满足一定的条件。


3.1.4 类型强制转换

var a T = (T)(b)，使用括号将类型和要转换的变量或表达式的值括起来


非常量类型的变量x可以强制转化并传递给类型T,需要满足如下的条件：
(1) x可以直接赋值给T类型变量
(2) x的类型和T具有相同的底层类型
(3) x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型
(4) x的类型和T都是整型，或都是浮点型
(5) x的整数值或[]byte类型的值，T是string类型
(7)x是一个字符串，T是[]byte或[]rune
字符串和字节切片之间的转换最常见

s := "hello,世界"
var a []byte
a = []byte(s)
var b string
b = string
var c []rune
c = []rune(s)
fmt.Printf("%T\n",a) 
fmt.Printf("%T\n",b)
fmt.Printf("%T\n",c)

注意
(1) 数值类型和string类型之间的相互转化可能造成值部分丢失；其他的转化仅仅是类型
转换，不会造成值的改变。string和数字之间的转换看可使用标准库strconv
(2)Go语言没有语言机制支持指针和interger之间的直接转换，可以使用标准
库中的unsafe包进行处理


3.2 类型方法


３．２．１　自定义方法

自定义类型。用户自定义类型使用关键字type,其语法格式是type newtype oldtype



自定义struct类型


struct XXXname struct{
	Field1 type1
}


type errorString struct{
	s string
｝

struct　初始化
p96 



