
李文塔


go语言的三大特性：类型系统，接口和并发

go语言编程类型的图书类型

１．基础全面型

２．源码深入型

３．　专业领域型


第１章　基础知识

每种语言都有其独特的应用领域：
在嵌入式领域，汇编和c是首选
在操作系统领域，c是首选
在系统级服务器编程领域，c++是首选
在企业级应用程序和web应用领域，java是


１．１．１　go的诞生北京

(1) 摩尔定律接近失效后多核服务器已经成为主流，当前的编程语言对并发的支持不是很好，
不能很好地发挥多核CPU的威力。
(2) 程序越大，编译速度越慢
(3) 语言越来越复杂

并发，编译速度，编程复杂度

1.1.2 语言特性

语言组织
所有的高级语言都使用源代码来表达程序，主要包括


１．标识符和关键字
２．变量和常量
３．　运算符
４．表达式
５．　简单语句
６．　控制结构


类型系统

１．动静特性：动态语言还是静态语言
２．　类型强弱：强类型还是弱类型
３．　基本数据类型：包括类型及其支持的运算和操作集合
４．　自定义数据类型：包括类型及其支持的运算和操作集合

抽象特性

１．函数：是否支持函数，匿名函数，高阶函数，闭包等
２．　面向对象：是否支持面向对象
３．多态：如何支持多态
４．接口：是否支持接口，以及接口实现模式

元编程特性

１．泛型：是否支持泛型
２．　反射：是否支持反射，反射的能力

运行和跨平台语言特性

１．编译模式：是编译可执行程序，还是编译成中间代码，还是解释器解释执行
２．　运行模式：直接由OS加载运行，还是由虚拟机加载执行
３．　内存管理：是否支持垃圾回收
４．　并发支持：是否原生支持并发，还是库支持
５．交叉编译：是否支持交叉编译
６．　跨平台支持：是否支持多个皮糖

语言软实力特性
１．库：标准库和第三方库是否丰富，好用，高效
２．　框架：是否有出众的框架
３．语言自身兼容性：语言规范是否
４．语言的他影响力

go

支持顺序，循环，分支，静态语言，支持运行时动态类型
强类型，支持隐式类型推导，类型安全，支持type自定义
支持函数，类型组合支持面向对象，接口
Duck模型，通过接口支持

没有泛型支持，有反射支持
编译成可执行程序

直接运行，支持自动垃圾回收
协程(语言原生支持)，支持交叉编译，支持跨平台

应用领域：
云计算基础设施软件，中间件，区块链


将新知识与已经掌握的旧知识进行对比，
将新知识链接到旧知识里面，最终形成一个知识体系。

技能就是把已经掌握的抽象成解决问题的认知模型，这些
认知模型能够直到摸解决某个领域和相似领域的问题

main是可执行程序的包名，所有的go源程序文件头部必须有一个
包声明语句，go通过包来管理命名空间

import 引用一个头部包fmt,可以是标准库的包，也可以是第三方或自定义的
包，fmt是标准输入/输出包

func关键字声明定义一个函数，函数名为main,main代表go程序入口函数

fmt包里面的Printf函数，函数实参是一个字符串字面量，在标准输出
\n是一个转义符，表示换行

go源代码的特征

１．源程序以.go为后缀
2. 源程序默认为UTF-8编码
3. 标识符区分大小写
4. 语句结尾的分号可以省略
5. 函数以func开头，函数体开头的"{"　必须在函数头所在行尾部，不能单独起一行
６、　字符串字面量使用""""(双引号)括起来
7. 调用表里面的方法通过点"."访问符，比如示例中的fmt.Printf
8. main函数所在的包名必须是main


go build hello.go
./hello

1.3 go词法单元


现代高级语言的源程序内部的几个概念：
１．token
2.关键字
3. 标识符
4. 操作符
5. 分隔符
6. 字面量

1.3.1 token

token是构成源程序的基本不可再分割的单元。
编译器编译源程序的第一步就是将源程序分割为一个个独立的
token,这个过程就是词法分析。

go语言的token可以分为关键字，标识符，操作符，分隔符和字面量等


go的toke分隔符有两类：
１．操作符
２．自身没有特殊函数，仅用来分隔其他token,被称为纯分隔符


操作符：操作符就是一个天然的分隔符，同时其自身也是一个token,

sum := a+b

纯分隔符：其本身不具备任何语法含义，只作为其他token的分割
功能。博爱看空格，制表符，换行符和回车符，多个相邻的空格或
制表符会被编译器看作分隔符处理，比如 package main

这是一个包声明的语句，pakcage和main之间可以有任意多个
空格或制表符，go编译器会将其作为一个分隔符处理，最后
分离出来两个token:package 和main



1.3.2 标识符

go语言预声明的标识符包括关键字，内置数据类型标识符，常量值
标识符，内置函数和空白标识符。在写go源程序的过程中，
用户自定义标识符用在包名，函数名，自定义类型名，变量名和
常量名等


关键字

break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var


１．引导程序整体结构的８个关键字


package //定义包名的关键字
import //导入包名关键字
const //　常量声明关键字
var //变量声明关键字
func //函数定义关键字
defer //延迟执行关键字
go // 并发语法糖关键字
return //函数返回关键字

2. 声明符合数据结构的４个关键字

struct //定义结构类型关键字
interface //定义接口类型类型关键字
map  //声明或创建map类型关键字
chan //声明或创建通道类型关键字

3. 控制程序结构的１３个关键字

if else // if else语句关键字
for range break continue //for循环使用的关键字
switch select type case default fallthrough // switch和select 语句使用的关键字

goto //goto跳转语句关键字

内置数据类型标识符(20个)

丰富的内置类型支持是高级语言的基本特性，基本类型也是构造用户自定义类型的基础。
为了标识符每种内置数据类型，go定义了一套预声明标识符，这些标识符用在变量或常量声明时，

内置数据类型标识符(20个)

数值(16个)
	整型(12个)
		byte int int8 int16 int32 int64
		uint uint8 uint16 uint32 uint64 uintptr
	浮点型(2个)
		float32 float64

	复数型(2个)
		complex64 complex128


字符和字符串型(2个)
string rune
接口型(1)
error


go是一种强类型静态编译型语言，在定义变量和常量时需要显式地指出数据类型，
go也支持自动类型推导，在声明初始化内置类型变量时，go可以自动地进行类型推导。
在定义新类型或函数时，必须显式地带上乐行标识符。

内置函数 １５个

make new len cap append copy delete panic recover close
complex real image Print Println


内置函数也是高级语言的一种语法糖，由于其是语言内置的，不需要用import 引入，内置函数
具有全局可见性。注意到其都是以小写字母开头的，但是并不影响其全局可用性。

常量值标识符(4个)
true false // true和false表示bool　类型的两常量值：真和假
iota  //用在连续的枚举的声明中
nil // 指针/引用型的变量的默认值就是nil


go的常量值标识代表的是一个常量值，这个常量值表达特殊的汉所以，
不好使用产量字面量直接表达时，就使用一个预先声明的标识符代替


空白标识符(1个)



空白标识符有特殊的汉所以，用来声明一个匿名的变量，该变量在赋值表达式的左端，空白标识符引用通常被用作
占位，比如忽略函数多个返回值中的一个和强制编译器做类型检查

１.3.3 操作符和分隔符


操作符就是语言所使用的符合集合，包括运算符，显式的分隔符，
纯粹的分隔符有４个：　空格，制表符，回车和换行


算术运算符(5个)
+ - * / %

位运算符(6个)
& | ^ &^ >> <<

赋值和赋值复核运算符(13个)

 :=  = += -= *=   &= |= ^= &^= >>= <<=

比较运算符(6个)

> >= < <= == !=


括号(6个)
() {} []

逻辑运算符(3个)

&& || !


自增自减操作符(2个)

++ --

注意，golang中自增，自减操作符是语句不是表达式

其他运算符(6个)

: , ; . ... <-


1.3.4 字面常量

编程语言源程序中表示固定值的符号叫做字面常量，简称字面量。

字面量可以被编程语言编译器直接转换为某个类型的值。
go的字面量可以出现在两个地方：
一是，用于常量和变量的初始化，而是用于在表达式里或作为函数调用实参。
变量初始化语句汇总如果没有显式地指定变量类型，则go编译器会结合字面量的值自动
进行类型推断。go中的字面量只能表达基本类型的值，go不支持用户定义的字面量


字面量有如下几类


１．整型字面量(Integer literals)
43
2.浮点型字面量
2.3

3. 复数类型字面量

4. 字符型字面量

go的源码采用的是UTF-8的编码方式，UTF-8的字符占用的字节数可以有1~4个字节，
Rune字符常量也有很多表现形式，但是使用" '' "(单引号)将其括住


'a'
'本'
'\t'
５．　字符串字面量

字符串字面量的基本表现形式就是使用" "" "(双引号)，将字符序列包括在内，双引号里面可以是
UTF-8的字符字面量，也可以是其编码值

"\n"
"\""
"Hello,world! \n"
"中国人"

go的源程序基本构成：
１．关键字引起程序的基本结构
２．内置类型标识符辅助声明变量和常量
3. 字面量辅助变量和常量的初始化
4. 分隔符帮助go编译器识别各个token
5. 操作符和变量，关键字一起构成丰富的语法单元


1.4 变量和常量

高级语言通过一个标识符来绑定一块特定的内存，后续对特定的内存的操作都可以使用该标识符来代替。

这种绑定某个存储单元的标识符又可以分为两类：
一类是变量，一类是常量

变量表示指向的内存可以被修改，常量表示指向的内存不能被修改

1.4.1 变量
变量：使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时指定的类型决定，
该内存地址里面存放的内容可以改变
go的基本类型变量声明有两种：
１．　显式的完整声明

var varName dataType [ = value]
go的变量声明后就会立即为其分配空间

var a int=1

2. 短类型声明

varName := value

:= 声明只能出现在函数内(包括在方法内)
此时go编译器自动进行数据类型推断
go支持多个类型同时声明并赋值

a,b := 1,"hello"



变量具有如下几个睡醒
１．变量名
２．　变量值

变量实际指向的是地址里存放的值，变量的值具体怎么解析是由变量的类型来决定的。
在初始化变量值时，可以使用字面量，也可以使用其他的变量名

3. 变量存储和生存期

go语言提供自动内存管理，通常程序员不需要特别关注变量的生存期和存放位置。编译器使用
栈逃逸技术能够自动为变量分配空间：可能在栈上，也可能在堆上

4. 类型信息

类型决定了该变量存储的值怎么解析，以及支持哪些操作和运算，不同类型的变量支持
的操作和运算集是不一样的

５．　可见型和作用域

go内部使用统一的命名空间对变量进行管理，每个变量都有一个唯一的名字，
包名是这个名字的前缀


1.4.2 常量

常量使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义常量时指定
的类型决定，而且该内存地址里面存放的内容不可以改变。
go中常量分为布尔型，字符串型和数值型常量。常量存储在程序的只读段里
预声明标识符iota用在常量声明中，其初始值为0.一组多个常量同时声明时其值逐行增加，
iota可以看作自增的枚举变量，专门用来初始化常量

1.5 基本数据类型
go是一种强类型的静态编译语言，类型是高级语言的基础，有了类型，高级语言才能对不同类型抽象
出不同的运算，

go内置七类基本数据类型(20个具体子类型)

布尔类型:bool
整型：byte int int
浮点型:float32 float64
复数
字符:rune
字符串：string
错误类型：error

1.5.1 布尔类型

var ok bool
ok = true

ok := false

布尔类型数据和整型数据不能进行相互转换

var a bool
a = 1
比较表达式和逻辑表达式的结果都是布尔类型数据

var b bool = (x>y) && (x>0)

if和for语句的条件部分一定是布尔类型的值或表达式

if a<= b{


for;tune ;{}

声明的布尔型变量如不指定初始化值，则默认为false
var b bool 


1.5.2  z整型


var a int =1
var b int32 =2
b =a

整型支持算术运算和位运算，算术表达式和位操作表达式的结果还是整型

1.5.3 浮点型


(1) 浮点数字面量被自动类型推断为float64类型

var b :=10.00
(2) 计算机很难进行浮点数的精确表示和存储，因此两个浮点数之间不应该使用== 或!= 进行比较操作，
高精度科学计算应该使用math标准库

１．５．４　复数类型


1.5.5 字符串

go语言将字符串作为一种原生的基本数据类型，字符串的初始化可以使用字符串字面量

var a = "hello,world"

(1) 字符串是常量，可以通过类似数组的索引访问其字节单元，但是不能修改某个字节的值

var a = "hello world"
	b:= a[0]
	
(2) 字符串转换为切片[]byte(s)要慎用，尤其是当数据量较大时(每转换一次都需要复制内容)
(3) 字符串尾部不包含NULL字符
(4)　字符串类型底层实现是一个二元的数据结构，一个是指针指向字节数组的起点，
另一个是长度

(5) 基于字符串创建的切片和原字符串指向相同的底层字符数组，一样不能修改，对字符串的切片操作返回的子串让然是string,而非slice
a := "hello"

(6) 字符串和切片的转换：字符串可以转换为字节数组，也可以转换为Unicode的字数组

b := []byte(a)
c := []rune(a)

(7) 字符串的运算


1.5.6 rune类型

go内置两种字符类型：一种是byte的字节类类型(byte是uint的别名)
另一种是表示Unicode编码的字符rune.
rune　在go内部是int32类型的别名，占用4个字节。
go语言默认的字符编码是UTF-8类型的，如果需要特殊的编码转换，则使用Unicode/UTF-8标准包


１．６　复合数据类型

指针，数组，切片，字典(map)，通道，结构体和接口

*pointerType // 指针类型使用*后面跟其指向的类型名
[n] elementType //数组类型使用[n]后面跟数组元素类型表示,n表示该数组的长度
[] elementType //切片类型使用[] 后面跟切片元素类型表示
map [keyType] valueType //map 类型使用map[键类型]值类型来表示
chan valueType //通道使用chan后面跟通道元素类型来表示

struct{
	feildType feildType
}  // 结构体类型使用struct{}将各个结构字段括起来表示

interface{ // 接口类型使用interface{}将各个方法括起来表示
	method1(inputParams)(returnParams)
}


1.6.1 指针



go语言支持指针，指针的声明类型为*T,go同样支持多级指针**T
通过在变量名前加&来获取变量的地址

(1) 指针赋值
*T = ,表示指针声明
=*T,表示取指针指向的值

var a =1
p := &a

(2) 结构体指针访问结构体字段仍然使用.操作
type User struct{
	name string
	age int
}

andes := User{
	name:"andes",
	age :18,
}
p := &andes
fmt.Println(p.name) // p.name 通过.操作符访问成员变量

(3) go不支持指针的运算

(4) 函数中允许返回局部变量的地址

go编译器使用"栈逃逸"机制将这种局部变量的空间分配在堆上。

func sum(a,b int) *int{
	sum := a+b
	return &sum //允许，sum会分配在heap上
}


1.6.2 数组

数组的类型名是[n]elementType,其中n是数组长度，elementType是数组元素类型。比如一个包含2个int类型元素
的数组类型可表示为[2]int.
数组一般在创建时通过字母量初始化，单独声明一个数组类型变量而不进行初始化是没有意义的

var arr [2]int //声明一个有两个整型的数组，但元素默认值都是0,一般很少使用

array := [...]float64{7.0,8.5,9.1} // [...]后面跟字面量初始化列表

数组初始化

a := [3]int{1,2,3} //指定长度和初始化字面量
a := [...]int{1,2,3} // 不指定长度，但是由后面的初始化列表数量来确定其长度
a := [3]int{1:1,2:3} //　指定总长度，并通过索引值进行初始化，没有初始化元素时使用类型默认值

a := [...]int{1:1,2:3} //不指定总长度，通过索引值进行初始化，数组长度由最后一个索引值确定，没有
		指定索引的元素被初始化为类型的零值


数组的特定啊
(1) 数组创建万长度就固定了，不可以再追加元素
(2) 数组是值类型的，数组赋值或作为函数参数都是值拷贝
(3) 数组长度是数组类型的组成部分，[10]int和[20]int表示不同的类型
(4) 可以根据数组创建切片


数组相关操作

(1) 数组元素访问

a := [...]int{1,2,3}

b := a[0]
for i,v := range a{}

(2) 数组长度

a := [...]int{1,2,3}
alengh := len(a)
for i:=0 ; i<alengh;i++{
	}

1.6.3 切片

go语言的数组的定长性和值拷贝限制了其使用场景，go提供了
另一种数据类型slice(中文为切片)
这是一种变长数组，其数据饥饿哦股中有指向数组的指针，所以
也是一种引用类型

type slice struct{
array unsafe.Pointer
len int
cap int
}

go为切片维护三个元素---指向底层数组的指针，切片的元素数量和
底层数组的容量

(1) 切片的创建

由数组创建

创建语法：array[b:e]
array表示数组名;b表示开始索引，可以不指定，默认是0;
e表示结束索引，可以不指定，
默认是len(array)
array[b:e]表示创建一个包含e-b个元素的切片，
第一个元素是array[b],最后一个元素是array[e-1]



通过内置函数make创建切片

注意：由make创建的切片各元素被默认初始化为切片元素类型的零值


// len =10,cap =10

a := make([]int,10)

// len = 10,cap =15

这里要注意:直接声明切片类西藏变量是没有意义的

此时切片a的底层的数据结构如图

(2) 切片支持的操作

内置函数len()返回切片长度
内置函数cap()返回切片底层数组容量
内置函数append()对切片追加元素
内置函数copy()用于复制一个切片

(3) 字符串和切片的相关转化

1.6.4 map

p44 

