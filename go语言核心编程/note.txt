
李文塔


go语言的三大特性：类型系统，接口和并发

go语言编程类型的图书类型

１．基础全面型

２．源码深入型

３．　专业领域型


第１章　基础知识

每种语言都有其独特的应用领域：
在嵌入式领域，汇编和c是首选
在操作系统领域，c是首选
在系统级服务器编程领域，c++是首选
在企业级应用程序和web应用领域，java是


１．１．１　go的诞生北京

(1) 摩尔定律接近失效后多核服务器已经成为主流，当前的编程语言对并发的支持不是很好，
不能很好地发挥多核CPU的威力。
(2) 程序越大，编译速度越慢
(3) 语言越来越复杂

并发，编译速度，编程复杂度

1.1.2 语言特性

语言组织
所有的高级语言都使用源代码来表达程序，主要包括


１．标识符和关键字
２．变量和常量
３．　运算符
４．表达式
５．　简单语句
６．　控制结构


类型系统

１．动静特性：动态语言还是静态语言
２．　类型强弱：强类型还是弱类型
３．　基本数据类型：包括类型及其支持的运算和操作集合
４．　自定义数据类型：包括类型及其支持的运算和操作集合

抽象特性

１．函数：是否支持函数，匿名函数，高阶函数，闭包等
２．　面向对象：是否支持面向对象
３．多态：如何支持多态
４．接口：是否支持接口，以及接口实现模式

元编程特性

１．泛型：是否支持泛型
２．　反射：是否支持反射，反射的能力

运行和跨平台语言特性

１．编译模式：是编译可执行程序，还是编译成中间代码，还是解释器解释执行
２．　运行模式：直接由OS加载运行，还是由虚拟机加载执行
３．　内存管理：是否支持垃圾回收
４．　并发支持：是否原生支持并发，还是库支持
５．交叉编译：是否支持交叉编译
６．　跨平台支持：是否支持多个皮糖

语言软实力特性
１．库：标准库和第三方库是否丰富，好用，高效
２．　框架：是否有出众的框架
３．语言自身兼容性：语言规范是否
４．语言的他影响力

go

支持顺序，循环，分支，静态语言，支持运行时动态类型
强类型，支持隐式类型推导，类型安全，支持type自定义
支持函数，类型组合支持面向对象，接口
Duck模型，通过接口支持

没有泛型支持，有反射支持
编译成可执行程序

直接运行，支持自动垃圾回收
协程(语言原生支持)，支持交叉编译，支持跨平台

应用领域：
云计算基础设施软件，中间件，区块链


将新知识与已经掌握的旧知识进行对比，
将新知识链接到旧知识里面，最终形成一个知识体系。

技能就是把已经掌握的抽象成解决问题的认知模型，这些
认知模型能够直到摸解决某个领域和相似领域的问题

main是可执行程序的包名，所有的go源程序文件头部必须有一个
包声明语句，go通过包来管理命名空间

import 引用一个头部包fmt,可以是标准库的包，也可以是第三方或自定义的
包，fmt是标准输入/输出包

func关键字声明定义一个函数，函数名为main,main代表go程序入口函数

fmt包里面的Printf函数，函数实参是一个字符串字面量，在标准输出
\n是一个转义符，表示换行

go源代码的特征

１．源程序以.go为后缀
2. 源程序默认为UTF-8编码
3. 标识符区分大小写
4. 语句结尾的分号可以省略
5. 函数以func开头，函数体开头的"{"　必须在函数头所在行尾部，不能单独起一行
６、　字符串字面量使用""""(双引号)括起来
7. 调用表里面的方法通过点"."访问符，比如示例中的fmt.Printf
8. main函数所在的包名必须是main


go build hello.go
./hello

1.3 go词法单元


现代高级语言的源程序内部的几个概念：
１．token
2.关键字
3. 标识符
4. 操作符
5. 分隔符
6. 字面量

1.3.1 token

token是构成源程序的基本不可再分割的单元。
编译器编译源程序的第一步就是将源程序分割为一个个独立的
token,这个过程就是词法分析。

go语言的token可以分为关键字，标识符，操作符，分隔符和字面量等


go的toke分隔符有两类：
１．操作符
２．自身没有特殊函数，仅用来分隔其他token,被称为纯分隔符


操作符：操作符就是一个天然的分隔符，同时其自身也是一个token,

sum := a+b

纯分隔符：其本身不具备任何语法含义，只作为其他token的分割
功能。博爱看空格，制表符，换行符和回车符，多个相邻的空格或
制表符会被编译器看作分隔符处理，比如 package main

这是一个包声明的语句，pakcage和main之间可以有任意多个
空格或制表符，go编译器会将其作为一个分隔符处理，最后
分离出来两个token:package 和main



1.3.2 标识符

go语言预声明的标识符包括关键字，内置数据类型标识符，常量值
标识符，内置函数和空白标识符。在写go源程序的过程中，
用户自定义标识符用在包名，函数名，自定义类型名，变量名和
常量名等


关键字

break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var


１．引导程序整体结构的８个关键字


package //定义包名的关键字
import //导入包名关键字
const //　常量声明关键字
var //变量声明关键字
func //函数定义关键字
defer //延迟执行关键字
go // 并发语法糖关键字
return //函数返回关键字

2. 声明符合数据结构的４个关键字

struct //定义结构类型关键字
interface //定义接口类型类型关键字
map  //声明或创建map类型关键字
chan //声明或创建通道类型关键字

3. 控制程序结构的１３个关键字

if else // if else语句关键字
for range break continue //for循环使用的关键字
switch select type case default fallthrough // switch和select 语句使用的关键字

goto //goto跳转语句关键字

内置数据类型标识符(20个)

丰富的内置类型支持是高级语言的基本特性，基本类型也是构造用户自定义类型的基础。
为了标识符每种内置数据类型，go定义了一套预声明标识符，这些标识符用在变量或常量声明时，

内置数据类型标识符(20个)

数值(16个)
	整型(12个)
		byte int int8 int16 int32 int64
		uint uint8 uint16 uint32 uint64 uintptr
	浮点型(2个)
		float32 float64

	复数型(2个)
		complex64 complex128


字符和字符串型(2个)
string rune
接口型(1)
error


go是一种强类型静态编译型语言，在定义变量和常量时需要显式地指出数据类型，
go也支持自动类型推导，在声明初始化内置类型变量时，go可以自动地进行类型推导。
在定义新类型或函数时，必须显式地带上乐行标识符。

内置函数 １５个

make new len cap append copy delete panic recover close
complex real image Print Println


内置函数也是高级语言的一种语法糖，由于其是语言内置的，不需要用import 引入，内置函数
具有全局可见性。注意到其都是以小写字母开头的，但是并不影响其全局可用性。

常量值标识符(4个)
true false // true和false表示bool　类型的两常量值：真和假
iota  //用在连续的枚举的声明中
nil // 指针/引用型的变量的默认值就是nil


go的常量值标识代表的是一个常量值，这个常量值表达特殊的汉所以，
不好使用产量字面量直接表达时，就使用一个预先声明的标识符代替


空白标识符(1个)



空白标识符有特殊的汉所以，用来声明一个匿名的变量，该变量在赋值表达式的左端，空白标识符引用通常被用作
占位，比如忽略函数多个返回值中的一个和强制编译器做类型检查

１.3.3 操作符和分隔符


操作符就是语言所使用的符合集合，包括运算符，显式的分隔符，
纯粹的分隔符有４个：　空格，制表符，回车和换行


算术运算符(5个)
+ - * / %

位运算符(6个)
& | ^ &^ >> <<

赋值和赋值复核运算符(13个)

 :=  = += -= *=   &= |= ^= &^= >>= <<=

比较运算符(6个)

> >= < <= == !=


括号(6个)
() {} []

逻辑运算符(3个)

&& || !


自增自减操作符(2个)

++ --

注意，golang中自增，自减操作符是语句不是表达式

其他运算符(6个)

: , ; . ... <-


1.3.4 字面常量

编程语言源程序中表示固定值的符号叫做字面常量，简称字面量。

字面量可以被编程语言编译器直接转换为某个类型的值。
go的字面量可以出现在两个地方：
一是，用于常量和变量的初始化，而是用于在表达式里或作为函数调用实参。
变量初始化语句汇总如果没有显式地指定变量类型，则go编译器会结合字面量的值自动
进行类型推断。go中的字面量只能表达基本类型的值，go不支持用户定义的字面量


字面量有如下几类


１．整型字面量(Integer literals)
43
2.浮点型字面量
2.3

3. 复数类型字面量

4. 字符型字面量

go的源码采用的是UTF-8的编码方式，UTF-8的字符占用的字节数可以有1~4个字节，
Rune字符常量也有很多表现形式，但是使用" '' "(单引号)将其括住


'a'
'本'
'\t'
５．　字符串字面量

字符串字面量的基本表现形式就是使用" "" "(双引号)，将字符序列包括在内，双引号里面可以是
UTF-8的字符字面量，也可以是其编码值

"\n"
"\""
"Hello,world! \n"
"中国人"

go的源程序基本构成：
１．关键字引起程序的基本结构
２．内置类型标识符辅助声明变量和常量
3. 字面量辅助变量和常量的初始化
4. 分隔符帮助go编译器识别各个token
5. 操作符和变量，关键字一起构成丰富的语法单元


1.4 变量和常量

高级语言通过一个标识符来绑定一块特定的内存，后续对特定的内存的操作都可以使用该标识符来代替。

这种绑定某个存储单元的标识符又可以分为两类：
一类是变量，一类是常量

变量表示指向的内存可以被修改，常量表示指向的内存不能被修改

1.4.1 变量
变量：使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时指定的类型决定，
该内存地址里面存放的内容可以改变
go的基本类型变量声明有两种：
１．　显式的完整声明

var varName dataType [ = value]
go的变量声明后就会立即为其分配空间

var a int=1

2. 短类型声明

varName := value

:= 声明只能出现在函数内(包括在方法内)
此时go编译器自动进行数据类型推断
go支持多个类型同时声明并赋值

a,b := 1,"hello"



变量具有如下几个睡醒
１．变量名
２．　变量值

变量实际指向的是地址里存放的值，变量的值具体怎么解析是由变量的类型来决定的。
在初始化变量值时，可以使用字面量，也可以使用其他的变量名

3. 变量存储和生存期

go语言提供自动内存管理，通常程序员不需要特别关注变量的生存期和存放位置。编译器使用
栈逃逸技术能够自动为变量分配空间：可能在栈上，也可能在堆上

4. 类型信息

类型决定了该变量存储的值怎么解析，以及支持哪些操作和运算，不同类型的变量支持
的操作和运算集是不一样的

５．　可见型和作用域

go内部使用统一的命名空间对变量进行管理，每个变量都有一个唯一的名字，
包名是这个名字的前缀


1.4.2 常量

常量使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义常量时指定
的类型决定，而且该内存地址里面存放的内容不可以改变。
go中常量分为布尔型，字符串型和数值型常量。常量存储在程序的只读段里
预声明标识符iota用在常量声明中，其初始值为0.一组多个常量同时声明时其值逐行增加，
iota可以看作自增的枚举变量，专门用来初始化常量

1.5 基本数据类型
go是一种强类型的静态编译语言，类型是高级语言的基础，有了类型，高级语言才能对不同类型抽象
出不同的运算，

go内置七类基本数据类型(20个具体子类型)

布尔类型:bool
整型：byte int int
浮点型:float32 float64
复数
字符:rune
字符串：string
错误类型：error

1.5.1 布尔类型

var ok bool
ok = true

ok := false

布尔类型数据和整型数据不能进行相互转换

var a bool
a = 1
比较表达式和逻辑表达式的结果都是布尔类型数据

var b bool = (x>y) && (x>0)

if和for语句的条件部分一定是布尔类型的值或表达式

if a<= b{


for;tune ;{}

声明的布尔型变量如不指定初始化值，则默认为false
var b bool 


1.5.2  z整型


var a int =1
var b int32 =2
b =a

整型支持算术运算和位运算，算术表达式和位操作表达式的结果还是整型

1.5.3 浮点型


(1) 浮点数字面量被自动类型推断为float64类型

var b :=10.00
(2) 计算机很难进行浮点数的精确表示和存储，因此两个浮点数之间不应该使用== 或!= 进行比较操作，
高精度科学计算应该使用math标准库

１．５．４　复数类型


1.5.5 字符串

go语言将字符串作为一种原生的基本数据类型，字符串的初始化可以使用字符串字面量

var a = "hello,world"

(1) 字符串是常量，可以通过类似数组的索引访问其字节单元，但是不能修改某个字节的值

var a = "hello world"
	b:= a[0]
	
(2) 字符串转换为切片[]byte(s)要慎用，尤其是当数据量较大时(每转换一次都需要复制内容)
(3) 字符串尾部不包含NULL字符
(4)　字符串类型底层实现是一个二元的数据结构，一个是指针指向字节数组的起点，
另一个是长度

(5) 基于字符串创建的切片和原字符串指向相同的底层字符数组，一样不能修改，对字符串的切片操作返回的子串让然是string,而非slice
a := "hello"

(6) 字符串和切片的转换：字符串可以转换为字节数组，也可以转换为Unicode的字数组

b := []byte(a)
c := []rune(a)

(7) 字符串的运算


1.5.6 rune类型

go内置两种字符类型：一种是byte的字节类类型(byte是uint的别名)
另一种是表示Unicode编码的字符rune.
rune　在go内部是int32类型的别名，占用4个字节。
go语言默认的字符编码是UTF-8类型的，如果需要特殊的编码转换，则使用Unicode/UTF-8标准包


１．６　复合数据类型

指针，数组，切片，字典(map)，通道，结构体和接口

*pointerType // 指针类型使用*后面跟其指向的类型名
[n] elementType //数组类型使用[n]后面跟数组元素类型表示,n表示该数组的长度
[] elementType //切片类型使用[] 后面跟切片元素类型表示
map [keyType] valueType //map 类型使用map[键类型]值类型来表示
chan valueType //通道使用chan后面跟通道元素类型来表示

struct{
	feildType feildType
}  // 结构体类型使用struct{}将各个结构字段括起来表示

interface{ // 接口类型使用interface{}将各个方法括起来表示
	method1(inputParams)(returnParams)
}


1.6.1 指针



go语言支持指针，指针的声明类型为*T,go同样支持多级指针**T
通过在变量名前加&来获取变量的地址

(1) 指针赋值
*T = ,表示指针声明
=*T,表示取指针指向的值

var a =1
p := &a

(2) 结构体指针访问结构体字段仍然使用.操作
type User struct{
	name string
	age int
}

andes := User{
	name:"andes",
	age :18,
}
p := &andes
fmt.Println(p.name) // p.name 通过.操作符访问成员变量

(3) go不支持指针的运算

(4) 函数中允许返回局部变量的地址

go编译器使用"栈逃逸"机制将这种局部变量的空间分配在堆上。

func sum(a,b int) *int{
	sum := a+b
	return &sum //允许，sum会分配在heap上
}


1.6.2 数组

数组的类型名是[n]elementType,其中n是数组长度，elementType是数组元素类型。比如一个包含2个int类型元素
的数组类型可表示为[2]int.
数组一般在创建时通过字母量初始化，单独声明一个数组类型变量而不进行初始化是没有意义的

var arr [2]int //声明一个有两个整型的数组，但元素默认值都是0,一般很少使用

array := [...]float64{7.0,8.5,9.1} // [...]后面跟字面量初始化列表

数组初始化

a := [3]int{1,2,3} //指定长度和初始化字面量
a := [...]int{1,2,3} // 不指定长度，但是由后面的初始化列表数量来确定其长度
a := [3]int{1:1,2:3} //　指定总长度，并通过索引值进行初始化，没有初始化元素时使用类型默认值

a := [...]int{1:1,2:3} //不指定总长度，通过索引值进行初始化，数组长度由最后一个索引值确定，没有
		指定索引的元素被初始化为类型的零值


数组的特定啊
(1) 数组创建万长度就固定了，不可以再追加元素
(2) 数组是值类型的，数组赋值或作为函数参数都是值拷贝
(3) 数组长度是数组类型的组成部分，[10]int和[20]int表示不同的类型
(4) 可以根据数组创建切片


数组相关操作

(1) 数组元素访问

a := [...]int{1,2,3}

b := a[0]
for i,v := range a{}

(2) 数组长度

a := [...]int{1,2,3}
alengh := len(a)
for i:=0 ; i<alengh;i++{
	}

1.6.3 切片

go语言的数组的定长性和值拷贝限制了其使用场景，go提供了
另一种数据类型slice(中文为切片)
这是一种变长数组，其数据饥饿哦股中有指向数组的指针，所以
也是一种引用类型

type slice struct{
array unsafe.Pointer
len int
cap int
}

go为切片维护三个元素---指向底层数组的指针，切片的元素数量和
底层数组的容量

(1) 切片的创建

由数组创建

创建语法：array[b:e]
array表示数组名;b表示开始索引，可以不指定，默认是0;
e表示结束索引，可以不指定，
默认是len(array)
array[b:e]表示创建一个包含e-b个元素的切片，
第一个元素是array[b],最后一个元素是array[e-1]



通过内置函数make创建切片

注意：由make创建的切片各元素被默认初始化为切片元素类型的零值


// len =10,cap =10

a := make([]int,10)

// len = 10,cap =15

这里要注意:直接声明切片类西藏变量是没有意义的

此时切片a的底层的数据结构如图

(2) 切片支持的操作

内置函数len()返回切片长度
内置函数cap()返回切片底层数组容量
内置函数append()对切片追加元素
内置函数copy()用于复制一个切片

(3) 字符串和切片的相关转化

1.6.4 map

go语言内置的字典类型为map


map[K]T
K可以是任意可以进行比较的类型，T是值类型。map也是一种引用类型

(1) map的黄建
使用字面量创建


使用内置的make函数创建

make(map[K]T) // map的容量使用默认值
make(map[K],len) // map的容量使用给定的len值

(2) map支持的操作

1. map的单个键值对访问格mapName[key]，更新某个key的值时mapName[key]
放到等号左边，访问某个key的值时mapName[key]放在等号的右边

2. 可以使用range遍历一个map类似变量，但是不保证每次迭代元素的顺序

3. 删除map中的某个键值，使用如下语法:delete(mapName,key)
delete是内置函数，用来删除map中的某个键值对

4. 可以使用内置的len()函数返回map中的键值对数量


注意

go内置的map不是并发安全的，并发安全的map可以使用标准包sync中的map


不要直接修改map value内某个元素的值，如果向修改map的某个键值，则必须
整体赋值


1.6.5 struct


go中的struct类型和C类似， 也称为结构体，由多个不同类型元素组合而成。
这里有两层：
1. struct结构中的类型可以是任意类型
2. struct的存储空间是连续的，
其字段按照声明时的顺序存放(注意字段之间有对齐要求)


struct有两种形式：一种是struct类型字面量，另一种
是使用type声明的自定义struct类型

(1) struct类型字面量

struct类型字面量的声明格式如下


struct {
	FeildName FeildType
}


(2) 自定义struct类型。自定义struct类型声明格式如下：

type  TypeName struct{
	FeildName FeildType}


实际使用struct字面量的场景不多，更多的时候是通过type自定义一个
新的类型来实现的。
type 是自定义类型的关键字，不但支持struct类型的创建，
还支持任意其他子定义类型的创建。


(3) struct类型变量的初始化

type Person struct{
	Name string
	Age int
}


type Student struct{
	*Person
	Number int
}


//按照类型声明顺序，逐个赋值
// 不推荐这种初始化方式，一旦struct增加字段，则整个初始化语句会报错


a := Person{"Tom",31}




//推荐这种使用Feild名字的初始化方式，没有指定的字段则默认初始化为类型的零值

p := &Person{
	Name:"tata",
	Age:12,
}


s := Student {
	Person:p,
	Number:110,
}


其他复合类型

接口(Interface),通道(chan)


1.7 控制接口


程序指令都是线性地存放在存储器上。

程序执行从本质上来说就是两种模式：顺序和跳转



顺序就是按照程序指令在存储器上的存放顺序逐条执行
跳转就是遇到跳转指令就跳转到某处继续线性执行

go是一门高级语言，起源程序虽然经过了高度的抽象并封装了很多语法糖，但
还是跳不出这个模式(暂时不考虑goroutine引入并发后的执行视图变化)

顺序在Go里面体现在从main函数开始逐条向下执行，就像我们的程序源代码
顺序一样：跳转在Go里面体现为多个语法糖，包括goto语句和函数调用，
分支(if,switch,select)，循环(for)
跳转分为两种：一种是无条件跳转，比如函数调用和goto语句：一种是有条件的
跳转，比如分支和循环

顺序语句很简单，就是我们天然写程序的从前往后的顺序



go的源代码的熟悉并不一定是编译后最终可执行的程序的指令顺序

1.7.1 if语句

特点

1. if后面的条件判断子句不需要用小括号括起来
2. {必须放在行尾，和if或if else放在一行
3. if后面可以带一个简单的初始化语句，并以分号分割，该简单语句
声明的变量的作用域是整个if语句块，包括后面的else if和else分支

4. Go语言没有条件运算符(a>b?a:b),这也符合Go的设计哲学，
只提供一种方法做事情

5. if分支语句遇到return后直接返回，遇到break则跳过break下方
的if语句块

if x<= y{
	return y
}else{
	return x
}

一个完整的if else的语句示例


if x := f(); x< y{ //初始化语句中的声明变量x
	return x
} else if x> z{ //x在else if里面一样可以被访问
	return z
}else{
	return y
}


最佳实践

1.尽量减少条件语句的复杂度，如果条件语句太多，太复杂，则建议放到函数里面
封装起来
2. 尽量减少if语句的嵌套层次，通过重构让代码变得扁平，便于阅读


if err,file := os.Open("xxxx"); err == nil{
	defer file.Close()
	//do something
	}else{
		return nil,err
}

修改后的代码

err,file := os.Open("xxx")
if err != nil{
	return nil,err
}
defer file.Close()
//do something


17.2 switch语句


switch语句会根据传入的参数检测并执行符合条件的分支

switch的语法特点：


1.7.3 for语句
return 和函数调动

return语句也能引发控制流程的跳转，用于函数和方法的退出。

函数和方法的调用也能引发程序控制流的跳转，

第2章 函数

函数是程序执行的一个基本语法结构，go语言的
很多特性是基于函数这个基础实现的
命名类型的方法本质上是一个函数，类型方法是go面向
对象的实现基础
接口，其底层同样是指针和函数将接口和接口实例连接起来的
甚至go并发语法糖go也是函数

1. 函数是一种类型，函数类型变量可以像其他类型变量一样使用
可以作为其他函数的参数或返回值，也可以直接调用执行
２．　函数支持多值返回。
３．　支持闭包
４．　函数支持可变参数

2.1 基本概念

２．１．１　函数定义

函数是go程序源代码的基本构造单位，一个函数包括如下几个部分
函数声明关键字func,
函数名
参数列表
返回列表
函数体

func funcName(param-list)(result-list){
	function-body
}


函数的特点

(1) 函数可以没有输入参数，也可以没有返回值(默认返回0)

func A(){
	//do something
}

func A()int{
	//do something
	return1
}

(2) 多个相邻的相同类型的参数可以使用简写模式


func add(a,b int) int{
	// a int,b int 可以简写为 a,b int
	return a+b
}
(3) 支持有名的返回值，参数名就相当于函数体内最外层的局部变量
命名返回值变量会被初始化为类型零值，最后的return可以
不带参数名直接返回


// sum　相当于函数内局部变量，被初始化为领

func add(a,b int) (sum int){
	sum = a+b
	return // return sum的简写模式
	// sum := a+b
	//如果是sum := a+b,则相当于新声明一个sum	
	// 变量命名返回变量sum覆盖
	//return sum // 最后需要显式地调用return sum

(4) 不支持默认值参数
(5) 不支持函数重载
(6) 不支持函数嵌套，严格地说是不支持函数的嵌套定义，
但支持嵌套匿名函数

func add(a,b int)(sum int){
	anonymous := func(x,y int)int{
		return x+y
}
	return anonymous(a,b)


2.1.2  多值返回
go函数支持多值返回，定义多值返回的返回参数列表时要使用"()"包裹，
支持命名参数的返回


func swap(a,b int)(int,int){
	return b,a
}

习惯用法：

１．如果多值返回值有错误类型，则一般将错误类型作为最后一个返回值
２．　有关多值返回的内部实现原理


2.1.3 实参到形参的传递

go函数实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，那是
因为参数传递的是指针值的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本

二者指向同一地址，本质上参数传递仍然是值拷贝

2.1.4 不定参数

Go函数支持不定数目的形式参数，不定参数声明使用param...type的语法格式

函数的不定参数有如下特点：

（１）　所有的不定从桉树类型必须是相同的
（２）　不定参数必须是函数的最后一个参数
（３）　不定参数名在函数体内相当于切片，对切片的操作同样适合对不定
参数的操作

func sum(arr...int)(sum int){
	for _,v := range arr{ // 此时arr就相当于切片，可以使用range访问
	sum += v
	}
	return
}


(4) 切片可以作为参数传递给不定参数，切片名后要加上"..."

func sum(arr ...int)(sum int){
	for _,v := range arr{
		sum += v
	}
	return 
}


func main(){
	slice := []int{1,2,3,4}
	array := [...]int{1,2,3,4}

	//数组不可以作为实参传递给不定参数的函数

	sum(slice...)
}

(5) 形参为不定参数的函数和形参为切片的函数类型不相同。

func suma(arr ...int)(sum int){
	for v := range arr {
		sum += v
		}
	return
}


func sumb(arr []int)(sum int){
	for v:= range arr{
		sum +=v
	}
	return 
}


// suma 和sumb的类型并不一样

fmt.Printf("%T \n",suma) // func(...int) int
fmt.Printf("%T \n",sumb) // func([]int) int

2.2 函数签名和匿名函数


２．２．１　　函数签名

函数类型又叫函数签名，一个函数的类型就是函数定义首行去掉函数名，参数名和{
，可以使用fmt.Printf的"%T"格式化参数打印函数的类型

两个函数类型相同的条件是，拥有相同的形参列表和返回值列表(列表元素的次序，个数
和类型都相同)，形参名可以不同

func add(a,b int) int {return a+b}

func sub(x int,y int)(c int) {c=x-y;return c}


可以使用type定义函数类型，函数类型变量可以作为函数的参数或返回值

函数类型和map,slice,chan一样，实际函数类型变量和函数名都可以
当做指针变量，该指针指向函数代码的开始位置。
通常说函数类型变量是一种引用类型，未初始化的函数类型的
变量的默认值是nil


Go中函数是"第一公民"(first class)
有名函数的函数名可以看作函数类型的常量，可以直接使用函数名调用函数，也可以
直接赋值给函数类型变量，后续通过该变量来调用该函数

package main

func sum(a,b int) int{
	return a+b
}

func main(){
	sum(3,4) //直接调用
	f := sum // 有名函数可以直接赋值给变量
	f(1,2)
}

2.2.2 匿名函数


GO提供两种函数：有名函数和匿名函数。匿名函数可以看作函数字面量，所有直接使用
函数类型变量的地方都可以由匿名函数代替。
匿名函数可以直接赋值给函数变量，当做实参，也可以作为返回值，还可以直接被调用

2.6 defer

Go函数里提供了defer关键字，可以注册多个延迟调用，这些调用以先进后出(FILO)
的顺序在函数返回前被执行。这有点类似与Java语言中异常处理的finanly子句。
defer常用于保证一些资源最终一定能够得到回收和释放


defer后面必须是函数或方法的调用，不能是语句，否则会报expression　in defer
must be function call错误

defer函数的实参在注册时通过值拷贝传递进去。下面的代码，
实参a的值在defer注册时通过值通过值拷贝传递金融区，后续
a++并不会影响defer语句最后的输出结果

func f() int{
	a := 0
	defer func(i int){
		println("defer i=",i)
	}(a)

	a++
	return a
}

//defer 打印结果
defer i=0
defer 语句必须先注册后才能执行，如果defer位于return之后，则defer因为
没有注册，不会执行

主动调用os.Exit(int)退出进程时，defer将不再被执行(即使defer
已经提前注册)

defer的好处是可以在一定程度上避免资源泄露，特别是在很多return语句，有多个资源需要关闭
的场景中，很容易漏掉资源的关闭操作

func CopyFile(dst,src string)(w int64,err error){
	src,err := os.Open(src)
	if err != nil {
		return
	}
	dst, err := os.Create(dst)
	if err != nil{
		//src 很容易被忘记关闭
		src.Close()
		return
	}
	w. err = io.Copy(dst,src)
	dst.Close()
	src.Close()
	return
}


使用defer改写后，在打开资源无报错后直接调用defer关闭资源，一旦
养成这样的编程习惯，很难会忘记资源的释放


func CopyFile(dst,src string)(w int64,err error){
	src,err := os.Open(src)
	if err != nil{
		return
	}
	defer src.Close()

	dst, err := os.Create(dst)
	if err != nil{
		return	
	}
	defer dst.Close()

	w,err = io.Copy(dst,src)
	return
}


defer语句额位置不当，有可能导致panic,一般defer语句放在错误检查语句之后，
defer有明显的副作用：defer会推迟资源的释放，defer尽量不要放到循环语句里面，
将大函数内部的defer语句单独拆分成一个小函数是一种好的策略

另外，defer相对于普通的函数调用需要间接的数据结构的支持，
相对于普通函数调用有一定的性能损耗


defer中最好不要对有名返回值参数进行操作，否则报错


２．４　闭包

２．４．１　概念

闭包是由函数及其相关引用环境组合而成的实体，一般通过在匿名函数中引用
外部函数的局部变量或包全局变量构成

闭包＝函数＋引用环境变量

闭包对闭包外的环境引入是直接引用，编译器检测到闭包，会将闭包引用的外部变量分配到堆上


如果函数返回的闭包引用咧该函数的局部变量(参数或函数内部变量)


(1) 多次调用该函数，返回的多个闭包所引用的外部变量是多个副本，原因是每次调用
函数都会局部变量分配内存。
(2) 用一个闭包函数多次，如果该闭包修改了其引用的外部变量，则每一次调用该
闭包对该外部变量都有影响，因为闭包函数共享外部引用

f和g引用的是不同的a

如果一个函数调用返回的闭包引用了全局变量，则每次调用都会影响到全局变量


如果函数返回的闭包引用的是全局变量a,则多次调用该函数返回的多个闭包引用的都是同一个
a.同理，调用一个闭包多次引用的也是同一个a.
此时如果闭包中修改了a值的逻辑，则每次闭包调用都会影响全局变量a的值。
使用闭包是为了减少全局变量，所以闭包引用全局变量不是好的编程方式


同一个函数返回的多个闭包共享该函数的局部变量


2.4.2 闭包的价值


闭包最初的目的是减少全局变量，在函数调用的过程中隐式地传递共享变量，
有其有用的一面：但是这种隐秘的共享变量的方式带来的坏处是不够直接，
不够清晰，除非是非常有价值的地方，一般不建议使用闭包


对象是附有行为的数据，而闭包是附有数据的行为，类在定义时已经显式地集中
定义了行为，但是闭包中的数据没有显式地集中声明的地方，
这种数据和行为耦合的模型不是一种推荐的编程模型，闭包仅仅
是锦上添花的东西，不是不可缺少的


2.5 panic和recover


这两个内置函数用来处理go的运行时错误(runtime errors)
panic用来主动抛出错误，
recover用来捕获panic抛出的错误

２．５．	　基本概念

panic(i interface{})
recover() interface{}


引发panic有两种情况，一种是程序主动调用panic函数，另一种是程序产生运行的错误
由运行时检测并抛出

发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层
向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获
或运行到最外层函数而退出

panic的参数是一个空接口类型interface{}，所以任意类型的变量都可以传递给panic(空即可欧)

调用panic的方法非常简单：panic(xxx)


panic不但可以在函数正常流程中抛出，在defer逻辑里也可以再次调用panic或
抛出panic

defer里面的panic能够被后续执行的defer捕获

recover()用来捕获panic,阻止panic继续向上传递。recover()和defer
一起使用，但是recover()只有在defer后面的函数体内被直接调用
才能捕获panic终止异常，否则返回nil,
异常继续向外传递

defer func(){
	println("defer inner")
	recover()
}()


func except(){
	recover()
}


func test(){
	defer except()
	panic("test panic")
}


可以有连续多个panic被抛出，连续多个panic的场景只能出现在的延迟调用
里面，否则不会出现多个panic被抛出的场景，但只有最后一次panic能被捕获


包中init函数引发的panic只能在init函数中捕获，在main中无法被捕获，
原因是init函数先于main执行，函数并不能捕获内部新启动的goroutine所抛出的panic



2.5.2 使用场景

什么情况下主动调用panic函数抛出panic?

一般有两种情况：
(1) 程序遇到了无法正常执行下去的错误，主动调动panic函数
结束程序运行
(2) 在调试程序时，通过主动调用panic实现快速退出，panic
打印出堆栈能够更快地定位错误

为了保证程序的健壮性，需要主动在程序的分支流程上使用recover()拦截
运行时错误

Go提供了两种处理错误的方式，一种是借助panic和recover的抛出
捕获机制，另一种是使用error错误类型。

2.6 错误处理

2.6.1 error

Go语言内置错误接口类型error.任何类型只要实现Error() string方法，
都可以传递error接口类型变量。Go语言典型的错误处理方式是将
error作为函数最后一个返回值。
在调用函数时，通过检测其返回的error值是否为nil来进行错误处理


type error　interface{
	Error() string
}

Go 语言标准库提供的两个函数返回实现了error接口的具体类型实例，
一般的错误可以使用这两个函数进行封装。遇到复杂的错误，用户也可以
自定义错误类型，只要其实现error接口接口

错误处理的最佳实践


１．　在多个返回值的函数中，error通常作为函数最后一个返回值

２．　如果一个函数返回error类型变量，则先用if语句处理error!=nil
的异常场景，正常逻辑放到if语句块的后面，保持代码平坦
3. defer语句应该放到err判断的后面，不然有可能产生panic
4. 在错误逐级向上传递的过程汇总，错误信息应该不断地丰富和完善，
而不是简单地抛出下层调用的错误，这在错误日志分析时非常有用和友好


2.6.2 错误和异常


异常和错误在现代编程语言中

错误(errors)
未捕获错误－异常(untrapped error)
可捕获错误(trapped error)
compile errors
runtime errors
logic errors

Go是一门类型安全的语言，其运行时不会出现这种编译器和运行时
都无法捕获的错误，不会出现untrapped error,
Go语言不存在所谓的异常，出现的"异常"全是错误

Go程序需要处理的这些错误可以分为两类：

一类是运行时错误(runtime errors),此类错误语言的运行时能够捕获，
并采取错误－－隐式或显式地抛出panic

一类是程序逻辑错误：程序执行错误不符合预期，但不会引发运行时错误


Go对于错误提供了两种处理机制：
（１）　通过函数返回错误类型的值来处理错误
(2) 通过panic打印程序调用栈，终止程序执行来处理错误

所以对错误的处理也有两种方法，一种是通过返回一个错误类型值来处理错误，ｍ
另一种是直接调用panic抛出错误，退出程序

Go是静态强类型语言，程序的大部分错误是可以在编译器检测到的，
但

２．７　底层实现

２．７．１　函数调用规约。

Go函数使用的是caller-save的模式，即由调用者负责保存寄存器，
所以在函数的头尾不会出现push ebp;mov esp ebp这样的代码

２．７.2 汇编基础


第３章类型系统


３．１　类型简介


简单类型和复合类型

３．１．１　命名类型和未命名类型

类型可以通过标识符来表示，这种类型称为命名类型。

一个类型由预声明类型，关键字和操作符组合而成，这个类型称为未命名类型。
未命名类型又称我类型字面量(Type Literal)


Go语言的基本类型中的复合类型：数组(array),切片(slice)
字典(map),通道(channel),指针(pointer)
函数字面量(function),结构(struct)和接口(interface)
都属于类型字面量，也都是未命名类型

所以 *int,[]int,[2]int,map[k]v都是未命名类型

(1) 未命名类型和类型字面量是等价的，我们通常是Go语言基本类型中的复合类型
就是类型字面量

(2) 通常所说的Go语言基本类型中的简单类型就是这２０个预声明类型，它们都属于
命名类型
(3) 预声明类型是命名类型的一种，另一类命名类型是自定义类型


3.1.2 底层类型

3.1.3 类型相同和类型赋值

类型可直接赋值

不同类型的变量之间一般是不能直接相互赋值的，除非满足一定的条件。


3.1.4 类型强制转换

var a T = (T)(b)，使用括号将类型和要转换的变量或表达式的值括起来


非常量类型的变量x可以强制转化并传递给类型T,需要满足如下的条件：
(1) x可以直接赋值给T类型变量
(2) x的类型和T具有相同的底层类型
(3) x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型
(4) x的类型和T都是整型，或都是浮点型
(5) x的整数值或[]byte类型的值，T是string类型
(7)x是一个字符串，T是[]byte或[]rune
字符串和字节切片之间的转换最常见

s := "hello,世界"
var a []byte
a = []byte(s)
var b string
b = string
var c []rune
c = []rune(s)
fmt.Printf("%T\n",a) 
fmt.Printf("%T\n",b)
fmt.Printf("%T\n",c)

注意
(1) 数值类型和string类型之间的相互转化可能造成值部分丢失；其他的转化仅仅是类型
转换，不会造成值的改变。string和数字之间的转换看可使用标准库strconv
(2)Go语言没有语言机制支持指针和interger之间的直接转换，可以使用标准
库中的unsafe包进行处理


3.2 类型方法


３．２．１　自定义方法

自定义类型。用户自定义类型使用关键字type,其语法格式是type newtype oldtype



自定义struct类型


struct XXXname struct{
	Field1 type1
}


type errorString struct{
	s string
｝

struct　初始化


type Person struct{
	name string
	age int
}

(1) 按照字段顺序进行初始化


a : = Person{"name",18}

b := Person{
	"andes",
	18,
	}


c := Person{
	"andes",
	18}


(2) 指定字段名进行初始化

a : = Person{name:"andes",age:18}


如果"}"独占一行，则最后一个字段的后面一定要带上逗号

(3) 使用new创建内置函数，字段默认初始化为其类型的零值，
返回值是指向结构的指针

p := new(Person)

//此时name为"",age是0


一般使用struct都不会将所有字段初始化为零值

(4) 一次初始化一个字段

(5) 使用构造函数进行初始化


当结构发生变化时，构造函数可以屏蔽细节

func New(text string) error{
	return &errorString{text}
}


type errorString struct{
	s string}



结构字段的特点


结构的字段你可以是任意的类型，基本类型，接口类型，
指针类型，函数类型都可可以作为struct的字段

结构字段的类型名必须唯一，struct字段类型可以是普通类型，
也可以是指针，另外，结构支持内嵌自身的指针，这也是
实现树形和链表等复杂数据结构的基础


//标准库　container/list


type Element struct{
	//指向自身类型的指针
	next,prev *Element
	list *List
	Value interface{}
}


匿名字段

在定义struct的过程中，


// 标准库${GOROOT}/src/os/type.go 内的一个匿名的指针字段
type File struct{
	*file //os specfilec
}


var i interface{}

自定义接口类型




// Reader是自定义接口类型，属于命名类型

type Reader interface{
	Read(p []byte) (n int,err error)
}


3.2.2 方法


go语言的类型方法是一种对类型行为的封装。
其显式地将对象实例或之后怎作为函数的第一个参数，
并且参数名可以自己指定，而不强制要求一定是this或self.
这个对象实例或指针称为方法的接收者(reciever)


// 类型方法接收者是值类型

func(t TypeName)MethodName(ParamList)(Returnlist){
	//method body 
}


//类型方法接收者是指针

func (t *TypeName)MethodName(ParaList)(Returnlist){
	//method body}


Go语言的而理性方法


go语言的类型方法本质上就是一个函数，没有使用隐式的指针

类型方法的特点

(1) 可以为命名类型增加方法(除了接口)，非命名类型不能自定义方法

(2) 为类型增加方法有一个心智，就是方法的定义必须和类型的定义在同一个包中

(3) 方法的命名空间的可见性和变量一样，大写开头的方法可以在包外
被访问，否则只能在包内可见

(4) 使用type定义的自定义类型是一个新类型，新类型不能调用原有类型的
方法，但是底层累心支持的运算可以被新类型继承




3.3  方法调用

类型方法本质上是函数，只是采用了一种特殊的语法书写
类型方法咋调用上也很灵活，

调用方法，方法集，方法变量和方法表达式


３．３．１　一般调用


类型方法的一般调用方式


TypeInstanceName.MethodName(ParamList)

TypeInstanceName:类型实例名或指向实例的指针变量名
MethodName：类型方法名
ParamList：方法实参

type  T struct{
	a int
}

func (t T ) Get() int{
	return t.a
}


func (t *T)Set (i int){
	t.a = i
}


var t = &T{}

//普通方法调用

t.Set(2)


//普通方法调用

t.Get()


3.3.2 方法值(method value)


变量x的静态类型是T,M是类型T的一个方法，x.T被称为方法值(method value)
x.T是一个函数类型变量，可以赋值给其他变量，并像普通的函数名一样使用


f := x.M
f(args...)


等价于
x.M(args...)


方法值(method value)其实是一个带有闭包的函数变量，其底层实现
原理和带有闭包的匿名函数类似，接收者被隐式地绑定到方法值(method value)
的闭包环境中。
后续调用不需要再显地传递接收者

type T struct{
	a int
}


func (t T) Get() int{
	return t.a
}

func (t *T) Print(){
	fmt.Printf("%p, %v,%s \n",t,t,t.a)
}
var t = &T{}


//method value


f := t.Set


//方法值调用

f(2) 
t.Print()

//方法值调用

f(3)
t.Print()

3.3.3 方法表达式(method expression)


方法表达式相当于提供一种语法将类型方法调用
显式地转换为函数调用，接收者(receiver)
必须显式地传递进去。下面定义一个类型T,增加两个方法，方法Get的接收者
为T,方法Set的接收这类型为*T


type T struct {
	a int
}

func (t *T) Set(i int) {
	t.a = i
}


func (t T) Get() int{
	return t.a
}


func (t *T) Print(){
	fmt.Printf("%p. %v, %d \n",t,t,t.a)
}



表达式T.Get和(*T).Set被称为方法表达式(method expression)
方法表达式可以看作函数名，只不过这个函数的首个参数是接收着的实例或指针。
T.Get的函数签名是func(t T)int,(*T).Set的函数前面是func(t *T,i int)
注意，这里的T.Get不能携程(*T).Get
(*T).Set也不能写成T.Set,在方法表达式中编译器不会做自动转换，，

//如下方法表达式调用都是等价的


t := T{a:1}


//普通方法调用


t.Get(t)



//方法表达式调用
(T).Get(t)

//方法表达式调用

f1 := T.Get;f1(t)

//方法表达式调用
f2 := (T).Get;f2(t)


//如下方法表达式调用都是等价的

(*T).Set(&t,1)
f3 := (*T).Set;f3(&t,1)


通过方法值和方法表达式可以看到：go的方法底层是基于函数实现的，
只是语法格式不同，本质是一样的

3.3.4 方法集(method set)

命名类型方法接收这两种类型，一个值乐行，另一个是指针类型，
这个和函数是一样的，前者的形参是值类型，后者的形参是
指针类型。无论接收者是什么类型，方法和函数的实参传递都是
值拷贝。如果接收者是值类型，则传递的是值的副本；
如果接收者是指针类型，则传递的是指针的副本

接收者是Int类型的方法集合(method set):
func (i Int) Print()
func　(a Int) Max(b Int) Int


接收者是*Int 类型的方法集合(method set)


func (i *Int)Set(a Int)


类型的方法集总结如下：

(1) T类型的方法集是S
(2) *T类型的方法集是S和*S




3.3.5 值调用和表达式调用的方法集


具体类型实例变量直接调用其方法时，编译器会所调用方法进行
自动转换，即使接收者是指针的方法，仍然可以使用值类型变量
进行调用。

(1) 通过类型字面量显式的进行值调用和表达式调用，可以看到在这种情况下
编译器不会做自动转换，会进行严格的方法集检查

type Data struct{}

func (Data) TestValue(){}



3.4 组合和方法集

结构类型(struct)为go提供了强大的类型扩展，主要体现在两个方面：
第一，struct可以嵌入任意其他类型的字段
第二，struct可以嵌套自身的指针类型的字段。

这两个特性决定了struct类型有着强大的表达力，几乎可以表示任意
的数据结构。同时，集合结构类型的方法，"数据＋方法"
可以灵活地表达程序逻辑



3.4.1 组合

使用type定义的新类型不会继承原有类型的方法，有个特例就是命名结构类型，
命名结构类型可以嵌套其他的命名类型的字段，外层的结构类型
是可以调用嵌入字段类型的方法，这种调用既可以显式的调用，
也可以隐式的调用。这就是Go的"继承"
准确的说是Go的"组合"
因为Go语言没有继承的语义，结构和字段之间是"has a"的关系
而不是"is a"的关系
没有父子的概念，仅仅是整体和局部的概念，所以后续这种
嵌套的结构和字段的关系为组合


struct中的组合非常灵活，可以表现为水平的字段扩展，由于struct
可以嵌套其他struct字段，所以组合也可以分层次扩展。
struct类型中的字段称为"内嵌字段"

内嵌字段的访问和方法调用遵照的规约


内嵌字段的初始化和访问

struct的字段访问使用点操作符".",struct的字段可以嵌套很多层，
只要内嵌的字段是唯一的即可，不需要使用全路径进行访问。

可以使用z.a 代替z.Y.X.a

package main


type X struct{
	a int
}



type Y struct{
	X
	b int
}


type Z struct{
	Y
	c int
}


func main(){
	x := X{a:1}

	y := Y{
		X:x,
		b:2,
	}

	z := Z{
		Y:y,
		c:3,
}

	println(z.a, z.Y.a,z.Y.X.a)

	z = Z{}
	z.a = 2
	println(z.a,z.Y.a,z.Y.X.a)
}



在struct的多层嵌套中，不同嵌套层次可以有相同的字段，此时最好
使用完全路径进行访问和初始化。
在实际数据结构的定义中应该尽量避开相同的字段，以免在使用中出现歧义


package main


type X struct{
	a int
}


type Y struct{
	X
	a int
}


type Z struct{
	Y
	a int
}


func main(){
	x := X{a:1}
	y := Y{
		X:x,
		a:2,
}


	z := Z{
		Y:y,
		a:3,
	}

	println(z.a,z.Y.a,z.Y.X.a)


	z = Z{}

	z.a = 4
	z.Y.a =5
	z.Y.X.a =6

	println(z.a,z.Y.a,z.Y.X.a)
}


内嵌字段的方法调用

struct类型方法调用也可以使用点操作符，不同嵌套层次的字段可以有
相同的方法，外层变量调用内嵌字段的方法时也可以像嵌套字段的
访问一样使用简化模式。


如果外层字段和内层字段有相同的方法，则使用简化模式
访问外层的方法会覆盖内层的方法。即在简写模式下，
Go编译器优先从外向内逐层查找方法，同名方法中外层的方法能够
覆盖内层的方法。这个特性有点类似于面向对象编程中，子类覆盖
父类的同名方法


package main


import "fmt"


type X struct{
	a int
}


type Y struct{
	X
	b int
}


type Z struct{
	Y
	c int
}


func (x X) Print(){
	fmt.Printf("In X,a=%d\n",x.a)

}


func (x X) XPrint(){
	fmt.Printf("In X,a=%d\n",x.a)
}


func (y Y) Print(){
	fmt.Printf("In Y,b=%d\n",y.b)
}


func (z Z) Print(){
	fmt.Printf("In Z,c=%d\n",z.c)
	//显式的完全路调动内嵌字段的方法

	z.Y.Print()
	z.Y.X.Print()
}



3.4.2 组合的方法集



组合结构的方法集有如下规则


１．　若类型S包含匿名字段T,则S的方法集包含T的方法集合

２．若类型S包含匿名字段*T,则S的方法集包含T和*T方法集

３.不管类型S中嵌入的匿名字段是T还是*T,*s方法集总是包含
T和*T方法集合


３．５　函数类型

一种是函数字面量类型(未命名类型)，另一种是函数命名类型

函数字面量类型

有名函数和匿名

函数声明＝函数名＋函数签名


１．　函数也是一种类型，可以在函数字面量类型的基础上定义一种命名函数类型
２．　有名函数和匿名函数的函数起那么与命名函数类型的底层类型相同，
它们之间可以进行类型转换
3. 可以为有名函数类型添加方法，这种为一个函数类型添加方法的技巧很有效
４．　为有名函数类型添加方法，使其与接口打通关系，使用接口的地方
可以传递函数类型的变量，这位函数到接口的转换开启了大门



第４章　接口


接口是一个编程规约，也是一组方法签名的集合。Go的接口是非侵入式的设计
一个具体类型实现接口不需要在语法上显式地声明，只要具体类型的方法集
是接口方法集的超集，就代表该类型实现了接口

编译器在编译时会进行方法集的校验。
接口是没有具体实现逻辑的，也不能定义字段



变量和实例

实例，代表具体类型的变量，接口变量只有值和类型的概念，
所以接口类型变量仍然称为接口变量，接口内部存放的具体类型
变量被称为接口指向的"实例"
接口只有声明没有实现，所以定义一个新接口，通常
变成声明一个新接口，定义接口和声明接口二者通用，代表相同的意思


空接口

最常用的接口字面量类型就是空接口interface{},由于空接口的方法集
为空，所以任意类型都被认为实现了空接口，任意类型的实例都可以赋值或传递
给空接口，包括非命名类型的实例

注意

非命名了类型由于不能定义自己的方法，所以方法集为空，因此其类型变量
除了传递给空接口，不能传递给任何其他接口



４．１　基本概念


４．１．１　　接口声明


go语言的接口分为接口字面量和接口命名乐行，接口的声明使用interface关键字


in接口字面量类型的声明语法：

interface {
	MethodSignature1
}




接口命名类型使用type关键字声明

type InterfaceName interface{
	MethodSignature1
}



使用接口字面量的场景很少，一般只有空接口interface{}类型变量的声明
才会使用。

接口定义大括号内可以是方法声明的集合，也可以嵌入另一个接口
类型匿名字段，还可以是二者的混合。接口支持嵌入匿名接口字段，
就是一个接口定义里面可以包括其他接口


type Reader interface{
	Read(p []byte)(n int,err error)
}


type Writer interface{
	Write(p []byte)(n int,err error)
}


type ReadWriter interface{
	Reader
	Writer
}


type ReadWriter interface{
	Reader
	Write(p []byte)(n int,err error)
}


type ReadWriter interface{
	Read(p []byte) (n int,err error)
	Write(p []byte)(n int,err error)
}


方法声明

函数签名是函数的字面量类型，函数签名是不包括函数名的，而函数声明
是值带上函数名的函数签名。
接口定义使用方法声明，而不是方法签名，因为方法名是接口的组成部分


方法声明　＝　方法名＋方法签名




声明新接口类型的特点：

１．　接口的命名一般以"er"结尾
２．　接口定义的内部方法声明不需要func引导
３．　在接口定义中，只有方法声明没有方法实现



４．１．２　j接口初四花

单纯地声明一个接口变量没有任何意义，接口只有被初始化为具体的类型时才有意义

接口作为一个胶水层或抽象层，起到抽象和适配的作用。
没有初始化的接口变量，其默认值是nil

接口绑定具体类型的实例的过程称为接口初始化，
接口变量支持两种直接初始化方法，具体ｒｕｘａ　

实例赋值接口


接口被初始化后，调用接口的方法就相当于调用接口绑定的具体类型的方法，
这就是接口调用的语义


接口变量赋值接口变量


已经初始化的接口类型变量a直接赋值给另一个接口变量b,要求b的方法集是a的
方法集的子集。

此时go编译器会在编译时进行方法集静态检查。

这个过程也是接口初始化的一种凡是，此时接口变量b绑定的具体实例是接口变量a
绑定的具体实例的副本


4.1.3 接口方法调用


接口方法调用和普通的函数调用是有区别的，接口方法调用的最终地址是在运行期决定的
将具体类型变量赋值给接口后，会使用具体而理性的方法指针初始化接口变量，
当调用接口变量的方法时，实际上是间接地调用实例的方法。接口方法调用
不是一种直接的调用，有一定的运行开销

直接调用未初始化的接口变量的方法会产生panic


4.1.4 接口的动态类型和静态类型

动态类型


接口绑定的具体实例的类型称为接口的动态类型。接口可以绑定不同类型的实例，
所以接口的动态类型是随着其绑定的不同类型实例而发生变化的


4.2 接口运算

接口是一个抽象的类型，

编程过程中有时需要确认已经已经初始化的接口变量指向实例的具体类型是什么
也需要检查运行时的接口类型


go语言提供两种语法结构来支持这两种需求，分别是类型断言和接口类型查询



4.2.1 类型断言( Type Assertion)

接口类型断言的语法形式

i.(TypeName)

i必须是接口变量，如果是具体类型变量会报错

TypeName可以是接口类型名，也可以是具体类型名


接口查询的两层含义

(1) 如果TypeName是一个具体类型名，则类型断言用于判断
接口变量i绑定的实例类型是否就是具体类型TypeName

(2) 如果TypeName是一个接口类型名，则类型断言用于判断
接口变量i绑定的实例了TypeName接口


接口断言的两种语法表现:

直接赋值模式如下

o :=i.(TypeName)

语义分析：

1.TypeName是具体类型名，此时如果接口i绑定的实例类型
就是具体类型TypeName,则变量o的类型就是TypeName,
变量o的值就是接口绑定的实例值的副本(当然实例可能是
指针值，那就是指针值的副本)
2.TypeName是接口类型名，如果接口i绑定的实例类型
满足接口类型TypeName,则变量o的类型就是接口类型
TypeName,o底层绑定的具体类型实例是i绑定的实例的
副本
3. 如果两种情况都不满足，则程序抛出panic


comma,ok表达式模式

if o,ok := i.(TypeName);ok {}


4.2.2 类型查询(Type Switches)

接口类型查询的

switch v:=i.(type){
case type1:
	xxx
case type2:
	xxx
default:
	xxx


语义分析

接口查询有两层汉所以，一是查询一个接口变量底层板顶的底层变量的具体类型是
什么，二是查询接口变量绑定的底层变量是否还实现了其他接口


(1) i必须是接口类型


具体类型实例的类型是静态的，在类型声明后就不再变化，
所以具体类型的变量不存在类型查询，类型查询一定是对一个
接口变量进行操作。上文中的i必须是接口变量，
如果i是未初始化接口变量，则v的值是nil


var i io.Reader

switch v:=i.(type) {
	// 此处i是为初始化的接口变量，所以v为il
case nil:
	fmt.Printf("%T\n",v) // nil
default:
	fmt.Printf("default")

}


2. case字句后面可以跟非接口类型名，也可以跟接口类型名
匹配是按照case子句的顺序进行的

如果case后面是一个接口乐行名，且接口变量i绑定的实例类型实现了
该接口类型的方法，则匹配成功，v的类型是接口类型，
v底层绑定的实例是i绑定具体类型实例的副本


如果case后面是一个具体类型名，且接口变量i绑定的实例类型和该具体
类型相同，则匹配成功，此时v就是该具体类型变量，
v的值是i绑定的实例值的副本

fallthrough不能在Type Switch语句中使用

注意

go和很多标准库使用的格式

switch i:= i.(type){}


推荐的方法是将i.(type)赋值给一个新变量


switch v:= i.(type){}

类型查询和类型断言


(1) 类型查询和类型断言具有相同的用以，只是语法格式不同
二者都能判定的实例的具体类型，以及判断接口变量绑定的实例是否满足另一个接口类型

(2) 类型查询使用case字句一次判断多个类型，类型断言一次只能
判断一个类型，当然类型断言也可以使用if else语句达到同样的效果


4.2.3 接口优点和使用形式


接口优点：

(1) 解耦：
复杂系统进行垂直和水平的分割是常用的设计手段，在
层与层之间使用接口进行抽象和解耦是一个好的编程内测了
(2)实现泛型
由于现阶段Go语言不支持泛型，使用空接口作为函数或方法
参数能够用在需要泛型的场景中

接口使用形式

接口类型是"第一公民"，可以用在任何使用变量的地方，使用灵活，方便解耦，
1. 作为结构内嵌字段
2. 作为函数或方法的形参
3. 作为函数或方法的返回值
4.作为其他接口定义的嵌入字段

4.3 空接口

4.3.1 基本概念

没有任何方法的接口，称为空接口。空接口表示为interface{}
系统中任何类型都符合空接口的要求，空接口有点类似Java语言中的Object,
不同点，go中的基本类型int,float,string也符合空接口。
go的类型系统里面没有类的概念，所有的类型都是一样的身份，
没有java里面对基本类型的开箱和转箱的操作

所有的类型都是统一的。
go语言的的空接口类似c语言中的void*
只不过void*是指针，而go语言的空接口内部封装了指针而已

4.3.2 空接口的用途

空接口和泛型

go语言没有泛型，如果一个函数需要接收任意类型的参数，则参数类型可以
使用空接口类型，这是弥补没有泛型的一种手段

//典型的就是fmt标准包的print函数

func Fprint(w io.Writer,a ...interface{}) (n int,err error)

空接口和反射


空接口是发射实现的基础，反射库就是将相关具体的类型转换并赋值给空接口后
才去处理，
4.3.3 空接口和nil

p133



