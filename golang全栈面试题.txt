
go基础语法


使用golang编程的好处

１．支持环境采用类似于动态语言的模式．例如，类型推断(x:=0是int类型的变量x的有效声明)

２．　编译时间很快

３．InBuilt并发支持：轻量级进程(通过goroutine)，通道，select语句

４．　简洁安全
５．　支持接口和类型嵌入
６．生成静态链接的本机二进制文件，没有外部依赖项


一个包是否可以在一个源文件里面多次引用？


一个go源文件可以多次引入同一个包．但是每次的引入名称必须不同．这些相同的包引入引用着同一个包实例


简述内置的print和println函数与fmt和log保准库包中相应的打印函数有什么区别？

内置的print/println函数总是写入标准错误．fmt标准包里的打印函数总是写入
标准输出．log标准包里的打印函数会默认写入标准错误，然而也可以通过
log.SetOutput函数来配置


内置print/println函数的调用不能接受数组和结构体参数


对于组合类型的参数，内置的print/println函数将输出参数的底层值部的
地址，而fmt和log标准库包中的打印函数将输出参数的字面值


目前go1.12 ,对于标准编译器，调用内置的print/println函数不会使
调用参数引用的值逃逸到堆上，而fmt和log标准库包中的打印函数将使
调用参数引用的值逃逸到堆上

如果一个实参有String() strign或Error() string方法，那么fmt和log
标准库包里的打印函数在打印参数时会调用这两个方法，
而内置的print/println函数则会忽略参数的这些方法



内置的print/println函数不保证在未来的go版本会继续存在



什么是byte?什么是rune?如何将[]byte和[]rune类型的值转换为字符串？

在golang,byte是uint8类型的一个别名．
byte和uint8是相同的类型.rune和int32属于同样类似的关系

一个rune通常被用来存储一个Unicode码点
[]byte和[]rune类型的值可以显式地直接转换成字符串，反之亦然



golang中数组和切片之间的区别？


Slice是go中的数组的包装器．总是优先使用切片而不是数组．极少情况下数组
会有溢出？一种情况是数组的大小是固定的(比如存储IPv4地址)

还有一种是当我们不希望函数修改原始副本时，我们可能会使用数组．
但是即使在这种情况下，也应该有一种传递切片的方法


在以下两个切片声明中有什么什么区别,哪一个更可取？


var a []int

a := []int{}


如果未使用切片，则第一个声明不会分配内存，因此首选此声明方法


什么可以／不可以作为方法的接收者？


结构体，指向结构体的指针，甚至内置类型的别名
都可以充当接收者，甚至函数也可以是接收器


我们不能使用以下东西作为接收类型

方法，如果我们在对象类型上定义方法，它就不能像普通函数一样用作接手方类型

接口，在go中，接口为类型了定义了一组可能的操作．它们没有定义实际的实现．
因此它们不能用作方法的接收者，因为方法是关于实现的


值接收者和指针接收者的区别

方法能给用户自定义的类型添加新的行为．它和函数的区别在于方法有一个接收者，
给一个函数添加一个接收者，那么它就变成了方法．
接收者可以是值接收者，也可以是指针接收者


在调用方法的时候，值类型既可以调动值接收者的方法，也可以调动指针接收者的方法
指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法


不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型


函数和方法　　值接收者２　　指针接收者



值类型调用者　　　方法会使用调用者的一个副本，类似于"传值"　　使用值的引用来调用方法，
上例中，p1.GetAge()实际上是(&p1).GetAge()

指针类型调用者　　　指针被解引用为值，上例中，p2.GetAge()实际上是(*p).GetAge()

		实际上也是"传值"，方法里的操作会影响到调用者，类似于指针传参，拷贝一份指针


如果实现了接收者是值类型的方法，会隐含地实现了接收者是指针类型的方法


如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身


通常我们使用指针作为方法的接收者的理由：


使用指针方法能够修改接收者指向的值


可以避免在每次调用昂发时复制该值，在值的类型为大型结构体时，这样做更加高效


我们是使用值接收者还是指针接收者，不是由该方法是否修改了调用者(也就是接收者)来决定，
而是应该基于该类型的本质


如果类型具备"原始的本质"，它的成员都是由go语言内置的原始类型，如字符串，整型等
那就定义值接收者类型的方法，像内置的引用类型，
如slice,map,interface,channel,这些类型比较特殊


声明它们的时候，实际上是创建了一个header,对于它们也是直接定义值接收类型的方法，
这样，调用函数时，是直接copy了这些类型的header,而header本身就是为复制设计的



如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义
指针接收者的方法．比如go源码里的文件结构体(struct　File)就不应该被复制，
应该只有一份实体


接口值的零值是指动态类型和动态值都为nil

当且仅当这两部分的值都为nil的情况下，这个接口值就才会被认为接口值==nil



哪些类型不支持比较

映射(map)  切片　　函数　　包含不可比较字段的结构体类型


元素类型为不可比较类型的数组类型　
不支持比较的类型不能用做映射类型的键值类型

尽管映射，切口和函数值不支持比较，但是它们的值可以与类型不确定的nil标识符比较


如果两个接口值的动态类型相同且不可比较，那么在运行时比较这两个接口的值会产生一个panic


go语言中哪些类型的值可以被取地址，哪些不可以被取地址？


以下的值是不可以寻址的：
字符串的字节元素
映射元素
接口值的动态值(类型断言的结果)
常量值
字面值
声明的包级别函数
方法(用做函数值)
中间结果值
函数调用
显式值转换
各种操作，不包含指针解引用(deference)操作，但是包含：

数据通道接收操作
子字符串操作
子切片操作
加法，减法，乘法，以及除法等

注意，&T{}在Go里面是一个语法糖，它是tmp:=T{}:(&tmp)的简写形式
所以&T{}是合法的，并不代表字面值T{}是可寻址的

以下的值是可寻址的，因此可以被取地址：

变量
可寻址的结构体的字段
可寻址的数组的元素
任意切片的元素(无论是可寻址切片或不可寻址切片)
指针解引用(dereference)操作


为什么映射元素不可被取地址？

如果映射元素可以被取地址，则每个映射元素的地址在它的生命期内必须保持不变
这阻碍了go编译器在实现映射时使用更加有效的算法

对于标准编译器，映射元素的内部地址在运行时刻有可能发生改变

为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此


切片的内部类型是一个结构体，类似于

struct{
	elements unsafe.Pointer //引用着一个元素序列
	length int
	capacity int
}


每一个切片间接引用一个元素序列，尽管一个非空切片是不可取地址的，它的内部元素
序列需要开辟在内存中的某处，因为必须是可取地址的．
取一个切片的元素地址事实上是取内部元素序列上的元素地址．
这就是为什么不可寻址的飞空切片元素是也可以被取地址的



哪些类型是值类型，哪些是引用类型？


值类型:基本数据类型,int,float,bool,string,以及数组和struct
引用类型:指针,slice,map,chan等都是引用类型


go struct 能不能比较?

相同struct类型的可以比较
不同struct类型的不可以比较,编译都不过,类型不匹配


为什么使用空sturct{}?


如果要保存一些内存,可使用空结构.空结构不会为其获取任何内存


a:=struct{}{}

println(unsafe.Sizeof(a))

1.如果使用的是map,而且map又很长,通常会节省不少资源
2. 空struct{}也在向别人表明,这里并不需要一个值


一下是一些有用的示例:


在map里节省资源的用途

set := make(map[string]struct{})

for _, value:= range []string{"apple","orange","apple"}{
	set[value] = struct{}{}
}
fmt.Println(set)

使用seen哈希,就像遍历MAP时一样

seen := make(map[string]struct{})
for _,ok := seen[v]; ok{
	//First time visiting a vertex,
	seen[v] = struct{}{}
}


构建对象时只对一组方法感兴趣而没有中间数据,或不打算保留对象状态时

在下面的示例中,无论方法是在相同的情况下调用(情况#1)还是在两个不同的对象上
调用(情况#2) 它都没有区别:


type Lamp struct{}


func (l Lamp) On(){
	println("on")
}


func (l Lamp) Off() {
	println("Off")

}


func main(){
	var lamp Lamp
	lamp.On()
	lamp.Off()



	Lamp{}.On()
	Lamp{}.Off()
}

当你需要一个通道来发出事件信号时,却不需要发送任何数据.这个事件也不是最后一个,
在这种情况下,将使用close(ch)内置函数






