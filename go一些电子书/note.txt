

go是一种新的语言，一种并发的，带垃圾回收的，快速编译的语言

１．它可以在一台计算机上用几秒钟的时间编译一个大型的go程序
２．go为软件构造提供了一种模型，它使依赖分析更加容易，且避免了大部分c风格include文件与库的开头
３．　go是静态类型的语言，它的类型系统没有层级。因此用户不需要在定义类型之间的关系上话费时间，
这样感觉其类比典型的面向语言更轻量级
４．go完全是垃圾回收型的语言，并为并发执行与通信提供了基本的支持


按照其设计，go打算为多核机器上系统软件的构造提供一种方法


go是一种编译型语言，它集合了解释型语言的游刃有余，动态类型语言的
开发效率，以及静态类型的安全性。

它也大打算称为现代的，支持网络与多核计算的语言
要满足这些目标，需要解决一些语言上的问题：
一个富有表达能力但轻量级的类型系统，
并发与垃圾回收机制，严格的依赖规范等

这些无法通过库或工具解决好的，

GOPATH与工作空间

在安装GOPATH这个目录，用来存放go源码，go的可运行文件，
自己相应的编译之后的文件。所以有三个目录:src,bin,pkg


从go1.8开始，GOPATH环境变量现在有一个默认值，
如果它没有被设置。
它在Unix上默认为$HOME/go
在Windows上默认为%USERPROFILE%/go


GOPATH设置


go命令依赖一个重要的环境变量：$GOPATH

GOPATH允许多个目录，当有多个目录树，请注意分隔符，多个目录的
时候Windows是分号，Linux系统是冒号，当有多个GOPATH时，
默认会将go get的内容放在第一个目录下


以上$GOPATH目录约定有３个子目录

１．src存放源代码(比如，.go,.c,.h等)
２．pkg编译后生成的文件(比如.a)
3. bin编译后生成的可执行文件(可以把此目录加入到$PATH变量中，
如果有多个gopath,那么使用${GOPATH//://bin:}/bin添加所有的bin目录)


代码目录结构规划


GOPATH下的src目录就是开发程序的主要目录，所有的源码都是放在这个目录下
，那么一般我们的做法就是一个目录一个项目，

例如:$GOPATH/src/mymath表示mymath这个应用包或可执行应用，

这个根据package是main还是其他来决定，
main的话就是可执行应用，其他对的话就是应用包，

所以当新建应用或一个代码包时都是在src目录下新建一个文件夹，
文件夹名称一般是代码包名称，当然也允许多级目录，例如在src下面新建了目录

$GOPATH/src/github.com/astaxie/beedb那么这个包路径
就是"github.com/astaxie/beedb"，包名称是最后一个目录beedb

写一个应用包

这样我的应用包目录和代码已经新建完毕，注意：一般建议package的名称和目录
名保持一致


编译应用

已经建立了自己的应用包，如何进行编译安装？有两种方法进行安装

１．　只要进入对应的包目录，然后执行go install,就可以安装了
2. 在任意的目录执行如下代码go install　mymath


.a文件是应用包，如何调用？

仙剑一个应用程序来调用这个应用包


新建应用包mathapp

cd $GOPATH/src
mkdir mathapp

cd mathapp
vim main.go

$GOPATH/src/mathapp/main.go


package main

import (
"mymath"
"fmt"
)

func main(){
	fmt.Printf("Hello,world! Sqrt(2)=%v \n",mymath.Sqrt(2))
}

可以看到这个的package是main，import 里面调用的包是mymath,这个就是相对于
$GOPATH/src路径，如果是多级目录，就在import里面引入多级路，
如果你有多个GOPATH,也是一样，go会自动在$GOPATH/src中寻找


如何编译程序呢？进入该应用目录，然后执行go build,
那么在该目录下面会生成一个mathapp的可执行文件

./mathapp

如何安装应用，进入该目录执行go install，那么在$GOPATH/bin/下增加了
一个可执行文件mathapp,还记得把$GOPATH/bin加到我们的PATH里面了，
这样可以在命令行输入如下的命令就可以执行

matapp


这里展示如何编译和安装一个可运行的应用，以及如何设计我们的目录结构


获取远程包

go语言有一个获取远程包的工具,go get,


go get github.com/astaxie/beedb

go get -u参数可以自动更新包，而且当go　get的时候自动获取该包依赖的
其他第三方包

通过这个命令可以获取相应的源码，对应的开源平台采用不同的源码控制工具，
例如github 采用git


$GOPATH----src----github.com----astaxie-----beedb



$GOPATH----pkg-----相应平台----github.com----astaxie----beedb.a


go get本质上可以理解为首先第一步是通过源码工具clone代码到src下面

然后执行go install

在代码中如何使用远程包，跟本地包一样，只要在开头加上相应路径即可


程序的整体结构


mygo的目录结构如下

bin/
	mathapp


pkg/
	平台名/如: darwin_amd64, linux_amd64
			mymath.a
			github.com/	
				astaxie/	
					beedb.a


src/

	mathapp
		main.go

	mymath/
		sqrt.go
	github.com/
		astaxie/
			beedb/
				beedb.go
				util.go


从上面的结构可以清晰看到，bin目录下面存的是编译之后可以执行的文件，
pkg下面存放的是应用包

src下面保存的是应用源代码

go 命令

go build ，主要用于编译代码。在包的编译过程中，若有必要
会同时编译与之相关联的包

如果是普通包，当执行go build 之后，它不会产生任何文件。如果需要
在$GOPATH/pkg下生成相应的文件，那就得执行go install

2.如果main包，当你指定go build之后，它就会在当前目录下生成一个
可执行文件，如果你需要在$GOPATH/bin下生成相应的文件，
需要执行go install，或使用go build -o 路径/a.exe

3. 如果某个项目文件加下有很多文件，而你只想编译某个文件，就可
在go build之后加上文件名，例如go build a.go
go build命令默认会编译当前目录下的所有go文件

４．你也可以指定编译输出的文件名。
例如mathapp应用，我们可以指定go build -o astaxie.exe
默认情况下是你的package名(非main包)或第一个原文件的文件名(main包)


实际上，package名在go语言规范中指代码中"package"后使用的名称
此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名


go build会忽略目录下"_"或"."开头的go文件

如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的
操作系统后缀来命名文件。
例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件

go build的时候会选择型地编译以系统名结尾的文件


go build -o 指定输出的文件名，可以带上路径，例如，go build -o a/b/c

go build  -i 安装相应的包，编译　go install
go build  -a更新全部已经是最新的包的，但是对标准包不适用
go build 　-n把需要执行的编译命令打印出来，但是不执行，
这样就可以很容易的直到底层是如何运行的

go build -p n指定可以并行可运行的编译数目，默认是CPU数目
go build -race开启编译的时候自动检测数据竞争的情况，
目前只支持64位的机器

go build -v打印出来当我们正在编译的包名

go build -work打印出来编译时的临时文件夹名称，并且
如果已经存在的话就不要删除

go build -x 打印出来执行的命令，其实就是和-n的结果类似，
只是这个会执行


go build 　-ccflags 'arg list'　传递参数给5c,6c,8c调用

go build  -compiler name　指定相应的编译器，gccgo还是gc

go build -gccgoflags 'arg list' 传递参数给gccgo编译连接调用

go build -gcflags 'arg list'传递参数给5g,6g,8g调用


go build 　-installsuffix suffix为了和默认的安装包区别开发来
采用这个前缀来重新安装哪些依赖的包

go build -race的时候默认已经是 -installsuffix race,
大家可以通过go build -n命令来验证

go build -ldflags　'flag list' 传递参数给5l,6l,8l调用


go build -tags 'tag list'设置在编译的时候可以适配的那些
tag,详细的tag限制参数里


go clean,用来移除当前源码包和关联源码里面编译生成的文件。
这些文件包括


_obj/  旧的object目录，由Makefiles遗留
_test/　	旧的test目录,由Makefiles遗留
_testmain.go	旧的gotest文件，由Makefiles遗留
test.go  	旧的test记录，由Makefiles遗留
build.out 	旧的test记录，由Makefiles遗留
*.[568ao]	object文件，由Makefiles遗留

DIR(.exe)	由go build 产生
DIR.test(.exe) 	由 go test -c产生
MAINFILE(.exe) 由go build　MAINFILE.go产生

*.go 	由SWIG产生

我一般都是利用这个命令清楚编译文件，然后github递交源码，在本机
测试的时候这些编译文件都是和系统相关的，但是对于源码管理没有必要


go clean =i -n

go clean -i　清除关联的安装的包和可运行恩建，也就是通过go install安装的文件
go clean -n 把需要执行的清楚命令打印出来，但是不执行，这样就可以很容易
的知道底层是如何运行的

go clean -r 循环的清除在import中引入的包
go clean -x打印出来执行的详细命令，其中就是-n打印的执行版本


go fmt,可以格式化写好的代码文件，使得写代码的时候不需要关心格式，

只需要在写完之后执行go fmt<文件名>.go

你的代码就被修改成标准格式，
开发工具里面一般都带来保存时候自动格式化功能，
这个功能其实在底层就是调用了go fmt


使用go fmt命令，其实是调用了go fmt,而且需要参数-w

否则格式化结果不会写入文件。

gofmt-w -l src，可以格式化整个项目


所以go fmt是gofmt的上一层一个包装的命令，我们想要更多的个性化的
格式化可以参考gofmt

gofmt 的参数介绍


gofmt -l显示那些需要格式化的文件
gofmt -w 把改写后的内容直接写入到文件中，而不是作为结果打印到
标输出
gofmt -r　添加形如"a[b:len(a)->a[b:]]"的重写规则，方法我们做
	批量替换

gofmt -s 简化文件中的代码
gofmt -d 显示格式化前后的diff而不是写入文件，默认是false
gofmt  -e 打印所有的语法错误到标准输出。如果不使用此标记，
	则只会打印不同行的前１０个错误

gofmt -cpuprofile 支持调试模式，写入相应的cpufile到指定的文件

go get ,用来动态获取远程代码包。这个命令在内部实际上分成了两步
操作：
第一步是下载源码包，
第二步，执行go install

下载源码包的go工具会自动根据不同的域名调用不同的源码工具

所以为了go get能正常工作，你必须确保安装了合适的源码管理工具，
并同时把这些命令加入你的PATH中。
其实go get支持自定义域名的功能

go get -d 只下载不安装
go get -f　只有在你包含了-u参数的时候才有效，不让-u
	去验证import中的每一个都已经获取了，这对于本地fork
	的包特别哟用

go get -fix在获取源码之后先运行fix,然后再去做其他的事情

go get -t同时也下载需要为运行测试所需要的包
go get -u强制使用网络去更新包和它的依赖包
go get -v显示执行的命令

go install ,这个命令在内部实际上分成了两步操作：
１．第一步是生成结果文件(可执行文件或.a包)
２．第二步会把编译好的结果移到$GOPATH/pkg或$GOPATH/bin

参数支持go build的编译参数。大家只要记住一个参数-v就好了，这个
随时随地的可以查看底层的执行信息


go test  ,执行这个命令，会自动读取源码目录下名为*_test.go的文件
生成并运行测试用的可执行文件


默认情况下，不需要任何的参数，它会自动把你源码包下面所有test
文件测试完毕，当然你也可以带上参数

go test  -bench regexp，执行相应的benchmarks，例如　-bench=.
go test  -cover 开启测试覆盖率
go test  -run regexp 只运行regexp匹配的函数，例如 -run=Array
	那么就执行包含有Array开头的函数

go test  -v显示测试的详细命令


go tool 下面下载聚集了很多命令，

go tool fix .用来修复以前老版本的代码到新版本，
例如go1之前老版本的代码转化到go1,例如API的变化

go tool vet directory|files 用来分析当前目录的代码是否都是
正确的代码，例如是不是调用fmt.Printf里面的参数不正确，例如
函数里面提前return了然后出现了无用代码之类的

go generate ,用于在编译前自动化生成某类代码。
go generate 通过分析源码中特殊的注释，然后执行相应的名。

go语言基础

go是一门类似c的编译型语言，它的编译速度非常快。

２５个关键字

break,default,func,interface,select
case,defer,go,map,struct
chan,else,goto,package,switch
const,fallthrough,if,range,type
continue,for,import,return ,var



使用var关键字是go最基本的定义变量方式，

_(下划线)　是个特殊的变量名，任何赋予它的值都会被丢弃

_,b := 34,35

go对于已经声明但未使用的变量会在编译阶段操作，
声明了i但未使用

所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时
无法改变该值。
在go程序中，常量可定义为数值，布尔值或字符串等类型

go中的字符串都是采用utf-8字符集编码。
字符串是用一对双引号(")或反引号(`)括起来定义，它的类型是string


错误类型

go内置有一个error类型，专门用来处理错误信息，go的package
里面还专门有一个包errors来处理错误


err := errors.New("emit macho dwarf:elf header corrupted")
if err != nil{
	fmt.Print(err)
}

go数据底层的存储

分组声明

在go语言中，同时声明多个常量，变量，或导入多个包时，可采用分组的
方式进行声明


iota枚举

go里面有一个关键字iota,这个关键字用来声明enum的时候采用，它
默认开始值是0,const每增加一行加１

除非被显式设置为其他值或iota,每个const分组的第一个常量
被默认设置为它的０值，第二及后续的常量被默认为它前面那个常量的值
如果起那么那个常量的值为iota，则它也被设置为iota

g程序设计的一些规则

１．大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有
变量；小写字母开头的就是不可导出的，是私有变量
２．大写字母开头的函数也是一样，相当于class中带public关键词
的公有函数；小写字母开头的就是有private关键词的私有函数



array,slice,map


array就是数组

var arr [n]type

在[n]type中，n表示数组的长度，type表示存储元素的类型。
对数组的操作和其他语言类似，都是通过[]来进行读取或赋值

var arr [10]int //声明一个int类型的数组
arr[0] = 42 //数组下标是从0开始的
a

由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型
数组也就不能改变长度。数组之间的赋值是值的赋值，
即当把一个数组作为参数传入函数的时候，传入的其实是该数组的
副本，而不是它的指针。如果要使用指针，那么就需要用到slice

数组可以使用另一种　:=来声明
go支持嵌套数组，即多维数组

//声明一个二维数组，该数组以两个数组作为元素与，其中
//每个数组中又有４个int类型的元素

doubleArray := [2][4]int{1,2,3,4}, [4]int{5,6,7,8}}

可以简化，直接忽略内部的类型


easyArray := [2][4]int{{1,2,3,4},{5,6,7,8}}

slice

在很多应用场景中，数组并不能满足我们的需求。
在初始定义数组时，我们并不知道需要多大的数组，
因此我们就需要"动态数组"。在go里面这种数据结构叫做slice

slice并不是真正意义上的动态数组，而是一个引用该类型。
slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度

var fslice []int

slice := []byte{'a',"b"}

slice可以从一个数组或一个已经存在的slice中再次声明.slice通过
array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j],它的长度是j
j-i


//声明一个含有10个元素元素类型为byte的数组

var ar =[10]byte{"a"}

注意slice和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或
使用...自动计算长度，而声明slice时，方括号内没有任何字符

slice是引用类型，所以当引用改变元素的值时，其它的所有引用都会改变该值，

结构体包含了三个元素：
１．一个指针，指向数组中slice指定的开始位置
２．长度，即slice的长度
３．　最大长度，也就是slice开始位置到数组的最后位置的长度

slice有几个有用的内置函数

１．　len获取slice的长度
2. cap获取slice的最大容量
３．　append向slice里面追加一个或多个元素，然后返回一个和slice一样类型的slice
4. copy函数copy从源slice的src中复制元素到目标dst,并且返回复制的元素的个数

注：append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其他slice\

但当slice中没有剩余空间(即(cap-len)==0)时，此时将动态分配新的数组空间。
返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；
其他引用数组的slice则不受影响

map的读取和设置也类似slice一样，通过key来操作，只是slice的index
只能是'int'类型，而map多了很多类型，可以是int,可以是string
及所有完全定义了==与!=操作的类型

声明一个key是字符串，值为int的字典，这种方式的声明需要在使用前使用make初始化

map使用过程中要注意

1. map是无序的，每次打印出来的map都会不一样，它不能通过index获取，
而必须通过key获取

２．map的长度是不固定的，也就是和slice一样，也是一种引用类型
３．　内置的len函数同样适用于map,返回map拥有的key的数量
４．　map的值可以很方便的修改，通过nubmers["one"] = 11可以人很容易的　
把key为one的字典改为11
5. map和其他基本型别不同，它不是thread-safe,在多个go-routine存取时，
必须适用mutex lock机制

map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key
的方式


通过delete删除map的元素

初始化一个字典
map也是一种引用类型，如果两个map同时指向一个底层，那么一个改变，
另一个也相应的改变

m := make(map[string]string)
m["hello"] = "Bonjour"
m1 := m
m1["Hello"] ="salut"


make,new操作


make用于内建类型(map,slice,channel)的内存分配。new用于各种类型的内存分配

内建函数new本质上说跟其他语言中的同名函数一样：new(T)分配了零值
填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。
用go的术语来说，它返回一个指针，指向新分配的类型T的零值。

new返回指针

内建函数make(T,args)与new(T)有着不同的功能，make只能创建slice,
map和channel,并且返回一个有初始值(非零)的T类型，而不是*T

本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前
必须被初始化。例如，一个slice,是一个包含指向数据(内部array)的指针
长度和容量的三项描述符；
在这些项目被初始化之前，slice为nil.对于slice,map和channel来说，
make初始化了内部的数据结构，填充适当的值

make返回初始化后的(非零)值

零值

关于"零值"，所并非是空值，而是一宗变量未填充前的默认值，通常为0

函数是go的核心设计，通过关键字func来声明

1.关键字func用来声明一个函数funcName
2.函数可以有一个或多个参数，每个参数后面带有类型，通过,分隔
3.函数可以返回多个值
４．　上面返回值声明了两个变量output1和output2,如果你不想声明也可以，
直接就两个类型
５．如果只有一个返回值且不声明返回值变量，那么你可以省略包含返回值的括号
６．如果没有返回值，那么就直接省略最后的返回信息
７．　如果有返回值，那么必须在函数的外层添加return语句

多个返回值

go语言比c更先进的特性，其中一点就是函数都能够返回多个值

go函数支持变参。接受便餐的函数是有着不定数量的参数的。
为了做到这点，首先需要定义函数使其接受变参：

func myfunc(arg...int){}

arg...int告诉go这个函数借书不定数量的参数。
在函数体中，变量arg是一个int的slice

for _,n := range arg{
	fmt.Printf("And the number is :%d\n",n)}

传值与传指针

当我们传一个参数值到被调用函数里时，实际上是传了这个值的一份copy,
当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，
因为数值变化只作用在copy上

变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的
内存。需要将x所在地址&x传入函数，并将函数的餐胡的类型由int改为*int
，即为指针乐行，才能在函数中修改x变量的值。
此时参数仍然是按copy传递的，只是copy的是一个指针

传指针的好处

１．传指针使得多个函数能操作同一个对象
２．传指针比较轻量级(8bytes),只是传内存地址，我们可以用指针传递
体积较大的结构体。如果用参数值传递的话，在每次copy上吗就会花费
相对较多的系统开销(内存和时间)
所以当你要传递大的结构体是，用指针会很有效率
３．　go语言中channel,slice,map这三种类型的实现机制类似指针，
所以可以直接传递，而不用取地址后传递指针
如果函数需要改变slice的长度，则仍需要取地址传递指针

defer

go语言中的有种，延迟(fefer)语句，你可以在函数中添加多个defer语句
当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。
特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，
在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题


函数作为值，类型

在go中函数也是一种变量，我们可以通过type来定义它，
它的类型就是所有拥有相同的参数，相同的返回值的一种类型


声明了一个函数类型

函数当做值和类类型在一些通用接口的时候非常有用


Panic和Ｒecover


panic
是一个内建函数，可以中断原有的控制流程，进入一个panic状态中。当函数
F调用panic，函数F的执行被中断，但是F中的延迟函数会正常执行，然后
F返回到调用它的地方。在调用的地方，F的行为就像调用了panic.
这一过程继续向上，直到发生panic的goroutine中所有调用的函数返回，
此时程序退出。panic可以直接调用panic产生。也可以由运行时错误产生，
例如访问越界的数组


Recover

是一个内建的函数，可以让panic状态的goroutine恢复过来。recover仅
在延迟函数中有效。在正常的执行过程中，调用recover会返回nil,
并且没有任何效果。如果当前的goroutine陷入panic状态，调用recover
可以捕获到panic的输入值，并且恢复正常的执行

main函数和init函数

go里面有两个保留的函数：
init函数(能够应用于所有的package)
main函数(只能应用于package main)

这两个函数在定义时不能有任何的参数和返回值。
虽然一个package里面可以写任意多个init函数，但这无论是对于可读性
还是以后的可维护性来说，我们都强烈建议用于在一个package中每个
文件只写一个init函数


go函数会自动调用init()和main(),所以你不需要在任何地方调用
这两个函数。每个package中的init函数都是可选的，但是package main
就必须包含一个main函数

程序的初始化和执行都起始于main包。如果main包还导入了其他的包，
那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，
那么它只会被导入一次(例如很多包可能会用到fmt包，但它只会被导入一次，
因为没有必要导入多次)
当一个包被导入时，如果该包还导入了其他的包，那么会先将其他包导入进来
然后再对这些包中的包级常量和变量进行初始化，接着执行init函数(如果有的话)
等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行
初始化，然后执行main包中的init函数(如果存在的话)
最后执行main函数


声明的函数类型在这个地方做了一个参数







