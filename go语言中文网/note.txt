http://c.biancheng.net/view/1.html


并发编程已经成为程序员的基本技能

Goroutine是go显著的特征。可以用类协程的方式来处理并发单元，
在运行时层面做更深度的优化处理。
无须处理回调，无须关注线程切换，只需要一个关键字


搭配通道(channel)实现CSP模型。将并发单元间的数据耦合拆解开来，

内存分配  tcmalloc，专门为并发而设计的高性能内存分配组件

内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器
而修改的内容，内存分配器完整保留了tcmalloc的原始架构。使用cache
为当前执行线程提供无锁份额配，多个central在不同线程间平衡内存
单元复用。在更高层次里，heap管理着大块内存，用以切分不同等级
的复用内存块。快速分配和二级内存平衡机制，让内存分配器能
优秀地完成高压力下的内存管理任务

垃圾回收
静态链接
标准库


Go语言为并发而生

go语言的并发基于goroutine的，goroutine类似于线程，但并非线程，
可以将goroutine理解为一种虚拟线程。go语言运行时会参与调用goroutine
并将goroutine合理地分配到每个CPU中，最大限度地使用CPU性能


多个goroutine中，go语言使用通道(channel)进行通信，
通信是一种内置的数据结构，可以让用户在不同的goroutine之间
同步发送具有类型的消息。
这让编程模型更倾向于在goroutine之间发送消息，而不是让多个goroutine
争夺同一个数据的使用权

程序可以将需要并发的环节设计为生产者模式和消费者的模式
将数据放入通道。通道另外一端的代码将这些数据进行并发计算并
返回结果

go语言通过通道可以实现多个goroutine之间内存共享

实例，生产者每秒生产一个字符串，并通过通道传给消费者，生产者使用两个
goroutine并发运行，消费者在main()函数goroutine中进行处理
导入格式化(fmt) 随机数(math/rand) 时间(time)包 参参与编译

生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道
for{}构成一个无限循环
使用rand.Int31()生成一个随机数，使用fmt.Sprintf()函数将
header和随机数格式化为字符串

使用time.Sleep()函数暂停1秒再执行这个函数。如果在goroutine中
执行，暂停不会影响前天goroutine的执行

消费数据的函数，传入一个只能写入的通道
构造一个不断消费消息的循环
从通道中取出数据
将取出的数据进行打印
程序的入口函数，总是在程序开始时执行
实例化一个字符串类型的通道
并发执行一个生产函数，两行分别创建了这个函数搭配不同参数的两个goroutine

执行消费者函数通过通道进行数据消费


代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字go
实现goroutine，和通道实现数据数据交换


GO的优秀项目：

1.Docker
docker是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间
进行隔离，称为容器。Docker可以在一台物理服务器上快速运行一个或多个实例
例如，启动一个Centos操作系统，并在其内部命令执行指令后结束，


Kubernetes

Google公司开发的构建于Docker之上的容器调度服务，用户
可以通过Kubernetes集群进行云端容器集群管理。系统会自动选取
合适的工作节点来执行具体的容器集群调度处理工作
其核心概念是Container Pod(容器仓)

go语言适合做服务器开发，其定位是用来开发"大型软件的"
适合需要很多程序员一起开发，并且开发周期较长的大型软件和支持云计算的
网络服务
1.服务器编程方面，go语言适合处理日志，数据打包，虚拟机处理，文件系统
分布式系统，数据库代理等

2.网络编程，go语言广泛应用于web应用，api应用，下载应用等

go语言还用于内存数据库和云平台数据，还可以用于开发底层


go标准库

bufio  :带缓冲的I/O操作
bytes:实现字节操作
container:封装堆，列表和环形列表等容器
crypto:加密算法
database:数据库驱动和接口
debug:常见算法如JSON,XML,Base64
flag:命令行解析
fmt:格式化解析
go:go语言的词法，语法树，类型等，可通过这个包进行代码信息提取和修改
html:HTML转义及模板系统
image:常见图形格式的访问及生成
io:实现I/O原始访问接口及访问封装
math:数学库
net:网络库，支持Socket，HTTP,邮件，RPC,SMTP等
os:操作系统平台不依赖平台操作封装
path::兼容个操作系统的路径操作实用函数
plugin:go1.7加入的插件系统。支持将代码编译为插件，按需加载
reflect:语言反射支持。可以动态获得代码中得的类型信息，获取和修改变量的值

regexp:正则表达式封装
runtime:运行时接口
sort:排序接口
strings:字符串转换，解析及实用函数
time:时间接口
text:文本模板及Token词法器

标记当前文件为main包，main包也是go程序的入口包

导入net/http包，这个包的作用是HTTP的基础封装和访问
程序执行的入口函数main()
使用http.FileServer文件服务器将当前目录作为根目录(/目录)
的处理器，访问根目录，就会进入当前目录

默认的HTTP服务侦听在本机8080端口

go语言工程结构简单

go语言源码无须头文件，编译的文件来自.go的源码文件

go语言无须解决方案，工程文件和Makefile，只要将工程文件按照
GOPATH的规则进行填充，即可使用go build/go install
进行编译，编译完成的二进制可执行文件系统放在bin文件夹下


go语言工程结构

环境变量GOPATH,项目的构建主要是考它来实现的
如果要构建一个项目，就要将这个向莫得目录添加到GOPATH中，
多个项目之间可以使用;分隔

如果不配合GOPATH,及时处于同一目录，代码之间也无法通过绝对路径相互调用


目录结构

一个go语言项目的目录一般包含以下三个子目录：
src目录：放置项目和库的源文件
pkg目录：放置编译后生成的包/库的归档文件
bin目录：放置编译后生成的可执行文件

重点掌握src目录

src目录

用于以包(package)的形式组织并存放go源文件，这里的包与src下的
每个子目录是一一对应。
若一个源文件被声明属于log包，那么它就应该保存在src/log目录中
开发中，最好把go源文件放入特定的目录中

包是go语言管理代码的重要机制，其作用类似于java中的package和c/c++
的头文件。go源文件中第一段有效代码必须是package<包名>的形式，
如package hell0

go语言会把通过go get命令获取到的库源文件下载到src目录下对应的文件夹中

pkg目录

用于存放go install命令安装某个包后的归档文件。归档文件是指那些
名称为".a"结尾的文件

该目录与GOROOT目录也即是go语言的安装目录，下的pkg目录功能类似，
区别在于这里的pkg目录专门用来存放项目代码的归档文件

编译和安装项目代码的过程一般会以代码包为单位进行，比如log包
被编译安装后，将生成一个名为log.a的归档文件，
并存放在当前项目的pkg目录下


bin目录


与pkg目录类似，在通过go install命令完成安装后，保存由go命令
源文件生成的可执行文件。在类Unix操作系统下
这个可执行文件的名称与命令源文件的文件名相同。

命令源文件：如果一个go源文件被声明属于main包，并且该文件中
包含main函数，则它就是命令源码文件。命令源文件属于程序的入口，
可以通过go语言的go run命令运行或通过go build命令生成可执行文件


库源文件: 库原文件则是指存在于某个包中的普通源文件，
并且库源文件中不包含main函数

不管是命令源文件还是库源文件，在同一个目录下的所有源文件，其所属包的名称必须是一直的


包管理工具 godep

变量的声明 ，使用var关键字


简短格式 :=

定义便离开，同时显式初始化
不能提供数据类型
只能用在函数内部

匿名变量 "_"空白标识符，可以向其他标识符那样用于变量的声明或
赋值(任何类型都可以赋值给它)但任何赋值给匿名变量的都将被抛弃


作用域与参数

局部变量

在函数体内声明的变量就是局部变量，它们的作用域只在函数体内，
函数的参数和返回值变量都属于局部变量

局部变量不是一直存在的，它只在定义它的函数被调用后
存在，函数调用结束后这个句变量也就被销毁

全局变量

在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，、
就可以在所有源文件中使用，当然，不包含这个全局变量的源文件
需要使用"import"关键字引入全局变量所在的源文件之后才能使用这个全局变量

全局变量声明必须以var关键字开头，如果想要在外部包中使用全局变量的
首字母必须大写

全局变量与局部变量名称可以相同，但在函数体内的局部变量会被优先考虑

形式参数

在定义函数时函数后面括号中的变量叫做形式参数
形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值

形式参数会作为函数的局部变量来使用

go字符串

一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，
但是通常是用来包含可读的文本，字符串是UTF-8字节的一个序列
(当字符为ASCII码表上的字符时则占用1个字节，其他字符根据需要
占用2-4个字节)

定义字符串
\n:换行符
\r:回车符
\t:tab键
\u或\U:Unicode字符
\\:反斜杠自身


一般的比较运算符 == ！=

是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串
自然编码的顺序。字符串所占的字节长度可以通过函数len()来获取
len(str)


字符串的内容(纯字节)可以通过标准索引法来获取,在方括号[]内写入
索引，索引从0开始计数：

字符串str的第1个字节：str[0]
第i个字节：str[i-1]
最后1个字节：str[len(str)-1]

这种转换方案只对纯ASCII码的字符串有效

获取字符串中某个字节的地址属于非法

指针地址和指针类型

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址
在32和64位机器上分别占用4或8个字节，占用字节的大小与所指的值
大小无关。
当一个指针被定义后没有分配到任何变量时，它的默认值为nil


指针变量通常为ptr


每个变量在运行是都拥有一个地址，这个地址代表变量在内存中的位置。
go语言中使用在变量名前面添加&来获取变量的内存地址(取地址操作)

ptr := &v // v的类型为T

其中，v代表被取地址的变量，变量v的地址使用变量ptr进行接收
ptr类型为 *T,称作T的指针类型，*代表指针


每个变量都拥有地址，指针的值就是地址

从指针获取指针指向的值

当使用&操作符对普通变量进行取地址操作并得到变量的指针后，
可以对指针使用*操作符，也就是指针取值

准备一个字符串并赋值
对字符串取地址，将指针保存到变量ptr中
打印变量ptr的类型，其类型为*string
打印ptr的指针地址，地址每次运行都会发生变化
对ptr指针变量进行取值操作，变量value的类型为string
打印取值后value的类型
打印value

取地址操作符&和取值操作符*是一对互补操作符

& 取出地址
* 根据地址取出地址

变量，指针地址，指针变量，取地址，取值

1.对变量进行取地址操作使用&曹祖否，可以获得这个变量的指针变量
2.指针变量的值是指针地址
3.对指针变量进行取值操作使用*操作符，可以获得指针变量指向的原变量得知


使用指针修改值

通过指针不仅可以取值，也可以修改值

使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换

定义一个交换函数,参数为a,b,类型为*int指针类型

取指针a的值，并把值赋给变量t,t此时是int类型
取b的指针值，赋给指针a指向的变量。
注意，*a此时不是a指针的值，而是a指向的变量
准备x,y两个变量，分别赋值为1和2 ，类型为int

取出x和y的地址作为参数传递给swap()函数进行调用
交换完毕时，输出x和y的值

*操作符作为右值，意义是取指针的值，
*操作符的根本意义就是操作指针指向的变量。
当操作符在右值时，就是取指向变量的值，
当操作符在左值是，就是将值设置给指向的变量

示例： 使用指针变量获取命令行的输入信息

go语言内置的flag包实现了对命令行参数的解析

通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，
经过flag包的解析后即可获取命令行的数据


创建指针变量的方法 new()函数

str := new(string)

*str = "GO"
fmt.Println(*str)
new()函数可以创建一个对应类型的指针，创建过程会分配内存，
被创建的指针指向默认值


变量逃逸分析

堆和栈

栈(stack):是一种拥有特殊规则的线性表数据结构

1.栈只允许从线性表的同一端放入或取出数据，按照后进先出(LIFO)

入栈出栈
2.

栈可用于内存分配，栈的分配和回收速度很多课

堆：后金后出


堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。
但是为此付出的代缴是分配速度较慢，而且会形成内存碎片


变量逃逸：自动决定变量分配方式，提供运行效率

取地址是发生逃逸

编译器，应该分配在堆和栈上的原则是：
变量是否被取地址
变量是否发生逃逸


变量的生命周期指的是在程序运行期间变量有效存在的时间间隔
变量的声明周期与变量的作用域：
1.全局变量：它的生命周期和整个程序的运行周期是一致的
2.局部变量：它的声明周期则是动态的，从创建整个变量的声明语句开始
到整个变量不再被引用为止
3.形式参数和函数返回值：它们都属于局部变量，在函数
被调用的时候创建，函数调用结束后被销毁


Go语言常量和const关键字

const定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此
并且只能是布尔型，数字型(整数型，浮点数和复数)和字符串型

由于编译时的限制，定义常量的表达式必须为能被编译器求职的常量表达式

const name[type] =value

可以省略类型说明符[type] 因为编译器可以根据变量的值来判断其类型


显式类定义： const b string ="abc"
隐式类型定义：  const b ="abc"


常量的值必须是能够在编译时就能够确定，可以在其赋值表达式中涉及计算过程，但是所有用于
计算的值必须在编译期间就能获得


正确的做法：  const c1 = 2/3
错误的做法   const c2 =getNumber()


和声明变量一样，可以批量声明多个常量
常量间的所有算术运算，逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或一下调用函数
都是返回常量结果：len,cap,real,imag,complex,unsafe.Sizeof


因为它们的值在编译期就确定了，因此常量可以是构成类型的一部分，

一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型
time.Duration是一个命名类型，底层类型是int64,time.Minute是对应类型的常量
可以通过%T 参数打印类型信息

如果是批量声明的常量，除了第一个外其他的常量右边的初始化表达式都可以省略，
如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样



iota 常量生成器

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，
但是不用没写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，
iota将会被设置为0,然后在每一个有常量声明的行加一


无类型常量

通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而且
不需要显式的类型转换

go语言可以使用const常量 iota, 枚举类型

iota的起始值为0，一般情况下也建议枚举从0开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用


一个const声明内的每一行常量声明，将会自耦东套用前面的iota格式，并自动增加
类似电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，

iota不仅可以生成每次增加1的枚举值，还可以利用iota来做一些强大的枚举常量值生成器

iota使用了一个移位操作，每次将上一次的值左移动一位(二进制位)，以得出每一位的常量值
将3个枚举按照常量输出，分别输出2,4,8 都是将1每次左移动一位的结果

将枚举值按二进制格式输出，可以清晰地看到每一位的变化


将枚举值转换为字符串

枚举是一个独立的类型，可以通过枚举值获取该值对应的字符串

将int声明为ChipType芯片类型
将const里定义的常量值设为ChipType类型，且从0开始，每行值加1
定义ChipType类型的方法String()，返回值为字符串类型
使用switch语句判断当前的ChitType类型的值，返回对应的字符串
按整型的格式输出CPU的值


String()方法的ChipType在使用上和普通的常量没有区别
当这个类型需要显示字符串时，go语言会自动寻找String()方法并进行调用

区分类型别名与类型定义

type TypeAlias =Type
类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型
类型别名与类型定义 的区别

通过type关键字的定义，会形成一种新的类型，新类型也有int类型的特性

类型别名是指换个名字，跟Int类型还是一样

使用%T格式化参数，打印变量本身的类型

本地类型不能定义方法

在结构体成员嵌入时使用别名
定义商标结构

为商标结构添加Show()方法
为Brand定义一个别名FakeBrand
定义车辆结构Vehicle,嵌入FakeBrand和Brand结构

将Vechicle实例化为a
显式调用Vehicle中FakeBrand的Show()方法
使用反射取变量a的反射类型对象，以查看其他成员类型
遍历a的结构体程雨涵


注释工具godoc
标识符，操作符，分隔符，关键字，字面量

break,default,func,interface,select,case
defer,go,map,struct,chan,else,goto,package,switch
const,fallthrough,if,range,type,
continue,for,import,return ,var

在go语言中还存在着一些特殊的标识符，预定义标识符


append,bool,byte,cap,close,complex,complex64
complex128,unit16,copy,false,float32,float64,int,int8,int16
unit32,init64,iota,len,make,new,nil,panic,
unit64,print,println,real,recover,string,true,unit,unit8,uintptr


strconv包：字符串和数值类型的相互转换
常用函数有Atoi(),Itia(),parse系列函数，format系列函数，append系列函数


sring 与int类型之间的转

Itoa():整型转字符串

func Itoa(i int) string

Atoi():字符串转整型
func Atoi(s string)(i int,err error)

通过函数签名可以看出Atoi()函数有两个返回值，i为转换成功的整型，err在转换成功是为空转换
失败时为相应的错误信息

Parse系列函数

Parse系列函数用于将字符串转换为指定类型的值，其中包括Parsebool()
ParseFloat()

ParseBool()函数用于将字符串转换为bool类型的值，它只能接受1,0,t,f,T,F,true,false
,True,False,TRUE,FALSE，其他的值均返回错误

func ParseBool(str string)(value bool,err error)

ParseInt()函数用于返回字符串表示的整数值(可以包含正负号)

func ParseInt(s string,base int,bitSize int)(i int64,err error)


base指定进制，取值范围为2-36 .如果base为0,则会从字符串前置判断，"0X"是16进制
"0"是8进制，否则是10进制

bitSize指定结果必须能无溢出赋值的整数类型，0，8,16,32,64分别代表int,int8,int16
int32,int64

返回的err是*NumErr类型的，如果语法有误，err.Error =ErrSyntax,
如果结果超出类型范围err.Error= ErrRange

ParseUnit() 不接受正负号，用于无符号整型

func ParseUint(s string,base int,bitSize int)(n uint64,err error)

变量在一定程度上能满足函数及代码要求。复杂类型一般情况下具有各种形式的存储和处理数据的功能，称为"容器"

容器是以标准库的方式提供，

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为
数组的长度是固定的，很少直接使用数组

和数组对应的类型是Slice(切片)，slice是可以增长和收缩的动态序列


数据声明
var 数组变量名[元素数据]Type

数组变量名：数组声明及使用时的变量名
元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素
数量不能含有到运行时才能确认大小的数值

Type:可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组

数组的每个元素都可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置，
内置函数len()可以返回数组中元素的个数


默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说是0
同时也可以使用数组字面值语法，用一组值来初始化数组


在数组的定义中，如果在长度的位置出现："..."省略号，则表示数组长度是根据初始化值的个数来计算

q := [...]int{1,2,3}

fmt.Printf("%T\n",q)

数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型，
数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定

比较两个数组是否相等

如果两个数组类型相同(包括数组的长度，数组中元素的类型)的情况下，可以直接通过
比较运算符(==,!=)来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的
不能比较两个不同类型的数组，否则程序将无法完成编译


遍历数组---访问每一个数组元素

遍历数组和遍历切片类似


GO语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值
多维数组尤其适合管理具有父子关系或与坐标系相关联的数据

var array_name [size1][size2]...[sizen] array_type


array_name为数组的名字，array_type为数组的类型，size1,size2等为数组的每一维度的长度


切片(slice)是数组的一个连续片段的引用，所以切片是一个引用类型(类似python的List类型)
这个片段可以是整个数组，也可以是一部分，终止索引标识符不包含在切片内

切片的内部结构包含地址，大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合
比作切蛋糕，切片就是你想要的那一块，切的过程包含从哪里开始(切片的起始位置)及切多大(切片的大小)
容量可以理解装切片的口袋大熊啊


分配的内存

切片操作[开始:结束]
地址，大小，容量
（切片结构和内存分配）

从数据或切片生成新的切片
切片默认指向一段连续内存区域，可以是数组，也可以是切片本身

从连续内存区域生成切片是常见的操作
slice[开始位置：结束位置]

slice:表示目标切片对象
开始位置：对应目标切片对象的索引
结束位置：对应目标切片的结束索引



取出的元素数量为：结束位置-开始位置
取出元素不包含结束位置对应的索引，切片最后一个元素使用slice[len(slice)]获取
当缺省开始位置时，表示从了；连续区域开头到结束位置
当缺省结束位置时，表示从开始位置到整个连续区域末尾
两个同时缺省时，与切片本身等效
两个同时为0时，等效于空切片，一般用于切片复位


根据索引位置取切片slice元素值时，取值范围为(0~len(slice)-1),超界会运行时报错，
生成切片时，结束位置可以填写len(slice)但不会报错


切片类似c语言的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，
约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片
比指针更安全，更强大


2. 表示原有的切片
[:]
3. 重置切片，清空拥有的元素
[0:0]

直接声明新的切片

除了可以从原有的数组或切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有
其切片类型，表示多个相同类型的元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：

var name[]Type


其中name表示切片的变量名，Type表示切片对应的元素类型

声明一个字符串切片，切片中拥有多个字符串

切片是动态结构，只能与nil判定相等，不能互相判定相等
声明新的切片后，可以使用append()函数向切片中添加元素


使用make()函数构造切片

如果需要动态地创建一个切片，可以使用make()内建函数

make([]Type,size,cap)
其中，Type是指切片的元素类型，size指的是这个类型分配多少个元素，cap为预分配的元素数量
这个值设定后不影响size,只是能提前分配空间，降低多次分配空间造成的性能问题

容量不会影响当前的元素个数

使用make()函数生成的切片一定发生了内存分配操作，但给定开始与结束位置(包括切片复位)的切片只是将
新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作
go的append()可以为切片动态添加元素

在使用append()函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片
就会进行"扩容"，此时新切片的长度会发生改变

切片在扩容时，容量的扩展规律是按容量的2倍数进行扩充，例如1,2,4


声明一个整型切片
循环向numbers切片中添加10个数

打印输出切片的长度，容量和指针变化，使用函数len()查看切片拥有的元素个数，使用
函数cap()查看切片的容量情况
切片长度len并不等于切片的容量cap

在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制1次，
从切片的开头添加元素的性能要比从尾部追加元素的性能差很多

切片也支持链式操作，可以将多个append操作组合起来，实现在切片中间插入元素


copy:切片复制(切片拷贝) 可以将一组切片复制到另一个数组切片中，如果加入的两个数组
切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制

copy(destSlice.srcSlice[]T) int

其中srcSlice为数据来源切片，destSlice为复制的目标(也就是将srcSlice复制到destSlice)

目标切片必须分配过空间足够承载复制的元素个数，并且来源和目标的类型必须一致，copy()函数
的返回值表示实际发生复制的元素个数

go并没有对删除切片元素提供专用的语法或接口，需要使用切片本身的特性来删除严肃，
根据要删除元素的位置有三种情况，分别为：从开头位置删除，从中间位置删除，从尾部删除，其中删除切片尾部
的元素速度最快


从开头位置删除

删除开头的元素可以直接移动数据指针

从切片的特性删除中间的元素，将两个切片进行拼接

go中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来

连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的元素，随着
元素的增加，这个过程将变得非常耗时，当业务需要大量，频繁地从一个切片中删除元素时，
如果对性能要求较高的话，就需要考虑更换其他的容器了(如双链表等能快速从删除点删除元素)

range关键字，可以配合fo来迭代切片中的每一个元素

当迭代切片时，关键字range会返回两个值，第一个值是当前迭代到的索引位置，
第二个值是该位置对应元素值的一份副本

range返回的是每个元素的副本，而不是直接返回对该元素的引用

如果不需要索引值，也可以使用下划线_来忽略这个值

关键字range总是会从切片头部开始迭代的。如果想对迭代做更多的控制，则可以使用传统的
for循环

map是一种特殊的数据结构，一种元素对(pair)的无序集合，pair对应的一个key(索引)和一个value(值)
这个结构也称为i关联数组或字典，

map是引用类型

var mapname map[keytype] valuetype

mapname为map的变量名
keytype为键类型
valuetype是键对应的值类型

[keytype]和valuetype之间允许有空格

在声明的时候不需要知道map的长度，因为map是可以动态增长的，未初始化的map的值是nil,
使用函数len()可以获取map中pair的数目


map在并发情况下，只读是线程安全的，同时读写是线程不安全的

使用两个并发函数不断地对map进行读和写而发生了竞态问题，map内部会对这种并发操作进行检查提前发现

需要并发读写时，一般的做法是加锁，但这样的性能不高，sync包下的特殊结构

sync.Map的特性：
1.无须初始化，直接声明即可
2.sync.Map 不能使用map的风格是进行取值和设置等操作，而是使用sync.Map的方法进行调用，Store表示
存储，Load表示获取，Delete表示删除
3. 使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，
Range参数中回调函数的返回值在需要继续迭代遍历时，返回true,终止迭代遍历时，返回false


列表是一种非连续的存储容器，如单链表，双链表

列表使用container/list包中实现，内部的实现原理是双链表，列表能够高效地进行任意位置的
元素插入和删除操作

初始化列表

list的初始化有两种方法：New(),var

1. 通过container/list包的New()函数初始化list

变量名 := list.New()

2. 通过var关键字声明初始化list

var 变量名  list.List

列表与切片和map不同的是，列表并没有具体元素类型的限制，列表的元素可以是人恶意类型


在列表中插入元素

双链表支持从队列前方或后方插入元素，PushFront,PushBack

这两个方法都会返回一个*list.Element结构，如果在以后的使用中需要删除插入的元素，
则只能通过*list.Element配合Remove()方法进行删除，这种方法可以让删除更加效率话，
同时也是双链表特性之一

从列表中删除元素

列表插入函数的返回值会提供一个*list.Element结构，这结

指针，切片，映射 ，通道，函数和接口的零值则是nil

nil是go语言中的一个预定一号的标识符，

nil标识符不能比较 nil == nil  这个和python不同

nil 不是关键字或保留字


nil并不是go语言的关键字或保留字，也可以顶一个一个名称Nil

nil没有默认类型

零值是go语言中变量在声明之后但是未初始化被赋予的该类型的一个默认值


不同类型的nil值占用的内存大小可能是不一样的
一个类型的所有的值的内存布局都是一样的，具体的大小取决于编译器何谓架构


创建并分配类型的内存：new,make

new只用来分配内存
make只能用于slice,map,channel的初始化

new函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。
同时new函数会吧分配的内存设置为零，也就是该类型的零值
new函数不仅能够为系统美容恩的数据类型，分配空间，自定义类型也可以
使用new函数来分配空间

new函数，它返回的永远是类型的指针，指针指向分配类型的内存地址

make 也是用于内存分配，只用于chan,map,slice的内存创建，而且
它返回的类型就是这三个类型本身，而不是他们的指针类型
因为这三种类型就是引用类型，所以就没有必要返回它们的指针
如果想要获得一个显式的指针，可以使用new函数进行分配，或显式运用一个变量的地址

new和make的区别：
1.make只能用来分配及初始化类型为slice,map,chan的数据
new可以分配任意类型的数据
2. new分配返回的是指针，即类型*Type,
make返回引用，即Type

3.new分配的空间被清零。make分配空间后，会进行初始化

make关键字的主要作用是创建slice,map,Channel等内置的数据结构
new的主要作用为类型申请一片内存空间，并返回指向这片内存的指针

在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的
地方，状态救护被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响
所有代码的执行状态，因此限制变量的作用返回对代码的稳定性有很大帮助

手动生成回车
fmt.Println()

for range遍历的返回值有一定的规律
1. 数组，切片，字符串返回索引和值
2. map返回键和值
3. 通道(channel)只返回通道内的值


key,value分别代表切片的下标和下标对应的值

对字符串进行遍历，遍历时，key,value分别代表字符串的索引和字符串中的每一个字符

对map遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序

遍历通道(channel) ----接收通道数据

for range可以遍历通道(channel), 但是通道在遍历时，只输出一个值，即管道内的
类型对应的数据


 



switch case语句

case与case之间是独立的代码块，不需要通过break语句跳出当前case代码块以避免执行到下一行

var a = "hello"
switch a {
case "hello":
	fmt.Println(1)
case "world!":
	fmt.Println(2)
default:
	fmt.Println(0)
}

每一个case均是字符串格式，且使用了default分支，go语言规定每个switch只能有一个分支

一分支多值：

当出现多个case要放在一起的时候

不同的case表达式使用逗号分隔

2. 分支表达式

case后不仅仅只是常量，还可以和if一样添加表达式

goto语句通过标签进行代码间的无条件跳转，同时goto语句在快速跳出循环，避免重复退出上有一些帮助

使用goto退出多层循环

使用goto语句后，无须额外的变量就可以快速退出所有的循环

使用goto集中处理错误

函数是组织好的，可重复使用的，用来实现单一或相关联功能的代码端，其可以提高应用的模块型和代码的重复利用率

go语言支持普通函数，匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便

go语言的函数属于"一等公民"
函数本身可以作为值进行传递
支持匿名函数和闭包(closure)
函数可以满足接口


函数构成了代码执行的逻辑结构。关键字func,函数名，参数列表，返回值，函数体和返回语句，每一个程序都包含很多的函数，
函数是基本的代码块

当函数执行到代码块最后一行}之前或return语句的时候会退出，其中return语句可以带有零个或多个参数
这些参数将作为返回值供调用者使用，简单的return语句也可以用来结束for的死循环，或结束一个协程(goroutine)

go语言里面拥有三种类型的函数：
1.普通的带有名字的函数
2.匿名函数或lambda函数
3.方法


普通函数声明(定义)

将秒转换为具体的时间

使用一个数值表示时间中的"秒值"，然后使用resolveTime()函数将传入的秒数转化为天，小时和分钟等的单位





