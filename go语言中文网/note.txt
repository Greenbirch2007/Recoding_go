http://c.biancheng.net/view/1.html


并发编程已经成为程序员的基本技能

Goroutine是go显著的特征。可以用类协程的方式来处理并发单元，
在运行时层面做更深度的优化处理。
无须处理回调，无须关注线程切换，只需要一个关键字


搭配通道(channel)实现CSP模型。将并发单元间的数据耦合拆解开来，

内存分配  tcmalloc，专门为并发而设计的高性能内存分配组件

内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器
而修改的内容，内存分配器完整保留了tcmalloc的原始架构。使用cache
为当前执行线程提供无锁份额配，多个central在不同线程间平衡内存
单元复用。在更高层次里，heap管理着大块内存，用以切分不同等级
的复用内存块。快速分配和二级内存平衡机制，让内存分配器能
优秀地完成高压力下的内存管理任务

垃圾回收
静态链接
标准库


Go语言为并发而生

go语言的并发基于goroutine的，goroutine类似于线程，但并非线程，
可以将goroutine理解为一种虚拟线程。go语言运行时会参与调用goroutine
并将goroutine合理地分配到每个CPU中，最大限度地使用CPU性能


多个goroutine中，go语言使用通道(channel)进行通信，
通信是一种内置的数据结构，可以让用户在不同的goroutine之间
同步发送具有类型的消息。
这让编程模型更倾向于在goroutine之间发送消息，而不是让多个goroutine
争夺同一个数据的使用权

程序可以将需要并发的环节设计为生产者模式和消费者的模式
将数据放入通道。通道另外一端的代码将这些数据进行并发计算并
返回结果

go语言通过通道可以实现多个goroutine之间内存共享

实例，生产者每秒生产一个字符串，并通过通道传给消费者，生产者使用两个
goroutine并发运行，消费者在main()函数goroutine中进行处理
导入格式化(fmt) 随机数(math/rand) 时间(time)包 参参与编译

生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道
for{}构成一个无限循环
使用rand.Int31()生成一个随机数，使用fmt.Sprintf()函数将
header和随机数格式化为字符串

使用time.Sleep()函数暂停1秒再执行这个函数。如果在goroutine中
执行，暂停不会影响前天goroutine的执行

消费数据的函数，传入一个只能写入的通道
构造一个不断消费消息的循环
从通道中取出数据
将取出的数据进行打印
程序的入口函数，总是在程序开始时执行
实例化一个字符串类型的通道
并发执行一个生产函数，两行分别创建了这个函数搭配不同参数的两个goroutine

执行消费者函数通过通道进行数据消费


代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字go
实现goroutine，和通道实现数据数据交换


GO的优秀项目：

1.Docker
docker是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间
进行隔离，称为容器。Docker可以在一台物理服务器上快速运行一个或多个实例
例如，启动一个Centos操作系统，并在其内部命令执行指令后结束，


Kubernetes

Google公司开发的构建于Docker之上的容器调度服务，用户
可以通过Kubernetes集群进行云端容器集群管理。系统会自动选取
合适的工作节点来执行具体的容器集群调度处理工作
其核心概念是Container Pod(容器仓)

go语言适合做服务器开发，其定位是用来开发"大型软件的"
适合需要很多程序员一起开发，并且开发周期较长的大型软件和支持云计算的
网络服务
1.服务器编程方面，go语言适合处理日志，数据打包，虚拟机处理，文件系统
分布式系统，数据库代理等

2.网络编程，go语言广泛应用于web应用，api应用，下载应用等

go语言还用于内存数据库和云平台数据，还可以用于开发底层


go标准库

bufio  :带缓冲的I/O操作
bytes:实现字节操作
container:封装堆，列表和环形列表等容器
crypto:加密算法
database:数据库驱动和接口
debug:常见算法如JSON,XML,Base64
flag:命令行解析
fmt:格式化解析
go:go语言的词法，语法树，类型等，可通过这个包进行代码信息提取和修改
html:HTML转义及模板系统
image:常见图形格式的访问及生成
io:实现I/O原始访问接口及访问封装
math:数学库
net:网络库，支持Socket，HTTP,邮件，RPC,SMTP等
os:操作系统平台不依赖平台操作封装
path::兼容个操作系统的路径操作实用函数
plugin:go1.7加入的插件系统。支持将代码编译为插件，按需加载
reflect:语言反射支持。可以动态获得代码中得的类型信息，获取和修改变量的值

regexp:正则表达式封装
runtime:运行时接口
sort:排序接口
strings:字符串转换，解析及实用函数
time:时间接口
text:文本模板及Token词法器

标记当前文件为main包，main包也是go程序的入口包

导入net/http包，这个包的作用是HTTP的基础封装和访问
程序执行的入口函数main()
使用http.FileServer文件服务器将当前目录作为根目录(/目录)
的处理器，访问根目录，就会进入当前目录

默认的HTTP服务侦听在本机8080端口

go语言工程结构简单

go语言源码无须头文件，编译的文件来自.go的源码文件

go语言无须解决方案，工程文件和Makefile，只要将工程文件按照
GOPATH的规则进行填充，即可使用go build/go install
进行编译，编译完成的二进制可执行文件系统放在bin文件夹下


go语言工程结构

环境变量GOPATH,项目的构建主要是考它来实现的
如果要构建一个项目，就要将这个向莫得目录添加到GOPATH中，
多个项目之间可以使用;分隔

如果不配合GOPATH,及时处于同一目录，代码之间也无法通过绝对路径相互调用


目录结构

一个go语言项目的目录一般包含以下三个子目录：
src目录：放置项目和库的源文件
pkg目录：放置编译后生成的包/库的归档文件
bin目录：放置编译后生成的可执行文件

重点掌握src目录

src目录

用于以包(package)的形式组织并存放go源文件，这里的包与src下的
每个子目录是一一对应。
若一个源文件被声明属于log包，那么它就应该保存在src/log目录中
开发中，最好把go源文件放入特定的目录中

包是go语言管理代码的重要机制，其作用类似于java中的package和c/c++
的头文件。go源文件中第一段有效代码必须是package<包名>的形式，
如package hell0

go语言会把通过go get命令获取到的库源文件下载到src目录下对应的文件夹中

pkg目录

用于存放go install命令安装某个包后的归档文件。归档文件是指那些
名称为".a"结尾的文件

该目录与GOROOT目录也即是go语言的安装目录，下的pkg目录功能类似，
区别在于这里的pkg目录专门用来存放项目代码的归档文件

编译和安装项目代码的过程一般会以代码包为单位进行，比如log包
被编译安装后，将生成一个名为log.a的归档文件，
并存放在当前项目的pkg目录下


bin目录


与pkg目录类似，在通过go install命令完成安装后，保存由go命令
源文件生成的可执行文件。在类Unix操作系统下
这个可执行文件的名称与命令源文件的文件名相同。

命令源文件：如果一个go源文件被声明属于main包，并且该文件中
包含main函数，则它就是命令源码文件。命令源文件属于程序的入口，
可以通过go语言的go run命令运行或通过go build命令生成可执行文件


库源文件: 库原文件则是指存在于某个包中的普通源文件，
并且库源文件中不包含main函数

不管是命令源文件还是库源文件，在同一个目录下的所有源文件，其所属包的名称必须是一直的


包管理工具 godep

变量的声明 ，使用var关键字


简短格式 :=

定义便离开，同时显式初始化
不能提供数据类型
只能用在函数内部

匿名变量 "_"空白标识符，可以向其他标识符那样用于变量的声明或
赋值(任何类型都可以赋值给它)但任何赋值给匿名变量的都将被抛弃


作用域与参数

局部变量

在函数体内声明的变量就是局部变量，它们的作用域只在函数体内，
函数的参数和返回值变量都属于局部变量

局部变量不是一直存在的，它只在定义它的函数被调用后
存在，函数调用结束后这个句变量也就被销毁

全局变量

在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，、
就可以在所有源文件中使用，当然，不包含这个全局变量的源文件
需要使用"import"关键字引入全局变量所在的源文件之后才能使用这个全局变量

全局变量声明必须以var关键字开头，如果想要在外部包中使用全局变量的
首字母必须大写

全局变量与局部变量名称可以相同，但在函数体内的局部变量会被优先考虑

形式参数

在定义函数时函数后面括号中的变量叫做形式参数
形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值

形式参数会作为函数的局部变量来使用

go字符串

一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，
但是通常是用来包含可读的文本，字符串是UTF-8字节的一个序列
(当字符为ASCII码表上的字符时则占用1个字节，其他字符根据需要
占用2-4个字节)

定义字符串
\n:换行符
\r:回车符
\t:tab键
\u或\U:Unicode字符
\\:反斜杠自身


一般的比较运算符 == ！=

是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串
自然编码的顺序。字符串所占的字节长度可以通过函数len()来获取
len(str)


字符串的内容(纯字节)可以通过标准索引法来获取,在方括号[]内写入
索引，索引从0开始计数：

字符串str的第1个字节：str[0]
第i个字节：str[i-1]
最后1个字节：str[len(str)-1]

这种转换方案只对纯ASCII码的字符串有效

获取字符串中某个字节的地址属于非法

指针地址和指针类型

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址
在32和64位机器上分别占用4或8个字节，占用字节的大小与所指的值
大小无关。
当一个指针被定义后没有分配到任何变量时，它的默认值为nil


指针变量通常为ptr


每个变量在运行是都拥有一个地址，这个地址代表变量在内存中的位置。
go语言中使用在变量名前面添加&来获取变量的内存地址(取地址操作)

ptr := &v // v的类型为T

其中，v代表被取地址的变量，变量v的地址使用变量ptr进行接收
ptr类型为 *T,称作T的指针类型，*代表指针


每个变量都拥有地址，指针的值就是地址

从指针获取指针指向的值

当使用&操作符对普通变量进行取地址操作并得到变量的指针后，
可以对指针使用*操作符，也就是指针取值

准备一个字符串并赋值
对字符串取地址，将指针保存到变量ptr中
打印变量ptr的类型，其类型为*string
打印ptr的指针地址，地址每次运行都会发生变化
对ptr指针变量进行取值操作，变量value的类型为string
打印取值后value的类型
打印value

取地址操作符&和取值操作符*是一对互补操作符

& 取出地址
* 根据地址取出地址

变量，指针地址，指针变量，取地址，取值

1.对变量进行取地址操作使用&曹祖否，可以获得这个变量的指针变量
2.指针变量的值是指针地址
3.对指针变量进行取值操作使用*操作符，可以获得指针变量指向的原变量得知


使用指针修改值

通过指针不仅可以取值，也可以修改值

使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换

定义一个交换函数,参数为a,b,类型为*int指针类型

取指针a的值，并把值赋给变量t,t此时是int类型
取b的指针值，赋给指针a指向的变量。
注意，*a此时不是a指针的值，而是a指向的变量
准备x,y两个变量，分别赋值为1和2 ，类型为int

取出x和y的地址作为参数传递给swap()函数进行调用
交换完毕时，输出x和y的值

*操作符作为右值，意义是取指针的值，
*操作符的根本意义就是操作指针指向的变量。
当操作符在右值时，就是取指向变量的值，
当操作符在左值是，就是将值设置给指向的变量

示例： 使用指针变量获取命令行的输入信息

go语言内置的flag包实现了对命令行参数的解析

通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，
经过flag包的解析后即可获取命令行的数据


创建指针变量的方法 new()函数

str := new(string)

*str = "GO"
fmt.Println(*str)
new()函数可以创建一个对应类型的指针，创建过程会分配内存，
被创建的指针指向默认值


变量逃逸分析

堆和栈

栈(stack):是一种拥有特殊规则的线性表数据结构

1.栈只允许从线性表的同一端放入或取出数据，按照后进先出(LIFO)

入栈出栈
2.

栈可用于内存分配，栈的分配和回收速度很多课

堆：后金后出


堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。
但是为此付出的代缴是分配速度较慢，而且会形成内存碎片


变量逃逸：自动决定变量分配方式，提供运行效率

取地址是发生逃逸

编译器，应该分配在堆和栈上的原则是：
变量是否被取地址
变量是否发生逃逸


变量的生命周期指的是在程序运行期间变量有效存在的时间间隔
变量的声明周期与变量的作用域：
1.全局变量：它的生命周期和整个程序的运行周期是一致的
2.局部变量：它的声明周期则是动态的，从创建整个变量的声明语句开始
到整个变量不再被引用为止
3.形式参数和函数返回值：它们都属于局部变量，在函数
被调用的时候创建，函数调用结束后被销毁


Go语言常量和const关键字

const定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此
并且只能是布尔型，数字型(整数型，浮点数和复数)和字符串型

由于编译时的限制，定义常量的表达式必须为能被编译器求职的常量表达式

const name[type] =value

可以省略类型说明符[type] 因为编译器可以根据变量的值来判断其类型


显式类定义： const b string ="abc"
隐式类型定义：  const b ="abc"


常量的值必须是能够在编译时就能够确定，可以在其赋值表达式中涉及计算过程，但是所有用于
计算的值必须在编译期间就能获得


正确的做法：  const c1 = 2/3
错误的做法   const c2 =getNumber()


和声明变量一样，可以批量声明多个常量
常量间的所有算术运算，逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或一下调用函数
都是返回常量结果：len,cap,real,imag,complex,unsafe.Sizeof


因为它们的值在编译期就确定了，因此常量可以是构成类型的一部分，

一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型
time.Duration是一个命名类型，底层类型是int64,time.Minute是对应类型的常量
可以通过%T 参数打印类型信息

如果是批量声明的常量，除了第一个外其他的常量右边的初始化表达式都可以省略，
如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样



iota 常量生成器

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，
但是不用没写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，
iota将会被设置为0,然后在每一个有常量声明的行加一


无类型常量

通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而且
不需要显式的类型转换

go语言可以使用const常量 iota, 枚举类型

iota的起始值为0，一般情况下也建议枚举从0开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用


一个const声明内的每一行常量声明，将会自耦东套用前面的iota格式，并自动增加
类似电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，

iota不仅可以生成每次增加1的枚举值，还可以利用iota来做一些强大的枚举常量值生成器

iota使用了一个移位操作，每次将上一次的值左移动一位(二进制位)，以得出每一位的常量值
将3个枚举按照常量输出，分别输出2,4,8 都是将1每次左移动一位的结果

将枚举值按二进制格式输出，可以清晰地看到每一位的变化


将枚举值转换为字符串

枚举是一个独立的类型，可以通过枚举值获取该值对应的字符串

将int声明为ChipType芯片类型
将const里定义的常量值设为ChipType类型，且从0开始，每行值加1
定义ChipType类型的方法String()，返回值为字符串类型
使用switch语句判断当前的ChitType类型的值，返回对应的字符串
按整型的格式输出CPU的值


String()方法的ChipType在使用上和普通的常量没有区别
当这个类型需要显示字符串时，go语言会自动寻找String()方法并进行调用

区分类型别名与类型定义

type TypeAlias =Type
类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型
类型别名与类型定义 的区别

通过type关键字的定义，会形成一种新的类型，新类型也有int类型的特性

类型别名是指换个名字，跟Int类型还是一样

使用%T格式化参数，打印变量本身的类型

本地类型不能定义方法

在结构体成员嵌入时使用别名
定义商标结构

为商标结构添加Show()方法
为Brand定义一个别名FakeBrand
定义车辆结构Vehicle,嵌入FakeBrand和Brand结构

将Vechicle实例化为a
显式调用Vehicle中FakeBrand的Show()方法
使用反射取变量a的反射类型对象，以查看其他成员类型
遍历a的结构体程雨涵


注释工具godoc
标识符，操作符，分隔符，关键字，字面量

break,default,func,interface,select,case
defer,go,map,struct,chan,else,goto,package,switch
const,fallthrough,if,range,type,
continue,for,import,return ,var

在go语言中还存在着一些特殊的标识符，预定义标识符


append,bool,byte,cap,close,complex,complex64
complex128,unit16,copy,false,float32,float64,int,int8,int16
unit32,init64,iota,len,make,new,nil,panic,
unit64,print,println,real,recover,string,true,unit,unit8,uintptr


strconv包：字符串和数值类型的相互转换
常用函数有Atoi(),Itia(),parse系列函数，format系列函数，append系列函数


sring 与int类型之间的转

Itoa():整型转字符串

func Itoa(i int) string

Atoi():字符串转整型
func Atoi(s string)(i int,err error)

通过函数签名可以看出Atoi()函数有两个返回值，i为转换成功的整型，err在转换成功是为空转换
失败时为相应的错误信息

Parse系列函数

Parse系列函数用于将字符串转换为指定类型的值，其中包括Parsebool()
ParseFloat()

ParseBool()函数用于将字符串转换为bool类型的值，它只能接受1,0,t,f,T,F,true,false
,True,False,TRUE,FALSE，其他的值均返回错误

func ParseBool(str string)(value bool,err error)

ParseInt()函数用于返回字符串表示的整数值(可以包含正负号)

func ParseInt(s string,base int,bitSize int)(i int64,err error)


base指定进制，取值范围为2-36 .如果base为0,则会从字符串前置判断，"0X"是16进制
"0"是8进制，否则是10进制

bitSize指定结果必须能无溢出赋值的整数类型，0，8,16,32,64分别代表int,int8,int16
int32,int64

返回的err是*NumErr类型的，如果语法有误，err.Error =ErrSyntax,
如果结果超出类型范围err.Error= ErrRange

ParseUnit() 不接受正负号，用于无符号整型

func ParseUint(s string,base int,bitSize int)(n uint64,err error)

变量在一定程度上能满足函数及代码要求。复杂类型一般情况下具有各种形式的存储和处理数据的功能，称为"容器"

容器是以标准库的方式提供，

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为
数组的长度是固定的，很少直接使用数组

和数组对应的类型是Slice(切片)，slice是可以增长和收缩的动态序列


数据声明
var 数组变量名[元素数据]Type

数组变量名：数组声明及使用时的变量名
元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素
数量不能含有到运行时才能确认大小的数值

Type:可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组

数组的每个元素都可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置，
内置函数len()可以返回数组中元素的个数


默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说是0
同时也可以使用数组字面值语法，用一组值来初始化数组


在数组的定义中，如果在长度的位置出现："..."省略号，则表示数组长度是根据初始化值的个数来计算

q := [...]int{1,2,3}

fmt.Printf("%T\n",q)

数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型，
数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定

比较两个数组是否相等

如果两个数组类型相同(包括数组的长度，数组中元素的类型)的情况下，可以直接通过
比较运算符(==,!=)来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的
不能比较两个不同类型的数组，否则程序将无法完成编译


遍历数组---访问每一个数组元素

遍历数组和遍历切片类似


GO语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值
多维数组尤其适合管理具有父子关系或与坐标系相关联的数据

var array_name [size1][size2]...[sizen] array_type


array_name为数组的名字，array_type为数组的类型，size1,size2等为数组的每一维度的长度


切片(slice)是数组的一个连续片段的引用，所以切片是一个引用类型(类似python的List类型)
这个片段可以是整个数组，也可以是一部分，终止索引标识符不包含在切片内

切片的内部结构包含地址，大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合
比作切蛋糕，切片就是你想要的那一块，切的过程包含从哪里开始(切片的起始位置)及切多大(切片的大小)
容量可以理解装切片的口袋大熊啊


分配的内存

切片操作[开始:结束]
地址，大小，容量
（切片结构和内存分配）

从数据或切片生成新的切片
切片默认指向一段连续内存区域，可以是数组，也可以是切片本身

从连续内存区域生成切片是常见的操作
slice[开始位置：结束位置]

slice:表示目标切片对象
开始位置：对应目标切片对象的索引
结束位置：对应目标切片的结束索引



取出的元素数量为：结束位置-开始位置
取出元素不包含结束位置对应的索引，切片最后一个元素使用slice[len(slice)]获取
当缺省开始位置时，表示从了；连续区域开头到结束位置
当缺省结束位置时，表示从开始位置到整个连续区域末尾
两个同时缺省时，与切片本身等效
两个同时为0时，等效于空切片，一般用于切片复位


根据索引位置取切片slice元素值时，取值范围为(0~len(slice)-1),超界会运行时报错，
生成切片时，结束位置可以填写len(slice)但不会报错


切片类似c语言的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，
约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片
比指针更安全，更强大


2. 表示原有的切片
[:]
3. 重置切片，清空拥有的元素
[0:0]

直接声明新的切片

除了可以从原有的数组或切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有
其切片类型，表示多个相同类型的元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：

var name[]Type


其中name表示切片的变量名，Type表示切片对应的元素类型

声明一个字符串切片，切片中拥有多个字符串

切片是动态结构，只能与nil判定相等，不能互相判定相等
声明新的切片后，可以使用append()函数向切片中添加元素


使用make()函数构造切片

如果需要动态地创建一个切片，可以使用make()内建函数

make([]Type,size,cap)
其中，Type是指切片的元素类型，size指的是这个类型分配多少个元素，cap为预分配的元素数量
这个值设定后不影响size,只是能提前分配空间，降低多次分配空间造成的性能问题

容量不会影响当前的元素个数

使用make()函数生成的切片一定发生了内存分配操作，但给定开始与结束位置(包括切片复位)的切片只是将
新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作
go的append()可以为切片动态添加元素

在使用append()函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片
就会进行"扩容"，此时新切片的长度会发生改变

切片在扩容时，容量的扩展规律是按容量的2倍数进行扩充，例如1,2,4


声明一个整型切片
循环向numbers切片中添加10个数

打印输出切片的长度，容量和指针变化，使用函数len()查看切片拥有的元素个数，使用
函数cap()查看切片的容量情况
切片长度len并不等于切片的容量cap

在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制1次，
从切片的开头添加元素的性能要比从尾部追加元素的性能差很多

切片也支持链式操作，可以将多个append操作组合起来，实现在切片中间插入元素


copy:切片复制(切片拷贝) 可以将一组切片复制到另一个数组切片中，如果加入的两个数组
切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制

copy(destSlice.srcSlice[]T) int

其中srcSlice为数据来源切片，destSlice为复制的目标(也就是将srcSlice复制到destSlice)

目标切片必须分配过空间足够承载复制的元素个数，并且来源和目标的类型必须一致，copy()函数
的返回值表示实际发生复制的元素个数

go并没有对删除切片元素提供专用的语法或接口，需要使用切片本身的特性来删除严肃，
根据要删除元素的位置有三种情况，分别为：从开头位置删除，从中间位置删除，从尾部删除，其中删除切片尾部
的元素速度最快


从开头位置删除

删除开头的元素可以直接移动数据指针

从切片的特性删除中间的元素，将两个切片进行拼接

go中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来

连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的元素，随着
元素的增加，这个过程将变得非常耗时，当业务需要大量，频繁地从一个切片中删除元素时，
如果对性能要求较高的话，就需要考虑更换其他的容器了(如双链表等能快速从删除点删除元素)

range关键字，可以配合fo来迭代切片中的每一个元素

当迭代切片时，关键字range会返回两个值，第一个值是当前迭代到的索引位置，
第二个值是该位置对应元素值的一份副本

range返回的是每个元素的副本，而不是直接返回对该元素的引用

如果不需要索引值，也可以使用下划线_来忽略这个值

关键字range总是会从切片头部开始迭代的。如果想对迭代做更多的控制，则可以使用传统的
for循环

map是一种特殊的数据结构，一种元素对(pair)的无序集合，pair对应的一个key(索引)和一个value(值)
这个结构也称为i关联数组或字典，

map是引用类型

var mapname map[keytype] valuetype

mapname为map的变量名
keytype为键类型
valuetype是键对应的值类型

[keytype]和valuetype之间允许有空格

在声明的时候不需要知道map的长度，因为map是可以动态增长的，未初始化的map的值是nil,
使用函数len()可以获取map中pair的数目


map在并发情况下，只读是线程安全的，同时读写是线程不安全的

使用两个并发函数不断地对map进行读和写而发生了竞态问题，map内部会对这种并发操作进行检查提前发现

需要并发读写时，一般的做法是加锁，但这样的性能不高，sync包下的特殊结构

sync.Map的特性：
1.无须初始化，直接声明即可
2.sync.Map 不能使用map的风格是进行取值和设置等操作，而是使用sync.Map的方法进行调用，Store表示
存储，Load表示获取，Delete表示删除
3. 使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，
Range参数中回调函数的返回值在需要继续迭代遍历时，返回true,终止迭代遍历时，返回false


列表是一种非连续的存储容器，如单链表，双链表

列表使用container/list包中实现，内部的实现原理是双链表，列表能够高效地进行任意位置的
元素插入和删除操作

初始化列表

list的初始化有两种方法：New(),var

1. 通过container/list包的New()函数初始化list

变量名 := list.New()

2. 通过var关键字声明初始化list

var 变量名  list.List

列表与切片和map不同的是，列表并没有具体元素类型的限制，列表的元素可以是人恶意类型


在列表中插入元素

双链表支持从队列前方或后方插入元素，PushFront,PushBack

这两个方法都会返回一个*list.Element结构，如果在以后的使用中需要删除插入的元素，
则只能通过*list.Element配合Remove()方法进行删除，这种方法可以让删除更加效率话，
同时也是双链表特性之一

从列表中删除元素

列表插入函数的返回值会提供一个*list.Element结构，这结

指针，切片，映射 ，通道，函数和接口的零值则是nil

nil是go语言中的一个预定一号的标识符，

nil标识符不能比较 nil == nil  这个和python不同

nil 不是关键字或保留字


nil并不是go语言的关键字或保留字，也可以顶一个一个名称Nil

nil没有默认类型

零值是go语言中变量在声明之后但是未初始化被赋予的该类型的一个默认值


不同类型的nil值占用的内存大小可能是不一样的
一个类型的所有的值的内存布局都是一样的，具体的大小取决于编译器何谓架构


创建并分配类型的内存：new,make

new只用来分配内存
make只能用于slice,map,channel的初始化

new函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。
同时new函数会吧分配的内存设置为零，也就是该类型的零值
new函数不仅能够为系统美容恩的数据类型，分配空间，自定义类型也可以
使用new函数来分配空间

new函数，它返回的永远是类型的指针，指针指向分配类型的内存地址

make 也是用于内存分配，只用于chan,map,slice的内存创建，而且
它返回的类型就是这三个类型本身，而不是他们的指针类型
因为这三种类型就是引用类型，所以就没有必要返回它们的指针
如果想要获得一个显式的指针，可以使用new函数进行分配，或显式运用一个变量的地址

new和make的区别：
1.make只能用来分配及初始化类型为slice,map,chan的数据
new可以分配任意类型的数据
2. new分配返回的是指针，即类型*Type,
make返回引用，即Type

3.new分配的空间被清零。make分配空间后，会进行初始化

make关键字的主要作用是创建slice,map,Channel等内置的数据结构
new的主要作用为类型申请一片内存空间，并返回指向这片内存的指针

在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的
地方，状态救护被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响
所有代码的执行状态，因此限制变量的作用返回对代码的稳定性有很大帮助

手动生成回车
fmt.Println()

for range遍历的返回值有一定的规律
1. 数组，切片，字符串返回索引和值
2. map返回键和值
3. 通道(channel)只返回通道内的值


key,value分别代表切片的下标和下标对应的值

对字符串进行遍历，遍历时，key,value分别代表字符串的索引和字符串中的每一个字符

对map遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序

遍历通道(channel) ----接收通道数据

for range可以遍历通道(channel), 但是通道在遍历时，只输出一个值，即管道内的
类型对应的数据


 



switch case语句

case与case之间是独立的代码块，不需要通过break语句跳出当前case代码块以避免执行到下一行

var a = "hello"
switch a {
case "hello":
	fmt.Println(1)
case "world!":
	fmt.Println(2)
default:
	fmt.Println(0)
}

每一个case均是字符串格式，且使用了default分支，go语言规定每个switch只能有一个分支

一分支多值：

当出现多个case要放在一起的时候

不同的case表达式使用逗号分隔

2. 分支表达式

case后不仅仅只是常量，还可以和if一样添加表达式

goto语句通过标签进行代码间的无条件跳转，同时goto语句在快速跳出循环，避免重复退出上有一些帮助

使用goto退出多层循环

使用goto语句后，无须额外的变量就可以快速退出所有的循环

使用goto集中处理错误

函数是组织好的，可重复使用的，用来实现单一或相关联功能的代码端，其可以提高应用的模块型和代码的重复利用率

go语言支持普通函数，匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便

go语言的函数属于"一等公民"
函数本身可以作为值进行传递
支持匿名函数和闭包(closure)
函数可以满足接口


函数构成了代码执行的逻辑结构。关键字func,函数名，参数列表，返回值，函数体和返回语句，每一个程序都包含很多的函数，
函数是基本的代码块

当函数执行到代码块最后一行}之前或return语句的时候会退出，其中return语句可以带有零个或多个参数
这些参数将作为返回值供调用者使用，简单的return语句也可以用来结束for的死循环，或结束一个协程(goroutine)

go语言里面拥有三种类型的函数：
1.普通的带有名字的函数
2.匿名函数或lambda函数
3.方法


普通函数声明(定义)

将秒转换为具体的时间

使用一个数值表示时间中的"秒值"，然后使用resolveTime()函数将传入的秒数转化为天，小时和分钟等的单位




go语言函数中的参数传递效果测试
go语言中传入与返回参数在调用和返回时都使用值传递，指针，切片，map等引用类型对象在
参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用


go语言函数变量---把函数作为值保存到变量中

在go中，函数也是一种类型，可以和其他类型一样保存在变量中，

下面定义了一个函数变量f,并将一个函数名为file()的函数赋值给函数变量f,这样调用函数变量f时，实际调用
的就是file()变量

定义一个fire()函数
将变量f声明为func()类型，此时f就是回调函数，此时f的值为nil
将fire()函数作为值，赋给函数变量f,此时f的值为fire()函数
使用函数变量f进行函数调用，实际调用的是fire()函数

go语言字符串的链式处理---操作与数据分析的设计期缴

使用sql语言从数据库中获取数据时，可以对原始数据进行排序(sort by),分组(group by)
去重(distinct)等操作，sql将数据的操作与遍历过程记性分离

对数据的操作进行多步骤的处理被称为链式处理，本例使用多个字符串作为数据结合，然后
对每个字符串进行一系列的处理，用户可以通过系统的函数或自定义函数对链式处理的每个环节记性子女大衣

1. 字符串处理函数(stringprocess)需要外部提供数据源，一个字符串切片(list[]string),
另外还要提供一个链式处理函数的切片(chain[]func(string)string),链式处理切片中的一个
处理函数 func(string)string


字符串处理主流程

1.准备要处理的字符串列表
2.准备字符串处理链
3.处理字符串列表
4. 打印输出后的字符串列表

匿名函数，在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的
变量，匿名函数也往往以变量方式传递，go语言支持随时在代码里定义匿名函数

匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成

匿名函数的另一就是没有名字的普通函数定义
1.在定义时调用匿名函数

匿名函数可以在声明后调用

2. 将匿名函数赋值给变量

匿名函数可以被赋值


func (data int){
	fmt.Println("hello",data)
}(100)


f := func(data int){
	fmt.Println("hello",data)
}


f(100)


匿名函数作为回调函数


对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户
传入不同的匿名函数体可以实现对元素不同的遍历操作


匿名函数作为回调函数比较常见


使用匿名函数实现操作风戽脏

将匿名函数作为map的键值，通过命令行参数动态调用匿名函数


go语言函数类型实现接口--把函数作为接口来调用


函数和其他类型一样都属于"一等公民"，其他类型能够实现接口，函数也可以，

这个接口实现Call()方法，调用时会传入一个interface{}类型的变量，这种类型的变量表示任意类型的值


使用结构体进行接口实现

结构体实现接口


函数体实现接口

函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，当
类型方法被调用时，还需要调用函数本体

将func(interface{})定义为FuncCaller类型
FuncCaller的Call()方法将实现Invoker的Call()方法

需要函数本身进行逻辑处理，FuncCaller无须被实例化，只需要将函数转换为FuncCaller类型即可，函数来源可以
是命名函数，匿名函数或闭包

声明接口变量

使用接口方法调用

HTTP包中包含有Handler接口定义

Handler用于定义HTTP的请求和相应的处理过程

同时，也可以使用处理函数实现接口

要使用闭包实现默认的HTTP请求处理，可以使用http.HandlerFunc（）函数

go语言中闭包是引用咧自由变量的函数，被引用的自由变量和函数一同存在，及时已经离开了
自由变量的环境也不会被释放或删除，在闭包中可以继续使用这个自由变量

函数 + 引用环境= 闭包

同一个函数与不同引用环境组合，可以形成不同的实例,也是不同的闭包

一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的
闭包才具有"记忆性"，函数是编译期静态的概念，而闭包是运行期动态的该男

闭包(closure)在某些编程语言中也被称为Lambda表达式

闭包对环境中变量的用用过程被称为"捕获"

在闭包内部修改引用的变量

闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改

准备一个字符串用于修改
创建一个匿名函数

在匿名函数中并没有定义str,ｓｔｒ的定义在匿名函数之前，此时，str就被应用到了匿名函数中形成了闭包
执行闭包，此时str发生修改

//准备一个字符串
str := "hello world"

//创建一个匿名函数

foo := func(){
	//匿名函数中访问str
	str ="hello dude"
}


//调用匿名函数foo()

闭包的记忆效应

被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会
跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应

可变参数类型

可变参数是指函数传入的参数个数是可变的，首选需要将函数定义为可接受可变参数的而理性


任意类型的可变参数

遍历可变参数列表－－－获取每一个参数的值

可变参数列表的数量不固定，传入的参数是一个切片，如果需要获得每一个参数的具体值
时，可以对可变参数变量进行遍历


如果要获取可变的数量，可以使用len()函数对可变变量对应的切片求长度操作，以获得可变参数数量

获得可变参数类型－－获得每一个参数的类型

当可变参数为interface{}类型时，可以传入任何类型的值，如果需要获得变量的类型，可以
通过switch获得变量的类型，

在多个可变参数函数中传递参数

可变参数是一个包含所有参数的切片，如果要将这个含有可变参数的变量传递给下一个可变参数函数，
可以在传递时给可变参数变后面添加...,这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身


可变参数使用...进行传递与切片间使用append连接是同一个特性

go语言中的defer语句会将其后面跟随的语句进行延迟处理，在defer归属的函数即将返回时，
将延迟处理的语句按defer的逆序进行执行，先被defer的语句最后被执行，最后被defer的语句，最先被执行

关键字defer的用法类似于面向对象java的finally语句块，它一般用于释放某些已经分配的资源
典型的例子就是对一个互斥解锁，或关闭一个文件

多个延迟执行语句的处理顺序

当有多个defer行为被注册时，它们会以逆序执行(类似栈，即后进先出)



代码的延迟顺序与最终的执行熟悉怒是反向的
延迟调用是在defer所在函数结束时进行，函数结束可以是正常返回时，
也可以是发生宕机时


使用延迟执行语句在函数退出时释放资源


处理业务胡逻辑中涉及成对的操作是一个烦琐的事情，比如打开和关闭文件，接收请求和回复请求
加锁和解锁等
在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源


defer语句正好在函数退出时执行的语句，所以使用defer能非常方便地处理资源释放问题

１．使用延迟并发解锁



实例化一个map,键是string类型，值为int

map默认不是并发安全的，准备一个sync.Mutex互斥量保护map的访问
readValue()函数给定一个键，从map中获得值后返回，该函数会在并发环境中使用，需要保护并发安全

使用互斥量加锁
从map中获取值
使用互斥量解锁
返回获取到的map值　　　使用defer语句


２．　使用延迟释放文件句柄

文件的操作需要经过打开文件，获取和操作文件资源，关闭资源几个过程，如果在操作完毕后不关闭
文件资源，进程将一直无法释放文件资源，下面的例子中将实现根据文件名获取文件大小的函数，
函数中需要打开文件，获取文件大小和关闭文件等操作，由于每一步系统操作都需要
进行错误处理，而每一步处理都会造成一次可能的退出，
因此就需要在退出时释放资源，而我们需要密切关注在函数处正确地释放文件资源


编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出

多个函数组成递归


go语言中也可以使用相互调用的递归函数，多个函数相互调用形成闭环，因为go语言编译器的特殊性，这些函数的声明
顺序可以是任意的，

处理运行时的错误

１一个可能造成错误的函数，需要返回值中返回一个错误接口(error),如果调用是成功的，错误接口
将返回nil,否则返回错误

２．在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理

net包中的例子


net.Dial()是go语言系统包net即中的一个函数，一般用于创建一个Socket连接

net.Dial　拥有两个返回值，即Conn和error，这个函数是阻塞的，因此在Socket操作后
会返回Conn连接对象和error,如果发生错误，error会告知错误的类型，Conn会返回空

根据go语言的错误处理机制，Conn是其重要的返回值，因此，为这个函数增加一个错误返回，类似为error


在io包中的Writer接口也拥有错误返回

io包中还有Closer接口，只有一个错误返回

错误接口的定义格式


error是go系统声明的接口类型

type error interface{
	Error() string
}


所有符合Error()string格式的方法，都能实现错误接口，Error()方法返回错误的具体描述
使用者可以通过这个字符串只奥发生了什么错误

自定义一个错误

返回错误前，需要定义会产生哪些可能的错误，在go原因中，使用errors包进行错误的定义，　

错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用errors.New返回

１．　errors包

go语言的errors中对New中定义ｉ

２．　在代码中使用错误定义

在解析中使用自定义错误

go语言的类型系统会在编译时捕捉很多错误，但有些错误只能在运行时检查，如数组访问越界，空指针引用等，这些运行时错误会引起宕机

一般而言，当宕机发生时，程序会中断运行，并立即执行在该goroutine（可以理解成线程）
中被延迟的函数(defer机制)
随后，程序崩溃并输出日志信息，日志信息包括panic value和函数调用的堆栈跟踪信息，panic value　通常是某种错误信息


对于每个goroutine，日志信息中都会有与之相对应的，发生panic
时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，
日志信息已经提供了足够的诊断依据，因此在我们填写问题　报告时，一般会将宕机和日志信息一并记录


手动触发宕机
go语言程序在宕机时，会将堆栈和goroutine信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置

在运行依赖的必备资源缺失时主动触发宕机

在宕机时触发延迟执行语句

当panic()触发的宕机发生时，panic()后面的代码将不会被运行，但是在panic()函数前面已经运行过的
defer语句依然会在宕机发生时发生作为永


宕机前，defer语句会被优先执行，

defer的特性可以用来在宕机发生前进行宕机信息处理


宕机恢复(recover)----防止程序崩溃

Recover是一个go语言的内建函数，可以让进入宕机流程中的goroutine恢复过来，recover
仅在延迟函数defer中有效，在正常的执行过程中，调用recover会返回nil并且没有其他任何效果，
如果当前的goroutine陷入恐慌，调用recover可以捕获到panic的输入值，并且恢复正常的执行


通常来说，不应该对进入panic宕机的程序做任何处理，有时，我们可以从宕机中恢复，
至少我们可以在程序崩溃前，做一些操作，

在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过try/catch机制捕获异常，
没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行

go语言中没有异常系统，其使用panic触发宕机类似于其他语言的抛出异常，recover的宕机恢复机制
就对应其他语言中的try/catch机制


让程序在崩溃时继续运行

该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生panic崩溃后，
可以将崩溃发生的错误打印出来，同时允许后面的代码继续执行
不会造成整个进程的崩溃


声明描述错误的结构体，保存执行错误的函数

使用defer将闭包延迟执行，当panic触发崩溃时，ProtectRun()函数将结束运行，此时
defer后的闭包将会发生调用

recover获取到panic传入的参数
使用switch对err 变量进行类型断言
如果错误是有Runtime层抛出的运行时错误，如空指针访问，除数为０等情况，打印运行时错误

1.有panic,没recover,程序宕机
2. 有panic,有recover,程序不会宕机，执行完对应的defer后，从宕机点退出当前函数后继续执行

如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接设置

计算函数执行时间

函数的运行时间的长短是衡量这个函数性能的重要指标，特别是在对比和基准测试中，
要得到函数的运行时间，就是在函数之前前设置一个起始时间，并在函数运行结束时获取从起始时间到现在的时间间隔，
这个时间间隔就是函数的运行时间

time包中的Since()函数来获取函数的运行时间，

Since()函数返回从t到现在经过的时间，等价于time.Now().Sub(t)

递归函数的缺点是比较销毁内存效率第

提升性能的一个方法就是避免重复计算，通过在内存中缓冲并重复利用
缓存从而避免重复执行相同计算的方式称为内存缓存

基于堆栈式的程序执行模型决定了函数是语言的一个核心元素，分析go原因函数的底层
实现，对理解整个程序的执行构成有很大帮助，
研究底层实现有两种方法
１. 看语言编译器源码，分析其对函数的各个特性的处理逻辑，
２．　反汇编，将可执行程序反汇编出来


函数调用规约

go语言函数使用的是caller-save的模式，即由调用者负责保存寄存器，所以在函数的头尾不会出现push ebp;mov esp ebp这样的
代码，相反其在主调函数调用被调函数的千户有一个保存现场和恢复现场的动作

自带testing测试包，可以进行自动化的单元测试，输出结果验证，并且可以测试性能

为什么需要测试
完善的测试体系，能够提高开发的效率，当项目足够复杂的时候，想要保证尽可能的减少bug,
有两种有效的方式：代码审核和测试，
go语言汇总提供了testing包来实现单元测试功能

要开始一个单元测试，需要准备一个go源码文件，在命名文件时文件名必须以_test.go结尾，
单元测试源码文件可以由多个测试用例(函数)组成，每个测试用例的名称要以Test为前缀


func TestXXX(t *testing.T){}


编写测试用例的注意：
１．测试用例文件不会参与正常源码的编译，不会被包含到可执行文件中；
２．测试用例的文件名必须以_test.go结尾
３．　需要使用import 导入testing包



testing包有三种测试方法：单元(功能)测试，性能(压力)测试和覆盖率测试

go语言通过自定义的方式形成新的类型，结构体是类型中带有成员的符合类型。
go语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性


go语言中的类型可以被实例化，使用new或&构造的类型实例的类型是类型的指针

结构体成员是由一系列的成员变量构成，这些成员变量的也称为"字段"字段的特性
１．字段拥有自己的类型和值
２．　字段名必须唯一
3. 字段的类型也可以是结构体，甚至是字段所在结构体的类型


go语言中没有"类"的概念，也不支持"类"的继承等面向对象额该爱你

go语言的结构体与"类"都是复合结构体，但go语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性

go语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法


可以通过自定义的方式形式新的类型，结构体就是这些类型中的一种复合类型，
结构体是由零个或多个任意类型的值聚合而成的实体，每个值都可以称为结构体的成员


结构体成员也可以称为字段，
１．　字段拥有自己的类型和值
２．　字段名必须唯一
３．　字段的类型也可以是结构体，甚至是字段所在结构体的类型


使用关键字type可以将各种基本类型定义为自定义类型，基本类型包括整型，字符串，布尔等
结构体是一种符合的基本类型


type 类型名 struct{
	字段1 字段1类型
}

类型名：标识自定义结构体的名称，在同一个包内不能重复
struct{}:表示结构体类型，type类型名struct{}可以理解为将struct{}结构体
定义为类型名的类型
字段１，：白石结构体字段名，结构体中的字段名必须唯一
字段１类型：表示结构体各个字段的类型


使用结构体可以表示一个包含X和整数分量的点结构：

type Point struct{
	X int
}

同类型的变量也可以写在一行，
type Color struct{
	R,G,B byte
}


结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存

实例化结构体－－－－为结构体分配内存并初始化

必须在定义结构体并实例化后才能使用结构体的字段。

实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，
结构体实例与实例间的内存是完全独立的

基本的实例化形式

结构体本身是一种类型，可以像整型，字符串类型一样，以var的方式声明结构体即可完成实例化
var ins T

其中，Ｔ为结构体类型，ins为结构体的实例


用结构体表示的点结构(Point)的实例化过程

type Point struct{
	X int
	Y int
}

var p Point
p.X =10
p.Y =10


使用.来访问结构体的成员变量，如p.X和p.Y等
结构体成员变量的赋值方法与普通变量一致


创建指针类型的结构体

go语言中，还可以使用new关键字对类型(包括结构体，整型，浮点数，字符串等)进行实例化，结构体在实例化后会形成指针类型的结构体

ins := new(T)
T为类型，可以是结构体，整型，字符串等
ins:Ｔ类型被实例化后保存到ins变量中，ins的类型为*T,属于指针

可以像访问普通结构体一样使用.来访问结构体指针的成员

在c/c++中，使用new实例化类型后，访问其成员变量时必须使用->操作符

在ｇｏ语言中，访问结构体指针的成员变量时可以继续使用.,这是因为go语言为了方便
开发者访问结构体指针的成员变量，使用了语法糖(Syntactic sugar)技术，
将ins.Name形式转换为(*ins).Name


取结构体的地址实例化


在go语言中，对结构体进行&取地址操作时，视为对该类型进行一次new的实话操作，
取地址格式

ins := &T{}


T表示结构体类型
ins为结构体的实例，类型为*T,是指针而理性

定义Command结构体，表示命令行指令
命令绑定的变量，使用整型指针绑定一个指针，指令的值可以与绑定的值随时保持同步
命令绑定的目标整型变量：版本号
对结构体取地址实例化
初始化成员字段


取地址实例化是最广泛的一种结构体实例化方式，可以使用函数封装上面的初始化过程

初始化结构体的成员变量

结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式：
１．　以字段"键值对"形式
2.多个值的列表形式

键值对形式的初始化适合选择性填充字段较多的结构体，
多个值的列表形式适合填充字段较少的结构体

使用"键值对"初始化结构体

结构体可以使用"键值对"(key value pair)初始化字段，，每个"键"(key)
对应结构体中的一个字段，键的"值"(value)对应字段需要初始化的值

键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中

结构体实例化后字段的默认值是字段类型的默认值，
例如，数值为０，字符串为""(空字符串)
布尔为false,指针为nil


1.键值对结构化结构体的书写格式

ins := 结构体类型名{
	字段１:字段１的

}


键值之间以:分隔，键值对之间以.分隔


2. 使用键值对填充结构的例子


定义People结构体
结构体的字符串字符
结构体的结构体指针字段，类型是*People
relation由People类型取地址后，形成类型为*People的实例
child在初始化时，需要 *People类型的值，使用取地址初始化一个People

使用多个值的列表初始化结构体

ｇ构造函数

每个类可以添加构造函数，多个构造函数使用函数重载实现
构造函数一般与类名同名，且没有返回值
构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数


多种方式创建和初始化结构体---模拟构造函数重载


如果使用结构体描述符的特性，

go方法是作用在接收器(receiver)上的一个函数，
接收器是某种类型的变量，因此方法是一种特殊类型的函数

接收器类型可以是(几乎)任何类型，不仅仅是结构体类型，任何类型
都可以有方法，甚至可以是函数类型，可以是int,bool,string或数组的别名类型，
但是接收器不能是一个接口类型，因为接口是一个抽象定义，
而方法却是具体实现，如果这样做了就会引发一个编译错误

接收器不能是一个指针类型，但接收器可以是任何其他允许类型的指针，一个类型加上它的方法
等价于面向对象的一个类，一个重要的区别是，在go语言中，
类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们存在不同的源文件中，唯一的要求就是它
它们必须是同一个包的

类型T 上所有方法的集合叫做类型Ｔ的方法集

接收器－－－方法作用的目标


func(接收器　接收器类型)方法名(参数列表)(返回参数){函数体}

为基本类型添加方法

使用时间系统实现事件的响应和处理


方法和函数的统一调用


无论是普通函数还是结构体的方法，只要它们的签名一致，与
它们签名一致的函数变量就可以保存普通函数或结构体方法

事件系统基本原理

事件系统可以将事件派发者与事件处理者解耦
例如，网络底层可以生成各种事件，在网络连接上后，网络底层
需要将事件派发出去，而不需要关系到底哪些代码来响应连接上的逻辑。


一个事件系统拥有如下特性：
１．能够实现事件的一方，可以根据事件ID或名字注册对应的事件
２．事件发起者，会根据注册信息通知这些注册者
３．一个事件可以有多个实现方响应


时间系统不保证同一个事件实现方多个函数列表中的调用顺序，事件系统
认为所有实现函数都是平等的
一个完善的时间系统还会提供移除单个和所有时间的方法

结构体可以包含一个或多个匿名(或内嵌)字段，即这些字段没有显式的名字，只有字段的类型是必须的，
此时类型也就是字段的名字。
匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体

go语言中的继承是通过内嵌或组合来实现的


在一个结构体中对于每一种数据类型只能有一个匿名字段

内嵌结构体

n内层结构体被简单的插入或内嵌进外层结构体。这种"继承"机制提供了一种方式，
使得可以从另外一个或一些类型继承或全部实现


一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，
编译器在发现可能的赋值歧义时会报错

go语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性

使用go语言的内嵌结构体实现对象特性，可以自由地在对象中增，删，改各种特性

初始化内嵌结构体

结构体内嵌初始化时，将结构体内嵌的类型作为字段名称像普通结构体一样进行初始化

go使用匿名结构体解析json数据
标准库中的encoding/json包提供

定义数据结构

准备json数据
将数据序列化json格式的字节数组

分离json数据
调用getJsonData获得JSON数据，将需要的字段填充到匿名结构体
实例中，通过json.Unmarshal反序列化Json数据达到分离Json数据效果

go自带垃圾回收机制(GC).GC通过独立的进程执行，它会搜索不再使用的变量，并将其释放。
GC在运行时会占用机器资源
GC是自动进行的，如果要手动进行GC,可以使用runtime.GC()函数，显式的执行ＧＣ.
显式的进行GC只在某些特殊的情况下才有用，比如当内存资源不足时调用runtime.GC()
这样会立即释放一大片内存，但是会造成程序短时间的性能下降


将结构体数据保存为json格式数据


json格式是一种对象文本格式，可使用json.Marshal()函数将结构体格式的数据
格式化为JSON格式

要使用json.Marshal()需要引入encoding/json包

链表是一种物理存储单元上非连续，非顺序的存储结构，数据元素的逻辑顺序是通过
链表中的指针链接次序实现的

链表由一系列结点(链表中每一个元素称为结点)组成，结点可以在运行时动态生成。
每个结点包括两部分：
１．存储数据元素的数据域，
２．　存储下一个结点地址的指针域


使用链表结构可以避免在使用数组时需要预先直到数据大小的缺点，链表结构可以充分利用
计算机内存空间，空间灵活的内存动态管理。
但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，
空间开销比较大


链表允许插入和移除上任意位置上的结点，但是不允许随机存取，
链表有三种类型：单向链表，双向链表，循环链表


在go中，几乎所有的数据结构都围绕着接口展开，接口是go语言中所有数据结构的核心。
在实际开发过程中，无论是实现web应用程序，还是控制台输入输出，又或者网络操作，
都不可避免的会遇到I/O操作

go语言标准库的bufio包汇总，实现了对数据I/O接口的缓冲功能。
这些功能封装在接口
io.ReadWriter,io.Reader,io.Writer中
并对应创建了ReadWriter,Reader,Writer对象
在提供缓冲的同时实现了一些文本基本I/O操作功能


接口本身是调用方和实现方均需要遵守的一种协议


按照统一的方法命名参数类型和数量来协调逻辑处理的过程


go语言中使用组合实现对象特性的描述。
对象的内部使用结构体内嵌组合对象应该具有的特性，
对外通过接口暴露能使用的特性


go语言的接口设计是非进入性的，接口编写者无须直到接口
被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明哪一个接口。
编译器直到最终编译时使用哪个类型实现哪个接口，或接口应该由谁来实现


接口是双方约定的一种合作协议，接口实现不需要关心接口会被怎样使用，调用者
也不需要关心接口的实现细节。
接口是一种类型，也是一种抽象接口，不会暴露所含数据的格式，类型以及接口


接口声明的格式

每个接口类型由数个方法组成。
接口的形式如下

type 接口类型名 interface{
	方法名1(参数列表)返回值列表１
}



接口类型名：使用type将接口定义为自定义的类型名

实现接口的条件

如果一个任意类型T的方法集为一个接口类型的方法集的超集，则说类型T实现了此接口类型。

Ｔ可以是一个非接口类型，也可以是一个接口类型


实现关系在go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。
go编译器将自动在需要的时候检查两个类型之间的实现关系

接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。
接口的实现两个条件：
１．接口的方法与实现接口的类型方法格式一致
在类型中添加与接口签名一致的方法就可以实现该方法。
签名包括方法中的名称，参数列表，返回参数列表。
只要实现接口类型中的方法的名称，参数列表，返回参数列表中的任意一项与接口要实现的方法不一致，那么接口
的这个方法就不会被实现


２．　接口中所有方法均被实现

当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用


一个类型可以实现多个接口
网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个Socket.
Socket能够同时读取和写入数据，这个特性与文件类似。
开发中把文件和Socket都具备的读写特性抽象为独立的读写器概念


Socket和文件一样，在使用完毕后，也需要对资源进行释放

把Socket能够写入数据和需要关闭的特性使用接口来描述

多个类型可以实现相同的接口

一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入
嵌入其他类型或结构体来实现。
使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构
嵌入到一个结构体中拼凑起来共同实现的


Service接口定义了两个方法：一个是开启服务的方法(Start())
一个是输出日志的方法(Log())
使用GameService结构体来实现Service,GameService自己的结构只能实现Start()

类型断言

(Type Assertion)是一个使用在接口值上的操作，用于检查接口类型变量所持有的值
是否实现了期望的接口或具体的类型


value,ok := x.(T)

其中，x表示一个接口的类型，T表示一个具体的类型(也可为接口类型)


该断言表达式会返回x的值(value),一个布尔值(ok)
可根据该布尔值判断x是否T类型

１．如果T是具体某个类型，类型断言会检查x的动态类型是否等于具体类型T.
如果检查成功，类型断言返回的结果是x的动态值，其类型为T
2.如果T是接口类型，类型断言会检查x的动态类型是否满足T.如果检查成功，
x的动态值不会被提取，返回值是一个类型为Ｔ的接口值

３．无论T是什么类型，如果x是nil接口值，类型断言都会失败

日志可以用于查看和分析应用程序的运行状态。日志一般可以支持输出多种形式，
如命令行，文件，网络等等

日志对外接口

定义一个日志写入器接口(LogWriter),要求写入设备这个接口协议才能被日志器(Logger)注册
日志器有一个写入器的注册方法(Logger的RegisterWriter()方法)


日志器有一个Log()方法，进行日志的输出，这个函数会将日志写入器(LogWriter)中

声明日志写入器接口。这个接口可以被外部使用。
日志的输出可以有多个

排序操作和字符串格式化是经常使用的操作。sort包内置的提供了一些排序函数来对任何序列排序
排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联


go语言的sort.Sort函数不会对具体的序列和它的元素做任何假设
它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到
的序列类型之间的约定。
这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片

一个内置的排序算法需要知道３个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式
这就是sort.Interface的三个方法

为了对序列进行排序，需要定义一个实现了这三个方法的类型，
然后对这个类型的一个实例应用sort.Sort函数。思考对一个字符串切片记性排序


使用sort.Interface接口排序

对一系列字符串进行排序时，使用字符串切片([]string)承载多个字符串。
使用type关键字，将字符串切片([]string)定义为自定义类型MyStrngList.

为了让sort包能识别MyStringList,能够对MyStringList进行排序，就必须
让MyStringList实现sort.Interface接口


接口的嵌套组合


在go语言汇总，不仅结构体与结构体之间可以嵌套，接口与接口之间也可以通过嵌套创造出新的接口。


一个接口包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样
只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可被调用


系统包中的接口嵌套组合

io包中定义了写入器(Writer),关闭器(Closer)和写入关闭器(WriteCloser)3个接口


接口和类型之间的转换

go语言中使用接口断言(type assertions)将接口转换成另一个接口，也可以将接口转换为另外的烈性

类型断言的格式

类型断言是一个使用在接口值上的操作。
i.(T)被称为断言类型，这里i表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的
动态类型是否和断言的类型匹配

t := i.(T)

空接口类型 interface{}

空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都实现无须实现空接口

从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，
也可以从空接口中取出原值

空接口是一种非常灵活的数据抽象保存和使用的方法

空接口的内部实现保存了对象的类型和指针。使用空接口保存一个数据的过程会比直接用数据对应类型的
变量保存稍慢。在开发时，应在需要的地方使用空接口，而不是在所有地方使用空接口

将值保存到空接口


从空接口获取值

保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误


类型分支(switch 判断空接口中变量的类型)

error接口：返回错误信息

错误

error基本用法

error接口有一个签名为Error() string的方法，所有实现该接口的类型都可以当做
一个错误类型。Error()方法给出了错误的描述，在使用fmt.Printn打印错误时，会在内部
调用Error() string方法来得到该错误的描述

一般情况下，如果函数需要返回错误，就将error作为多个返回值中的最后一个

创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error

把复杂留给自己，把简单留给用户

１．从语言运行时中抽取部分源码，讲解接口实现中涉及的基本数据结构
２．从反汇编的代码中分析接口实现机制
３．　从编译的可执行文件中寻找线索


数据接口必须初始化才有意义，没有初始化的接口变量的默认值是nil,
具体类型实例传递给接口称为接口的实例化，
在接口的实例化的过程中，编译器通过特定的数据结构描述这个过程


os中的文件操作返回的错误集合，I/O会因为很多原因失败，但有三类原因通常
必须单独处理：文件已存储(创建操作),文件没找到(读取操作)以及权限不足

os包提供了三个帮助函数用来对错误进行分类

go的动态类型

go语言是唯一结合了接口值，静态类型检查(是否该类型实现了某个接口)
，运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口，
该特性允许我们在不改变已有代码的情况下定义和使用新即可欧

go语言实现web服务器

音乐播放器

关键流程
１．音乐库功能，使用这可以查看，添加和删除里面的音乐曲目
２．播放音乐
３．支持mp3,wav,但也能随时扩展以支持更多的音乐类型
４．退出程序

使用空接口实现可以保存任意值的字典


空接口可以保存任何类型这个特性可以方便地用于容器的设计。

二叉树数据结构的应用

go语言的源码复用建立在包(package)基础之上。go语言的入口main()函数所在的包(package)叫做main,
main包想要引用别的代码，必须同样以包的方式引用，


go语言使用包来组织源代码的，并实现命名空间的管理。
任何源代码文件必须属于某个包。源文件的第一行有效代码必须是package packageName语句，
通过该语句声明自己所在的包


go语言的包借助了目录树的组织形式，

包的习惯用法：
１．报名一般是小写的，使用一个简短的命名
2.包名一般要和所在的目录同名
３．包一般放到公司的域名目录下，这样能保证包名的唯一性，便于共享代码

包引用

标准包的源码位于$GOROOT/src/下面，标准包可以直接引用。自定义的包和第三方包的源码必须
放到$GOPATH/src目录下才能被引用

包引用路径

包的引用路径有两种写法：１．全路径，２．相对路径

全路径引用

包的绝对路径就是"$GOROOT/src"或$GOPATH/src后面的源码的全路径

相对路径引用

比如包a的路径是$GOPATH/src/lab/a
包b的路径是$GOPATH/src/lab/b

假设b引用了b包，则可以使用相对路径引用方式

相对路径引用
import "../a"

//全路径引用
import "lab/a"

包引用

１．　标准引用方式

import "fmt"
此时，可以用"fmt."作为前缀引用包内可导出元素，这是常用的一种方式

２．　别名引用方式

import F"fmt"

此时相当于给包fmt起了一个别名F,用"F."代替标准的"fmt."作为前缀引用fmt包可导出元素

３．　省略方式

import . "fmt"

此时相当于把包fmt的命名空间直接合并到当前程序的命名空间中，使用fmt包内可导出元素可以不用前缀"fmt.",直接引用

4. 仅执行包初始化init函数

使用标准格式引用包，但是代码中却没有使用包，编译器会报错。
如果包中有init初始化函数，则通过import_"packageName"这种方式引用包，仅执行包的初始化程序，
即使包没有init初始化函数，也不会引发编译器报错


１．一个包可以有多个init函数，包加载会执行全部的init函数，但并不能保证执行顺序，所以不建议
在一个包中放入多个init函数，将需要初始化的逻辑放到一个init函数里面

２．包不能出现环形应用。　比如包a引用包b,包b引用了包ｃ,如果包c又引用了包a，则编译不能通过
３．　包的重复引用是允许的。

比如包a引用了包b和包c,包ｂ和包c都引用了包d。这种场景相当于重复引用了d.
这种情况是允许的，并且ｇｏ编译器保证d的init函数只会执行一次


包加载

在执行main.main之前，go引导程序会先对整个程序的包进行初始化

go包的初始化的特点
１．　包初始化程序从main函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，
最终生成一个包引用的有向无环图
２．go编译器会将有向无环图转换为一棵树，然后从树的叶子结点开始逐层向上对包进行初始化
３．但个包的初始化过程，先初始化常量，然后是全局变量，最后执行包的init函数(如果有)


封装简介及实现细节

在go语言中封装就是把抽象出来的字段和对字段的操作封装在一起，数据被保护在内部
程序的其他包只能通过被授权的方法，才能对字段进行操作


封装的好处
１．隐藏实现细节
２．可以对数据进行验证，保证数据安全合理


如何体现封装：
１．对结构体中的属性进行封装
２．通过方法，包，实现封装


封装的实现步骤：
１．将结构体，字段的首字母小写
２．通过方法，包，实现封装


封装的实现步骤：
１．将结构体，字段的首字母小写
２．给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数
３．提供一个首字母大写字母的Set方法(类似于public),用于对属性判断并赋值
4.　提供一个首字母大写的Get方法(类似与其他语言的public)，用于获取属性的值


GOPATH详解(Go语言工作目录)

GOPATH是go语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录

GOPATH适合处理大量GO语言源码，多个包组合而成的复杂工程

使用命令行查看GOPATH信息

go env  ,将输出当前go开发包的环境变量状态
GOARCH表示目标处理器架构
GOBIN表示编译器和链接器的安装位置
GOOS表示目标操作系统
GOPATH表示当前工作目录
GOROOT表示GO开发包的安装目录

使用GOPATH的工程结构
bin,pkg目录的内容都可以由src目录生成

Global GOPATH代表全局GOPATH,一般来源于系统环境变量中的GOPATH
Project　GOPATH代表项目使用的GOPATH
该设置会被保存在工作目录下的.idea目录下，不会
被设置到环境变量的GOPATH中，但会在编译时使用到这个目录
在开发时只填写项目的GOPATH,
每一个项目尽量只设置一个GOPATH,不使用多个GOPATH和全局的GOPATH

内置包简介


