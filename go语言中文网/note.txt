http://c.biancheng.net/view/1.html


并发编程已经成为程序员的基本技能

Goroutine是go显著的特征。可以用类协程的方式来处理并发单元，
在运行时层面做更深度的优化处理。
无须处理回调，无须关注线程切换，只需要一个关键字


搭配通道(channel)实现CSP模型。将并发单元间的数据耦合拆解开来，

内存分配  tcmalloc，专门为并发而设计的高性能内存分配组件

内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器
而修改的内容，内存分配器完整保留了tcmalloc的原始架构。使用cache
为当前执行线程提供无锁份额配，多个central在不同线程间平衡内存
单元复用。在更高层次里，heap管理着大块内存，用以切分不同等级
的复用内存块。快速分配和二级内存平衡机制，让内存分配器能
优秀地完成高压力下的内存管理任务

垃圾回收
静态链接
标准库


Go语言为并发而生

go语言的并发基于goroutine的，goroutine类似于线程，但并非线程，
可以将goroutine理解为一种虚拟线程。go语言运行时会参与调用goroutine
并将goroutine合理地分配到每个CPU中，最大限度地使用CPU性能


多个goroutine中，go语言使用通道(channel)进行通信，
通信是一种内置的数据结构，可以让用户在不同的goroutine之间
同步发送具有类型的消息。
这让编程模型更倾向于在goroutine之间发送消息，而不是让多个goroutine
争夺同一个数据的使用权

程序可以将需要并发的环节设计为生产者模式和消费者的模式
将数据放入通道。通道另外一端的代码将这些数据进行并发计算并
返回结果

go语言通过通道可以实现多个goroutine之间内存共享

实例，生产者每秒生产一个字符串，并通过通道传给消费者，生产者使用两个
goroutine并发运行，消费者在main()函数goroutine中进行处理
导入格式化(fmt) 随机数(math/rand) 时间(time)包 参参与编译

生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道
for{}构成一个无限循环
使用rand.Int31()生成一个随机数，使用fmt.Sprintf()函数将
header和随机数格式化为字符串

使用time.Sleep()函数暂停1秒再执行这个函数。如果在goroutine中
执行，暂停不会影响前天goroutine的执行

消费数据的函数，传入一个只能写入的通道
构造一个不断消费消息的循环
从通道中取出数据
将取出的数据进行打印
程序的入口函数，总是在程序开始时执行
实例化一个字符串类型的通道
并发执行一个生产函数，两行分别创建了这个函数搭配不同参数的两个goroutine

执行消费者函数通过通道进行数据消费


代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字go
实现goroutine，和通道实现数据数据交换


GO的优秀项目：

1.Docker
docker是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间
进行隔离，称为容器。Docker可以在一台物理服务器上快速运行一个或多个实例
例如，启动一个Centos操作系统，并在其内部命令执行指令后结束，


Kubernetes

Google公司开发的构建于Docker之上的容器调度服务，用户
可以通过Kubernetes集群进行云端容器集群管理。系统会自动选取
合适的工作节点来执行具体的容器集群调度处理工作
其核心概念是Container Pod(容器仓)

go语言适合做服务器开发，其定位是用来开发"大型软件的"
适合需要很多程序员一起开发，并且开发周期较长的大型软件和支持云计算的
网络服务
1.服务器编程方面，go语言适合处理日志，数据打包，虚拟机处理，文件系统
分布式系统，数据库代理等

2.网络编程，go语言广泛应用于web应用，api应用，下载应用等

go语言还用于内存数据库和云平台数据，还可以用于开发底层


go标准库

bufio  :带缓冲的I/O操作
bytes:实现字节操作
container:封装堆，列表和环形列表等容器
crypto:加密算法
database:数据库驱动和接口
debug:常见算法如JSON,XML,Base64
flag:命令行解析
fmt:格式化解析
go:go语言的词法，语法树，类型等，可通过这个包进行代码信息提取和修改
html:HTML转义及模板系统
image:常见图形格式的访问及生成
io:实现I/O原始访问接口及访问封装
math:数学库
net:网络库，支持Socket，HTTP,邮件，RPC,SMTP等
os:操作系统平台不依赖平台操作封装
path::兼容个操作系统的路径操作实用函数
plugin:go1.7加入的插件系统。支持将代码编译为插件，按需加载
reflect:语言反射支持。可以动态获得代码中得的类型信息，获取和修改变量的值

regexp:正则表达式封装
runtime:运行时接口
sort:排序接口
strings:字符串转换，解析及实用函数
time:时间接口
text:文本模板及Token词法器

标记当前文件为main包，main包也是go程序的入口包

导入net/http包，这个包的作用是HTTP的基础封装和访问
程序执行的入口函数main()
使用http.FileServer文件服务器将当前目录作为根目录(/目录)
的处理器，访问根目录，就会进入当前目录

默认的HTTP服务侦听在本机8080端口

go语言工程结构简单

go语言源码无须头文件，编译的文件来自.go的源码文件

go语言无须解决方案，工程文件和Makefile，只要将工程文件按照
GOPATH的规则进行填充，即可使用go build/go install
进行编译，编译完成的二进制可执行文件系统放在bin文件夹下


go语言工程结构

环境变量GOPATH,项目的构建主要是考它来实现的
如果要构建一个项目，就要将这个向莫得目录添加到GOPATH中，
多个项目之间可以使用;分隔

如果不配合GOPATH,及时处于同一目录，代码之间也无法通过绝对路径相互调用


目录结构

一个go语言项目的目录一般包含以下三个子目录：
src目录：放置项目和库的源文件
pkg目录：放置编译后生成的包/库的归档文件
bin目录：放置编译后生成的可执行文件

重点掌握src目录

src目录

用于以包(package)的形式组织并存放go源文件，这里的包与src下的
每个子目录是一一对应。
若一个源文件被声明属于log包，那么它就应该保存在src/log目录中
开发中，最好把go源文件放入特定的目录中

包是go语言管理代码的重要机制，其作用类似于java中的package和c/c++
的头文件。go源文件中第一段有效代码必须是package<包名>的形式，
如package hell0

go语言会把通过go get命令获取到的库源文件下载到src目录下对应的文件夹中

pkg目录

用于存放go install命令安装某个包后的归档文件。归档文件是指那些
名称为".a"结尾的文件

该目录与GOROOT目录也即是go语言的安装目录，下的pkg目录功能类似，
区别在于这里的pkg目录专门用来存放项目代码的归档文件

编译和安装项目代码的过程一般会以代码包为单位进行，比如log包
被编译安装后，将生成一个名为log.a的归档文件，
并存放在当前项目的pkg目录下


bin目录


与pkg目录类似，在通过go install命令完成安装后，保存由go命令
源文件生成的可执行文件。在类Unix操作系统下
这个可执行文件的名称与命令源文件的文件名相同。

命令源文件：如果一个go源文件被声明属于main包，并且该文件中
包含main函数，则它就是命令源码文件。命令源文件属于程序的入口，
可以通过go语言的go run命令运行或通过go build命令生成可执行文件


库源文件: 库原文件则是指存在于某个包中的普通源文件，
并且库源文件中不包含main函数

不管是命令源文件还是库源文件，在同一个目录下的所有源文件，其所属包的名称必须是一直的


包管理工具 godep

变量的声明 ，使用var关键字


简短格式 :=

定义便离开，同时显式初始化
不能提供数据类型
只能用在函数内部

匿名变量 "_"空白标识符，可以向其他标识符那样用于变量的声明或
赋值(任何类型都可以赋值给它)但任何赋值给匿名变量的都将被抛弃


作用域与参数

局部变量

在函数体内声明的变量就是局部变量，它们的作用域只在函数体内，
函数的参数和返回值变量都属于局部变量

局部变量不是一直存在的，它只在定义它的函数被调用后
存在，函数调用结束后这个句变量也就被销毁

全局变量

在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，、
就可以在所有源文件中使用，当然，不包含这个全局变量的源文件
需要使用"import"关键字引入全局变量所在的源文件之后才能使用这个全局变量

全局变量声明必须以var关键字开头，如果想要在外部包中使用全局变量的
首字母必须大写

全局变量与局部变量名称可以相同，但在函数体内的局部变量会被优先考虑

形式参数

在定义函数时函数后面括号中的变量叫做形式参数
形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值

形式参数会作为函数的局部变量来使用

go字符串

一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，
但是通常是用来包含可读的文本，字符串是UTF-8字节的一个序列
(当字符为ASCII码表上的字符时则占用1个字节，其他字符根据需要
占用2-4个字节)

定义字符串
\n:换行符
\r:回车符
\t:tab键
\u或\U:Unicode字符
\\:反斜杠自身


一般的比较运算符 == ！=

是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串
自然编码的顺序。字符串所占的字节长度可以通过函数len()来获取
len(str)


字符串的内容(纯字节)可以通过标准索引法来获取,在方括号[]内写入
索引，索引从0开始计数：

字符串str的第1个字节：str[0]
第i个字节：str[i-1]
最后1个字节：str[len(str)-1]

这种转换方案只对纯ASCII码的字符串有效

获取字符串中某个字节的地址属于非法

指针地址和指针类型

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址
在32和64位机器上分别占用4或8个字节，占用字节的大小与所指的值
大小无关。
当一个指针被定义后没有分配到任何变量时，它的默认值为nil


指针变量通常为ptr


每个变量在运行是都拥有一个地址，这个地址代表变量在内存中的位置。
go语言中使用在变量名前面添加&来获取变量的内存地址(取地址操作)

ptr := &v // v的类型为T

其中，v代表被取地址的变量，变量v的地址使用变量ptr进行接收
ptr类型为 *T,称作T的指针类型，*代表指针


每个变量都拥有地址，指针的值就是地址

从指针获取指针指向的值

当使用&操作符对普通变量进行取地址操作并得到变量的指针后，
可以对指针使用*操作符，也就是指针取值

准备一个字符串并赋值
对字符串取地址，将指针保存到变量ptr中
打印变量ptr的类型，其类型为*string
打印ptr的指针地址，地址每次运行都会发生变化
对ptr指针变量进行取值操作，变量value的类型为string
打印取值后value的类型
打印value

取地址操作符&和取值操作符*是一对互补操作符

& 取出地址
* 根据地址取出地址

变量，指针地址，指针变量，取地址，取值

1.对变量进行取地址操作使用&曹祖否，可以获得这个变量的指针变量
2.指针变量的值是指针地址
3.对指针变量进行取值操作使用*操作符，可以获得指针变量指向的原变量得知


使用指针修改值

通过指针不仅可以取值，也可以修改值

使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换

定义一个交换函数,参数为a,b,类型为*int指针类型

取指针a的值，并把值赋给变量t,t此时是int类型
取b的指针值，赋给指针a指向的变量。
注意，*a此时不是a指针的值，而是a指向的变量
准备x,y两个变量，分别赋值为1和2 ，类型为int

取出x和y的地址作为参数传递给swap()函数进行调用
交换完毕时，输出x和y的值

*操作符作为右值，意义是取指针的值，
*操作符的根本意义就是操作指针指向的变量。
当操作符在右值时，就是取指向变量的值，
当操作符在左值是，就是将值设置给指向的变量

示例： 使用指针变量获取命令行的输入信息

go语言内置的flag包实现了对命令行参数的解析

通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，
经过flag包的解析后即可获取命令行的数据


创建指针变量的方法 new()函数

str := new(string)

*str = "GO"
fmt.Println(*str)
new()函数可以创建一个对应类型的指针，创建过程会分配内存，
被创建的指针指向默认值


变量逃逸分析

堆和栈

栈(stack):是一种拥有特殊规则的线性表数据结构

1.栈只允许从线性表的同一端放入或取出数据，按照后进先出(LIFO)

入栈出栈
2.

栈可用于内存分配，栈的分配和回收速度很多课

堆：后金后出


堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。
但是为此付出的代缴是分配速度较慢，而且会形成内存碎片


变量逃逸：自动决定变量分配方式，提供运行效率

取地址是发生逃逸

编译器，应该分配在堆和栈上的原则是：
变量是否被取地址
变量是否发生逃逸


变量的生命周期指的是在程序运行期间变量有效存在的时间间隔
变量的声明周期与变量的作用域：
1.全局变量：它的生命周期和整个程序的运行周期是一致的
2.局部变量：它的声明周期则是动态的，从创建整个变量的声明语句开始
到整个变量不再被引用为止
3.形式参数和函数返回值：它们都属于局部变量，在函数
被调用的时候创建，函数调用结束后被销毁


Go语言常量和const关键字

const定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此
并且只能是布尔型，数字型(整数型，浮点数和复数)和字符串型

由于编译时的限制，定义常量的表达式必须为能被编译器求职的常量表达式

const name[type] =value

可以省略类型说明符[type] 因为编译器可以根据变量的值来判断其类型


显式类定义： const b string ="abc"
隐式类型定义：  const b ="abc"


常量的值必须是能够在编译时就能够确定，可以在其赋值表达式中涉及计算过程，但是所有用于
计算的值必须在编译期间就能获得


正确的做法：  const c1 = 2/3
错误的做法   const c2 =getNumber()


和声明变量一样，可以批量声明多个常量
常量间的所有算术运算，逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或一下调用函数
都是返回常量结果：len,cap,real,imag,complex,unsafe.Sizeof


因为它们的值在编译期就确定了，因此常量可以是构成类型的一部分，

一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型
time.Duration是一个命名类型，底层类型是int64,time.Minute是对应类型的常量
可以通过%T 参数打印类型信息

如果是批量声明的常量，除了第一个外其他的常量右边的初始化表达式都可以省略，
如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样



iota 常量生成器

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，
但是不用没写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，
iota将会被设置为0,然后在每一个有常量声明的行加一


无类型常量

通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而且
不需要显式的类型转换

go语言可以使用const常量 iota, 枚举类型

iota的起始值为0，一般情况下也建议枚举从0开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用


一个const声明内的每一行常量声明，将会自耦东套用前面的iota格式，并自动增加
类似电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，

iota不仅可以生成每次增加1的枚举值，还可以利用iota来做一些强大的枚举常量值生成器

iota使用了一个移位操作，每次将上一次的值左移动一位(二进制位)，以得出每一位的常量值
将3个枚举按照常量输出，分别输出2,4,8 都是将1每次左移动一位的结果

将枚举值按二进制格式输出，可以清晰地看到每一位的变化


将枚举值转换为字符串

枚举是一个独立的类型，可以通过枚举值获取该值对应的字符串

将int声明为ChipType芯片类型
将const里定义的常量值设为ChipType类型，且从0开始，每行值加1
定义ChipType类型的方法String()，返回值为字符串类型
使用switch语句判断当前的ChitType类型的值，返回对应的字符串
按整型的格式输出CPU的值


String()方法的ChipType在使用上和普通的常量没有区别
当这个类型需要显示字符串时，go语言会自动寻找String()方法并进行调用

区分类型别名与类型定义

type TypeAlias =Type
类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型
类型别名与类型定义 的区别

通过type关键字的定义，会形成一种新的类型，新类型也有int类型的特性

类型别名是指换个名字，跟Int类型还是一样

使用%T格式化参数，打印变量本身的类型

本地类型不能定义方法

在结构体成员嵌入时使用别名
定义商标结构

为商标结构添加Show()方法
为Brand定义一个别名FakeBrand
定义车辆结构Vehicle,嵌入FakeBrand和Brand结构

将Vechicle实例化为a
显式调用Vehicle中FakeBrand的Show()方法
使用反射取变量a的反射类型对象，以查看其他成员类型
遍历a的结构体程雨涵


注释工具godoc
标识符，操作符，分隔符，关键字，字面量

break,default,func,interface,select,case
defer,go,map,struct,chan,else,goto,package,switch
const,fallthrough,if,range,type,
continue,for,import,return ,var

在go语言中还存在着一些特殊的标识符，预定义标识符


append,bool,byte,cap,close,complex,complex64
complex128,unit16,copy,false,float32,float64,int,int8,int16
unit32,init64,iota,len,make,new,nil,panic,
unit64,print,println,real,recover,string,true,unit,unit8,uintptr


strconv包：字符串和数值类型的相互转换
常用函数有Atoi(),Itia(),parse系列函数，format系列函数，append系列函数


sring 与int类型之间的转

Itoa():整型转字符串

func Itoa(i int) string

Atoi():字符串转整型
func Atoi(s string)(i int,err error)

通过函数签名可以看出Atoi()函数有两个返回值，i为转换成功的整型，err在转换成功是为空转换
失败时为相应的错误信息

Parse系列函数

Parse系列函数用于将字符串转换为指定类型的值，其中包括Parsebool()
ParseFloat()

ParseBool()函数用于将字符串转换为bool类型的值，它只能接受1,0,t,f,T,F,true,false
,True,False,TRUE,FALSE，其他的值均返回错误

func ParseBool(str string)(value bool,err error)

ParseInt()函数用于返回字符串表示的整数值(可以包含正负号)

func ParseInt(s string,base int,bitSize int)(i int64,err error)


base指定进制，取值范围为2-36 .如果base为0,则会从字符串前置判断，"0X"是16进制
"0"是8进制，否则是10进制

bitSize指定结果必须能无溢出赋值的整数类型，0，8,16,32,64分别代表int,int8,int16
int32,int64

返回的err是*NumErr类型的，如果语法有误，err.Error =ErrSyntax,
如果结果超出类型范围err.Error= ErrRange

ParseUnit() 不接受正负号，用于无符号整型

func ParseUint(s string,base int,bitSize int)(n uint64,err error)

变量在一定程度上能满足函数及代码要求。复杂类型一般情况下具有各种形式的存储和处理数据的功能，称为"容器"

容器是以标准库的方式提供，

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为
数组的长度是固定的，很少直接使用数组

和数组对应的类型是Slice(切片)，slice是可以增长和收缩的动态序列


数据声明
var 数组变量名[元素数据]Type

数组变量名：数组声明及使用时的变量名
元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素
数量不能含有到运行时才能确认大小的数值

Type:可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组

数组的每个元素都可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置，
内置函数len()可以返回数组中元素的个数


默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说是0
同时也可以使用数组字面值语法，用一组值来初始化数组


在数组的定义中，如果在长度的位置出现："..."省略号，则表示数组长度是根据初始化值的个数来计算

q := [...]int{1,2,3}

fmt.Printf("%T\n",q)

数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型，
数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定

比较两个数组是否相等

如果两个数组类型相同(包括数组的长度，数组中元素的类型)的情况下，可以直接通过
比较运算符(==,!=)来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的
不能比较两个不同类型的数组，否则程序将无法完成编译


遍历数组---访问每一个数组元素

遍历数组和遍历切片类似







