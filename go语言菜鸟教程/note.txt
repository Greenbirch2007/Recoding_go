
go语言菜鸟教程第二遍


1.包声明
2. 引入包
3. 函数
4. 变量
5. 语句 & 表达式
6. 注释

go语言可以由多个标记组成,可以是关键字,标识符,常量,字符串,符号


数据类型

布尔型 true false
数字类型  int float32
字符串类型  UTF-8编码标识Unicode文本
派生类型
a.指针类型(Pointer)
b.数组类型
c.结构化类型(struct)
d.Channel类型
e.函数类型
f.切片类型
g.接口类型(interface)
h.Map类型


变量可以通过变量名访问
go语言变量名,由字母,数字,下划线组成,其中首个字符不能为数字

声明变量的一般形式是使用var关键字


可以一次声明多个变量

变量声明
1, 指定变量类型,如果灭有初始化,则变量默认为零值

零值就是变量没有做初始化时系统默认设置的值

声明一个变量并初始化   没有初始化就为零值  bool零值为false


数值类型(包括complex64/128) 为)
布尔类型为false
字符串为""(空字符串) nil

error是接口

prinln和printf
println:可以打印出字符串,和变量
printf:只打印出格式化的字符串,可以输出字符串类型的变量

printf要在需要格式化的地方输出,
其他直接输出变量或直接输出字符串的

要格式化就用printf
不用格式化就用println
2. 根据值自行判定变量类型
3. 省略var,注意:= 左侧如果没有声明新的变量,就产生编译错误

:= 要go自己判断数据而理性

多变量僧们

类型相同多个变量,非全局变量

不需要显示声明类型,自动判断

因式分解关键字的写法一般用于声明全局变量


注意不需要声明格式的只能在函数体中出现

值类型和引用类型
所有像int,float,bool,string这些节本类型都属于值类型
使用这些类型的变量直接指向存在内存中的值

当使用等号 = 将一个变量的值赋值给另一个变量时,如j=i,实际上
是在内存中将i的值进行了拷贝

可以通过&i来获取变量i的内存地址,
值类型的变量的值存储在栈中

内存地址会根据机器的不同而有所不同,甚至相同的程序在不同的
机器上执行后也会有不同的内存地址.
因为每台机器可能有不同的存储器布局,并且位置分配也可能不同
更复杂的数据通常会需要使用多个字,这些数据一般使用引用类型保存
一个引用类型的变量r1存储的是r1的值所在的内存地址(数字)
或内存地址中第一个字所在的位置


这个内存你地址称之为指针
同一个引用类型的指针指向的多个字可以是在连续的
内存地址中(内存布局是连续的,)这也是计算效率最高的一种
存储形式;也可以将这些字分散存放在内存中,每个字都指示了
下一个字所在的内存地址

当使用赋值语句r2=r1时,只有引用(地址)被复制

如果r1的值被改变了,那么这个值的所有引用都会指向被修改后的
内存

简短形式,使用:=赋值操作符

语言常量(不会改变的量)

常量还可以用作枚举

常量可以用Len(),unsafe.Sizeof()
常量表达式中,函数必须是内置函数,否则编译不够


iota,特殊常量,可以认为是一个可以被编译器修改的常量

iota在const关键字出现时将被重置为0(const内部的第一行之前)
const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)

==
!=
>
<
>=
<=

&& || !


位运算

&  | ^ << >>  

= += -= *= /= %= <<= >>= &= ^= |=

&  返回变量存储地址  &a;将给出变量的实际地址

 * 指针变量  *a,是一个指针地址

指针变量*和地址值&的区别:
指针变量保存一个地址值,会分配独立的内存来存储一个整型数字
当变量前面有*标识时,才等同于&的用法,否则会直接输出一个整型数字

switch语句用于基于不同条件执行不同动作,每一个case分支都是唯一的,

switch 语句执行的过程从上而下,直到找到匹配项,匹配项后面也不需要再加break

switch默认情况下case最后自带break语句,匹配成功后就不会执行
其他case,如果我们需要执行后面的case,可以使用fallthrough


同类型的不同值

switch语句还可以被用来type-switch来判断某个
interface变量中实际存储的变量类型

switch x.(type){
	case type:
		statement(s);
	case type:
		statement(s);
	default:	
		statement(s);}


fallthrough

使用fallthrough会强制执行后面的case语句,
fallthrough不会判断下一条case的表达式结果是否为truhe 


1. 支持多条件匹配
2.不同的case之间不使用break分隔,默认只会执行一个case
3.如果想要执行多个case,需要使用fallthrough关键字,也可用break终止

select 是go中的一个控制结构,
每个case必须是一个通信操作,要么是发送要么是接收

select 随机执行一个可运行的case.如果没有case可运行,它将阻塞,直到有case可运行.
一个默认的子句应该总是可运行的

select {
	case communication clause;
		statetment(s);
	case communication clause;		
		statement(s);	
	default:
		statement(s);
}


每个case都必须是一个通信
所有channel表达式都会被求值
所有被发送的表达式都会被求值

如果任意某个通信可以进行,它就执行,其他被忽略

如果有多个case都可以运行,select会随机公平地选出一个执行.其他不会执行

否则:
1. 如果有default 子句,则执行该语句
2. 如果没有default子句,select 将阻塞,直到某个通信可以运行;
go不会重新对channel或值进行求值

select 会循环检测条件,如果有满足执行并退出,否则一直循环检测


for循环 重复执行语句块
循环嵌套:  在for循环中嵌套一个或多个for循环

循环控制语句可以控制循环体内语句的执行过程

break 语句:经常用于中断当前for循环或跳出switch语句
continue语句: 跳过当前循环的剩余语句,然后继续进行下一轮循环
goto语句:将控制转移到被标记的语句

for init;condition;post{}
for condition{}
for {}

init:一般为赋值表达式,给控制变量赋初值
condition:关系表达式或逻辑表达式,循环控制条件
post:一般为赋值表达式,给控制变量增量或减量

for-each range循环
这种格式的循环可以对字符串,数组,切片等进行迭代输出元素


break:
1.用于循环语句中跳出循环,并开始执行循环之后的语句
2.break在switch(开关语句)中在执行一条case后跳出语句的作用

在多重循环中,可以用标号label标出想break的循环
continue不是跳出循环,而是跳过当前循环执行下一次循环语句

for循环中,执行continue语句会触发for增量语句的执行
在多重循环中,可以用标号label标出想continue的循环

goto语句可以无条件地转移到过程中指定的行
goto语句通常与条件语句配合使用.可用来实现条件转移,构成循环,跳出循环体等
在结构体


Go 语言函数




