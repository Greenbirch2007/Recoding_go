
go语言菜鸟教程第二遍


1.包声明
2. 引入包
3. 函数
4. 变量
5. 语句 & 表达式
6. 注释

go语言可以由多个标记组成,可以是关键字,标识符,常量,字符串,符号


数据类型

布尔型 true false
数字类型  int float32
字符串类型  UTF-8编码标识Unicode文本
派生类型
a.指针类型(Pointer)
b.数组类型
c.结构化类型(struct)
d.Channel类型
e.函数类型
f.切片类型
g.接口类型(interface)
h.Map类型


变量可以通过变量名访问
go语言变量名,由字母,数字,下划线组成,其中首个字符不能为数字

声明变量的一般形式是使用var关键字


可以一次声明多个变量

变量声明
1, 指定变量类型,如果灭有初始化,则变量默认为零值

零值就是变量没有做初始化时系统默认设置的值

声明一个变量并初始化   没有初始化就为零值  bool零值为false


数值类型(包括complex64/128) 为)
布尔类型为false
字符串为""(空字符串) nil

error是接口

prinln和printf
println:可以打印出字符串,和变量
printf:只打印出格式化的字符串,可以输出字符串类型的变量

printf要在需要格式化的地方输出,
其他直接输出变量或直接输出字符串的

要格式化就用printf
不用格式化就用println
2. 根据值自行判定变量类型
3. 省略var,注意:= 左侧如果没有声明新的变量,就产生编译错误

:= 要go自己判断数据而理性

多变量僧们

类型相同多个变量,非全局变量

不需要显示声明类型,自动判断

因式分解关键字的写法一般用于声明全局变量


注意不需要声明格式的只能在函数体中出现

值类型和引用类型
所有像int,float,bool,string这些节本类型都属于值类型
使用这些类型的变量直接指向存在内存中的值

当使用等号 = 将一个变量的值赋值给另一个变量时,如j=i,实际上
是在内存中将i的值进行了拷贝

可以通过&i来获取变量i的内存地址,
值类型的变量的值存储在栈中

内存地址会根据机器的不同而有所不同,甚至相同的程序在不同的
机器上执行后也会有不同的内存地址.
因为每台机器可能有不同的存储器布局,并且位置分配也可能不同
更复杂的数据通常会需要使用多个字,这些数据一般使用引用类型保存
一个引用类型的变量r1存储的是r1的值所在的内存地址(数字)
或内存地址中第一个字所在的位置


这个内存你地址称之为指针
同一个引用类型的指针指向的多个字可以是在连续的
内存地址中(内存布局是连续的,)这也是计算效率最高的一种
存储形式;也可以将这些字分散存放在内存中,每个字都指示了
下一个字所在的内存地址

当使用赋值语句r2=r1时,只有引用(地址)被复制

如果r1的值被改变了,那么这个值的所有引用都会指向被修改后的
内存

简短形式,使用:=赋值操作符

语言常量(不会改变的量)

常量还可以用作枚举

常量可以用Len(),unsafe.Sizeof()
常量表达式中,函数必须是内置函数,否则编译不够


iota,特殊常量,可以认为是一个可以被编译器修改的常量

iota在const关键字出现时将被重置为0(const内部的第一行之前)
const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)

==
!=
>
<
>=
<=

&& || !


位运算

&  | ^ << >>  

= += -= *= /= %= <<= >>= &= ^= |=

&  返回变量存储地址  &a;将给出变量的实际地址

 * 指针变量  *a,是一个指针地址

指针变量*和地址值&的区别:
指针变量保存一个地址值,会分配独立的内存来存储一个整型数字
当变量前面有*标识时,才等同于&的用法,否则会直接输出一个整型数字

switch语句用于基于不同条件执行不同动作,每一个case分支都是唯一的,

switch 语句执行的过程从上而下,直到找到匹配项,匹配项后面也不需要再加break

switch默认情况下case最后自带break语句,匹配成功后就不会执行
其他case,如果我们需要执行后面的case,可以使用fallthrough


同类型的不同值

switch语句还可以被用来type-switch来判断某个
interface变量中实际存储的变量类型

switch x.(type){
	case type:
		statement(s);
	case type:
		statement(s);
	default:	
		statement(s);}


fallthrough

使用fallthrough会强制执行后面的case语句,
fallthrough不会判断下一条case的表达式结果是否为truhe 


1. 支持多条件匹配
2.不同的case之间不使用break分隔,默认只会执行一个case
3.如果想要执行多个case,需要使用fallthrough关键字,也可用break终止

select 是go中的一个控制结构,
每个case必须是一个通信操作,要么是发送要么是接收

select 随机执行一个可运行的case.如果没有case可运行,它将阻塞,直到有case可运行.
一个默认的子句应该总是可运行的

select {
	case communication clause;
		statetment(s);
	case communication clause;		
		statement(s);	
	default:
		statement(s);
}


每个case都必须是一个通信
所有channel表达式都会被求值
所有被发送的表达式都会被求值

如果任意某个通信可以进行,它就执行,其他被忽略

如果有多个case都可以运行,select会随机公平地选出一个执行.其他不会执行

否则:
1. 如果有default 子句,则执行该语句
2. 如果没有default子句,select 将阻塞,直到某个通信可以运行;
go不会重新对channel或值进行求值

select 会循环检测条件,如果有满足执行并退出,否则一直循环检测


for循环 重复执行语句块
循环嵌套:  在for循环中嵌套一个或多个for循环

循环控制语句可以控制循环体内语句的执行过程

break 语句:经常用于中断当前for循环或跳出switch语句
continue语句: 跳过当前循环的剩余语句,然后继续进行下一轮循环
goto语句:将控制转移到被标记的语句

for init;condition;post{}
for condition{}
for {}

init:一般为赋值表达式,给控制变量赋初值
condition:关系表达式或逻辑表达式,循环控制条件
post:一般为赋值表达式,给控制变量增量或减量

for-each range循环
这种格式的循环可以对字符串,数组,切片等进行迭代输出元素


break:
1.用于循环语句中跳出循环,并开始执行循环之后的语句
2.break在switch(开关语句)中在执行一条case后跳出语句的作用

在多重循环中,可以用标号label标出想break的循环
continue不是跳出循环,而是跳过当前循环执行下一次循环语句

for循环中,执行continue语句会触发for增量语句的执行
在多重循环中,可以用标号label标出想continue的循环

goto语句可以无条件地转移到过程中指定的行
goto语句通常与条件语句配合使用.可用来实现条件转移,构成循环,跳出循环体等
在结构体


Go 语言函数

函数是基本的代码块,用于执行一个任务

go 语言最少有一个main()函数
逻辑上每个哈数执行的是指定的任务
函数声明告诉了编译器函数的名称,返回类型和参数

标准库提供了很多内置的函数,比如,len()函数可以接受不同类型参数
并返回该类型的长度.如果我们传入的是字符串则返回字符串的长度,如果
传入的是数组,则返回数组中包含元素的个数

func function_name([parameter list]) [return_types]{
	函数体
}


func:函数由func开始声明
function_name:函数名称,函数名和参数列表一起构成函数签名
parameter_list:参数列表,参数就像一个占位符,当函数被调用时,
可以将值传递给参数,这个值被称为实际参数.参数列表指定的是参数类型,
顺序,及参数个数.参数是可选的,参数也可以不包含参数

return_types:返回类型,函数返回一列值.return_types是该列值的数据类型
有写功能不需要返回值,这种情况下return_types不是必须的

函数体:函数定义的代码集合

调用函数,就是向函数传递参数,并返回值

go函数可以返回多个值

函数参数

函数如果使用参数,该变量可称为函数的形参
形参就像定义在函数体内的局部变量
调用函数,可以通过两种方式传递阐述

值传递:是指在调用函数是将实际参数复制一份传递到函数中,这样在函数中
如果对参数进行修改,将不会影响到实际参数

引用传递:是指在调用时将实际采纳数的地址传递给函数中,那么在函数中对参数
所进行的修改,将影响到实际参数

默认情况下,go语言使用的是值传递,即在调用过程中不会影响到实际参数

func swap(x,y int) int {
	var temp int
	temp =x //保存x的值
	x =y  // 将y值赋给x
	y = temp // 将temp值赋给y
	return temp;

引用传递是值在调用函数时将实际参数的地址传递到函数中,那么在函数中对参数
所进行对的修,将影响到实际参数

引用传递指针参数传递到函数内,


//定义交换值函数

func swap(x *int,y *int){
	var temp int
	temp =*x //保持x地址上的值
	*x =*y // 将y值赋给x
	*y = temp //将temp 值赋给y
}


函数用法

函数作为另一个函数的实参:函数定义后可作为另一个函数的实参数传入
闭包:闭包是匿名函数,可在动态编程中使用
方法：方法就是一个包含了接受者的函数

go语言可以灵活创建函数，并作为另一个函数的实参

函数作为参数传递，实现回调

go语言支持匿名函数，可作为闭包．匿名函数是一个"内联"语句或表达式
匿名函数的优越性在于可以直接使用函数的变量，不必申明

创建了函数getS()，返回另外一个函数，该函数的目的是在闭包中递增i变量

带参数的闭包函数调用

闭包带参数补齐

go语言中同时有函数和方法．一个方法就是一个包含了接受者的函数，
接受者可以是命名类型或结构体类型的一个值或一个指针．
所有给定类型的方法属于该类型的方法集

func (variable_name variable_data_type)function_name()[return_type]
{函数体}


go没有面向对象，但是c++,java中，实现类的方法都是编译器隐式的给函数
加一个this指针，而在go中，这个this需要明确的申明出



ｇｏ语言变量的作用域

作用域为已经声明标识符所表示的常量，类型，变量，函数或包在源代码中的作用范围

go语言中变量可以在三个地方声明：
１．局部变量：函数内定义的变量(可以简化赋值)
２．全局变量:函数外定义的变量
3. 形式参数：函数定义中的变量


局部变量

在函数体内声明的变变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量

全局变量在函数体外声明，全局变量可以在整个包甚至外部包(被导出后)使用
全局变量可以在任何函数中使用，

go语言程序中全局变量与局部变量名称可以相同，但是函数内局部变量会被优先考虑


形式参数作为函数的局部变量来使用

初始化局部和全局变量

不同类型的局部和全局变量值默认不用

数据类型　　　初始化默认值
int          0
float32        0
pointer        nil


go语言提供了数组类型的数据结构
数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，
这种类型可以是任意的原始类型，例如整型，字符串或自定义类型

使用n[0],...



