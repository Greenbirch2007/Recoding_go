
go语言菜鸟教程第二遍


1.包声明
2. 引入包
3. 函数
4. 变量
5. 语句 & 表达式
6. 注释

go语言可以由多个标记组成,可以是关键字,标识符,常量,字符串,符号


数据类型

布尔型 true false
数字类型  int float32
字符串类型  UTF-8编码标识Unicode文本
派生类型
a.指针类型(Pointer)
b.数组类型
c.结构化类型(struct)
d.Channel类型
e.函数类型
f.切片类型
g.接口类型(interface)
h.Map类型


变量可以通过变量名访问
go语言变量名,由字母,数字,下划线组成,其中首个字符不能为数字

声明变量的一般形式是使用var关键字


可以一次声明多个变量

变量声明
1, 指定变量类型,如果灭有初始化,则变量默认为零值

零值就是变量没有做初始化时系统默认设置的值

声明一个变量并初始化   没有初始化就为零值  bool零值为false


数值类型(包括complex64/128) 为)
布尔类型为false
字符串为""(空字符串) nil

error是接口

prinln和printf
println:可以打印出字符串,和变量
printf:只打印出格式化的字符串,可以输出字符串类型的变量

printf要在需要格式化的地方输出,
其他直接输出变量或直接输出字符串的

要格式化就用printf
不用格式化就用println
2. 根据值自行判定变量类型
3. 省略var,注意:= 左侧如果没有声明新的变量,就产生编译错误

:= 要go自己判断数据而理性

多变量僧们

类型相同多个变量,非全局变量

不需要显示声明类型,自动判断

因式分解关键字的写法一般用于声明全局变量


注意不需要声明格式的只能在函数体中出现

值类型和引用类型
所有像int,float,bool,string这些节本类型都属于值类型
使用这些类型的变量直接指向存在内存中的值

当使用等号 = 将一个变量的值赋值给另一个变量时,如j=i,实际上
是在内存中将i的值进行了拷贝

可以通过&i来获取变量i的内存地址,
值类型的变量的值存储在栈中

内存地址会根据机器的不同而有所不同,甚至相同的程序在不同的
机器上执行后也会有不同的内存地址.
因为每台机器可能有不同的存储器布局,并且位置分配也可能不同
更复杂的数据通常会需要使用多个字,这些数据一般使用引用类型保存
一个引用类型的变量r1存储的是r1的值所在的内存地址(数字)
或内存地址中第一个字所在的位置


这个内存你地址称之为指针
同一个引用类型的指针指向的多个字可以是在连续的
内存地址中(内存布局是连续的,)这也是计算效率最高的一种
存储形式;也可以将这些字分散存放在内存中,每个字都指示了
下一个字所在的内存地址

当使用赋值语句r2=r1时,只有引用(地址)被复制

如果r1的值被改变了,那么这个值的所有引用都会指向被修改后的
内存

简短形式,使用:=赋值操作符

语言常量(不会改变的量)

常量还可以用作枚举

常量可以用Len(),unsafe.Sizeof()
常量表达式中,函数必须是内置函数,否则编译不够


iota,特殊常量,可以认为是一个可以被编译器修改的常量

iota在const关键字出现时将被重置为0(const内部的第一行之前)
const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)

==
!=
>
<
>=
<=

&& || !


位运算

&  | ^ << >>  

= += -= *= /= %= <<= >>= &= ^= |=

&  返回变量存储地址  &a;将给出变量的实际地址

 * 指针变量  *a,是一个指针地址

指针变量*和地址值&的区别:
指针变量保存一个地址值,会分配独立的内存来存储一个整型数字
当变量前面有*标识时,才等同于&的用法,否则会直接输出一个整型数字

switch语句用于基于不同条件执行不同动作,每一个case分支都是唯一的,

switch 语句执行的过程从上而下,直到找到匹配项,匹配项后面也不需要再加break

switch默认情况下case最后自带break语句,匹配成功后就不会执行
其他case,如果我们需要执行后面的case,可以使用fallthrough


同类型的不同值

switch语句还可以被用来type-switch来判断某个
interface变量中实际存储的变量类型

switch x.(type){
	case type:
		statement(s);
	case type:
		statement(s);
	default:	
		statement(s);}


fallthrough

使用fallthrough会强制执行后面的case语句,
fallthrough不会判断下一条case的表达式结果是否为truhe 


1. 支持多条件匹配
2.不同的case之间不使用break分隔,默认只会执行一个case
3.如果想要执行多个case,需要使用fallthrough关键字,也可用break终止

select 是go中的一个控制结构,
每个case必须是一个通信操作,要么是发送要么是接收

select 随机执行一个可运行的case.如果没有case可运行,它将阻塞,直到有case可运行.
一个默认的子句应该总是可运行的

select {
	case communication clause;
		statetment(s);
	case communication clause;		
		statement(s);	
	default:
		statement(s);
}


每个case都必须是一个通信
所有channel表达式都会被求值
所有被发送的表达式都会被求值

如果任意某个通信可以进行,它就执行,其他被忽略

如果有多个case都可以运行,select会随机公平地选出一个执行.其他不会执行

否则:
1. 如果有default 子句,则执行该语句
2. 如果没有default子句,select 将阻塞,直到某个通信可以运行;
go不会重新对channel或值进行求值

select 会循环检测条件,如果有满足执行并退出,否则一直循环检测


for循环 重复执行语句块
循环嵌套:  在for循环中嵌套一个或多个for循环

循环控制语句可以控制循环体内语句的执行过程

break 语句:经常用于中断当前for循环或跳出switch语句
continue语句: 跳过当前循环的剩余语句,然后继续进行下一轮循环
goto语句:将控制转移到被标记的语句

for init;condition;post{}
for condition{}
for {}

init:一般为赋值表达式,给控制变量赋初值
condition:关系表达式或逻辑表达式,循环控制条件
post:一般为赋值表达式,给控制变量增量或减量

for-each range循环
这种格式的循环可以对字符串,数组,切片等进行迭代输出元素


break:
1.用于循环语句中跳出循环,并开始执行循环之后的语句
2.break在switch(开关语句)中在执行一条case后跳出语句的作用

在多重循环中,可以用标号label标出想break的循环
continue不是跳出循环,而是跳过当前循环执行下一次循环语句

for循环中,执行continue语句会触发for增量语句的执行
在多重循环中,可以用标号label标出想continue的循环

goto语句可以无条件地转移到过程中指定的行
goto语句通常与条件语句配合使用.可用来实现条件转移,构成循环,跳出循环体等
在结构体


Go 语言函数

函数是基本的代码块,用于执行一个任务

go 语言最少有一个main()函数
逻辑上每个哈数执行的是指定的任务
函数声明告诉了编译器函数的名称,返回类型和参数

标准库提供了很多内置的函数,比如,len()函数可以接受不同类型参数
并返回该类型的长度.如果我们传入的是字符串则返回字符串的长度,如果
传入的是数组,则返回数组中包含元素的个数

func function_name([parameter list]) [return_types]{
	函数体
}


func:函数由func开始声明
function_name:函数名称,函数名和参数列表一起构成函数签名
parameter_list:参数列表,参数就像一个占位符,当函数被调用时,
可以将值传递给参数,这个值被称为实际参数.参数列表指定的是参数类型,
顺序,及参数个数.参数是可选的,参数也可以不包含参数

return_types:返回类型,函数返回一列值.return_types是该列值的数据类型
有写功能不需要返回值,这种情况下return_types不是必须的

函数体:函数定义的代码集合

调用函数,就是向函数传递参数,并返回值

go函数可以返回多个值

函数参数

函数如果使用参数,该变量可称为函数的形参
形参就像定义在函数体内的局部变量
调用函数,可以通过两种方式传递阐述

值传递:是指在调用函数是将实际参数复制一份传递到函数中,这样在函数中
如果对参数进行修改,将不会影响到实际参数

引用传递:是指在调用时将实际采纳数的地址传递给函数中,那么在函数中对参数
所进行的修改,将影响到实际参数

默认情况下,go语言使用的是值传递,即在调用过程中不会影响到实际参数

func swap(x,y int) int {
	var temp int
	temp =x //保存x的值
	x =y  // 将y值赋给x
	y = temp // 将temp值赋给y
	return temp;

引用传递是值在调用函数时将实际参数的地址传递到函数中,那么在函数中对参数
所进行对的修,将影响到实际参数

引用传递指针参数传递到函数内,


//定义交换值函数

func swap(x *int,y *int){
	var temp int
	temp =*x //保持x地址上的值
	*x =*y // 将y值赋给x
	*y = temp //将temp 值赋给y
}


函数用法

函数作为另一个函数的实参:函数定义后可作为另一个函数的实参数传入
闭包:闭包是匿名函数,可在动态编程中使用
方法：方法就是一个包含了接受者的函数

go语言可以灵活创建函数，并作为另一个函数的实参

函数作为参数传递，实现回调

go语言支持匿名函数，可作为闭包．匿名函数是一个"内联"语句或表达式
匿名函数的优越性在于可以直接使用函数的变量，不必申明

创建了函数getS()，返回另外一个函数，该函数的目的是在闭包中递增i变量

带参数的闭包函数调用

闭包带参数补齐

go语言中同时有函数和方法．一个方法就是一个包含了接受者的函数，
接受者可以是命名类型或结构体类型的一个值或一个指针．
所有给定类型的方法属于该类型的方法集

func (variable_name variable_data_type)function_name()[return_type]
{函数体}


go没有面向对象，但是c++,java中，实现类的方法都是编译器隐式的给函数
加一个this指针，而在go中，这个this需要明确的申明出



ｇｏ语言变量的作用域

作用域为已经声明标识符所表示的常量，类型，变量，函数或包在源代码中的作用范围

go语言中变量可以在三个地方声明：
１．局部变量：函数内定义的变量(可以简化赋值)
２．全局变量:函数外定义的变量
3. 形式参数：函数定义中的变量


局部变量

在函数体内声明的变变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量

全局变量在函数体外声明，全局变量可以在整个包甚至外部包(被导出后)使用
全局变量可以在任何函数中使用，

go语言程序中全局变量与局部变量名称可以相同，但是函数内局部变量会被优先考虑


形式参数作为函数的局部变量来使用

初始化局部和全局变量

不同类型的局部和全局变量值默认不用

数据类型　　　初始化默认值
int          0
float32        0
pointer        nil


go语言提供了数组类型的数据结构
数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，
这种类型可以是任意的原始类型，例如整型，字符串或自定义类型

使用n[0],...

声明数组
初始化数组
访问数组元素

多维数组：最简单的多维数组是二维数组
向函数传递数组：可以向函数传递数组参数

声明数组

go语言数组声明需要指定元素类型及元素个数，

var variable_name[SIZE] variable_type

上面是一维数组的定义方式。
var balacne[10] float32

初始化数组

var balance  = [5]float32{1000.0,2.0,3.4,7.0,50.0}


初始化数组中{}中的元素个数不能大于[]中的数字

如果忽略[]中的数字不设置数组大小，GO语言会根据元素个数来设置数组的大小

var balance [...]float32{1000.0,2.0,3.4,7.0,50.0}


数组元素可以通过索引(位置)来读取(或修改)，索引从0开始，第一个元素
索引为0

访问数组元素
数组元素可以通过索引位置来读取。格式为数组后加中括号，中括号中
为索引的值


var salary float32 = balance[9]

二维数组

var arrayName[x][y] variable_type

二维数组可以认为是一个表格，x为行，y为列

二维数组中的元素可以通过a[i][j]来访问

初始化二维数组

多维数组可通过大括号来初始值。

a = [3][4]int{
	{0,1,2,3}, //第一行索引为0
	{4,5,6,7}, // 第二行索引为1
	{8,9,10,11}}


访问二维数组

二维数组通过指定坐标来访问。如数组中的行索引与列索引

val := a[2][3]

或
var value int = a[2][3]


以上实例访问了二维数组val第三行的第四个元素。

二维数组可以使用循环嵌套来输出元素

向函数传递数组参数，需要在函数定义时，声明形参维数组，
可以通过以下两种方式来声明：

1. 形参设定数组大小：
void myFunction(param [10]int){}

2. 形参未设定数组大小

void myFunction(param []int){}

实例中函数接收整型数组参数，另一个参数指定了数组元素的根数，
并返回平均值

浮点数计算输出有一定的偏差，也可以转整型来设置精度

go语言中使用指针可以更简单的执行一些芮乃伟

变量是一种使用方便的占位符，用于引用计算机内存地址
go语言的取地址符是&,放到一个变量前使用就会返回相应变量的内存地址



什么是指针


一个指针变量指向了一个值的内存地址

类似与变量和常量，在使用指针前需要声明指针，

var var_name *var-type

var-type为指针类型，var_name为指针变量名
*号用于指定变量作为一个指针

var ip *int //指向整型
var fp *float32 // 指向浮点型


如何使用指针

指针使用流程：
1.定义指针变量
2 为指针变量赋值
3. 访问指针变量中指向地址的值

在指针类型前面加上*号(前缀)来获取指针所指向的内容

go空指针

当一个指针被定义后没有分配到任何变量时，它的值为nil

nil指针称为空指针

nil在概念上和其他语言的null,None,nil,NULL都一样，都指代零值或空值

一个指针变量通常写为ptr

空指针判断

if (ptr != nil) //ptr不是空指针
if (ptr == nil) // ptr是空指针

go指针数组  可以一定要一个指针数组来存储地址
go指向指针的指针   go支持指向指针的指针
go向函数传递指针参数  通过引用或地址传参，在函数调用时可以改变其值


还有一种情况，可能需要保存数组，就需要使用到指针


下面声明了整型指针数组

var ptr [MAX]*int;

ptr为整型指针数组。因此每个元素都指向一个值。
实例的三个整数将存储在指针数组中

创建指针数组的时候，不适合用range循环

问题在于range循环的实现逻辑引起的.跟for循环不一样的地方
在于range循环中x变量是临时变量。range循环只是将值
拷贝到x变量中。因此内存地址都是一样的


go语言指向指针的指针

如果一个指针变量存放的又是另一个指针变量的地址，则称
这个指针变量为指向指针的的指针变量


当定义一个指向指针的指着变量时，第一个指针存放第二个指针的地址，
第二个指针存放变量的地址


指向指针的指针变量声明如下：
var ptr **int;


以上指向指针的指针变量为整型

访问指向指针的指针变量值需要使用两个*号

go语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可

实例，如何向函数传递指针，并在函数调用后修改函数内的值


go语言结构体

go语言中数组可以存储同一类型对的数据，但在结构体中可以为不同项
定义不同的数据类型

结构体是由一系列具有相同类型或不同类型的数据构成的数据集合

结构体表示一项记录，比如保存图书馆的书记记录，每本书的特性

Title:标题
Author:作者
Subject:学科
ID:书籍ID

定义结构体


结构体定义需要使用type和struct语句。
struct语句定义一个新的数据类型，结构体中有一个或多个成员。
type语句设定了结构体的名称

type struct_variable_type struct{
	member definiton
}



一旦定义了结构体类型，它就能用于变量的声明，

variable_name := struct_variable_type{value1,value2,...}
variable_name := struct_variable_type{key1:value1,key2:value2...}

忽略的字段为0或为空

访问结构体成员

如果要访问结构体成员，需要使用点好.操作符号

结构体.成员名

结构体类型变量使用struct关键字定义


结构体作为函数参数

结构体指针 类似于其他指针变量

var struct_pointer *Books

以上定义的指针变量可以存储结构体变量的地址。
查看结构体变量地址，可以将&符号放置于结构体变量前

struct_pointer = &Book1

使用结构体指针访问结构体成员，使用"."操作符

struct_pointer.title

结构体也可以作为参数的值传递
struct类似于java中的类，可以在struct中定义成员变量
要访问成员变量，可以有两种方式：
1.通过struct 变量.成员变量来访问
2.通过 struct指针.成员变量来访问

不需要通过getter,setter来设置访问权限

go语言切片是数组的抽象

go数组的长度不可改变，在特定场景中这样的集合就不太使用。
go中提供了一种灵活，工的内置类型切片("动态数组")
与数组相比切片的长度是不固定的，可以追加元素，在追加时
可能使用切片的容量增大

定义切片

可以声明一个未指定大小的数组来定义切片

var identifier []type


切片不需要说明长度

或使用make()函数来创建切片

var slice1 []type = make([]type,len)
也可以简写为
slice1 := make([]type,len)

也可以指定容量，其中capacity为可选参数

make([]T,length,capacity)

这里len是数组的长度并且也是切片的初始长度


切片初始化

s :=[] int {1,2,3}


直接初始化切片，[]表示是切片类型,{1,2,3}初始化
依次是1,2,3 ,其中cap=len=3


s := arr[:]

初始化切片s,是数组arr的引用
s := arr[startIndex:endIndex]

将 arr中从下标startIndex到endIndex-1下的元素
创建一个新的切片

s := arr[startIndex:]

默认startIndex时将表示arr的第一个元素开始

s1 := s[startIndex:endIndex]


通过切片s初始化切片s1

s := make([]int,len,cap)

通过内置函数make()初始化切片s,[]int标识为其元素类型为int的切片

len()和cap()函数

切片是可索引的，并且可以由len()方法获取长度
切片提供了计算容量的方法cap()可以测量切片最长可以达到多少

空(nil)切片

一个切片在未初始化之前默认为nil,长度为0

切片截取可以通过设置下限和上限来截取切片
[lower-bound:upper-bound]


append()和copy()函数

如果想增加切片的容量，必须创建一个新的更大的切片吧原分片
的内容都拷贝过来

从拷贝切片的copy方法和向切片追加新元素的append方法


go语言范围

go语言中range关键字用于for循环中迭代数组(array)
切片(slice),通道(channel)或集合(map)的元素
在数组和切片中它返回元素的索引对应的值

在集合中返回key-value对

go语言Map(集合)

Map是一种无序的键值对的集合。Map最重要的一点可以通过key来
快速检索

